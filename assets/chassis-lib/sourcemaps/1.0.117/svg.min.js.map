{"version":3,"sources":["svg.min.js","svg.js"],"names":["fuoc","ss","document","createElement","str","createTextNode","appendChild","head","NGN","DOM","svg","Object","defineProperties","_cache","swap","privateconst","svgs","callback","me","this","i","length","attr","attributes","output","getAttribute","attrs","exec","trim","sep","replace","RegExp","split","e","console","error","Array","isArray","map","els","toLowerCase","x","idx","indexOf","name","push","value","filter","a","join","outerHTML","id","url","cleanCode","code","toString","match","viewbox","cache","fetchFile","_this","nodelike","require","readFileSync","resolve","NET","get","res","status","Error","responseText","update","section","body","nodeName","hasOwnProperty","_splice","forEach","sec","imgs","querySelectorAll","unfetched","keys","remaining","content","monitor","setInterval","clearInterval"],"mappings":"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","file":"svg.min.js","sourcesContent":["'use strict';\n\n/**\n * @class NGN.DOM.svg\n * Provides a way to easily manage SVG images within a document while\n * retaining the ability to style them with external CSS.\n * @singleton\n */\n/* This file should be loaded in the <head>, not at the end of the <body>.\n* By loading this script before the rest of the DOM, it will insert the\n* FOUC (Flash of Unstyled Content) CSS into the page BEFORE unstyled SVG images\n* are loaded. If this script is included in the <body>, the CSS will be loaded\n* AFTER the SVG images are loaded, meaning they may display briefly before\n* proper styling can be applied to the DOM.\n*/\n\n// Prevent FOUC\n// (function () {\n//   let ss = document.createElement('style')\n//   let str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}')\n//   ss.appendChild(str)\n//   document.head.appendChild(ss)\n// })()\nvar fuoc = function fuoc() {\n  var ss = document.createElement('style');\n  var str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}');\n  ss.appendChild(str);\n  document.head.appendChild(ss);\n};\nfuoc();\n\n// SVG Controller\nNGN.DOM = NGN.DOM || {};\nNGN.DOM.svg = {};\n\nObject.defineProperties(NGN.DOM.svg, {\n  /**\n   * @property {Object} _cache\n   * A cache of SVG images.\n   */\n  _cache: NGN.private({}),\n\n  /**\n   * @method swap\n   * Replace image tags with the SVG equivalent.\n   * @param {HTMLElement|NodeList} imgs\n   * The HTML element or node list containing the images that should be swapped out for SVG files.\n   * @param {function} [callback]\n   * Executed when the image swap is complete. There are no arguments passed to the callback.\n   * @private\n   */\n  swap: NGN.privateconst(function (svgs, callback) {\n    var me = this;\n    for (var i = 0; i < svgs.length; i++) {\n      var attr = svgs[i].attributes;\n      var output = me._cache[svgs[i].getAttribute('src')];\n      var attrs = [];\n\n      try {\n        attrs = /<svg(\\s.*=[\\\"\\'].*?[\\\"\\'])?>/i.exec(output)[1].trim();\n        var sep = /[\\\"\\']\\s/i.exec(attrs);\n        sep = sep !== null ? sep[0] : '\\\" ';\n        attrs = attrs.replace(new RegExp(sep, 'gi'), sep.replace(/\\s/ig, ',')).split(',');\n      } catch (e) {\n        console.error(e);\n      }\n\n      attrs = Array.isArray(attrs) ? attrs : [attrs];\n\n      var map = attrs.map(function (els) {\n        return els.split('=')[0].trim().toLowerCase();\n      });\n\n      for (var x = 0; x < attr.length; x++) {\n        var idx = map.indexOf(attr[x].name.toLowerCase());\n        if (idx < 0) {\n          attrs.push(attr[x].name + '=\"' + attr[x].value + '\"');\n        } else {\n          attrs[idx] = attr[x].name + '=\"' + attr[x].value + '\"';\n        }\n      }\n\n      attrs = attrs.filter(function (a) {\n        return a.split('=')[0].toLowerCase() !== 'src';\n      });\n\n      var svg = '<svg ' + attrs.join(' ') + '>';\n\n      svgs[i].outerHTML = output.replace(/<svg.*?>/i, svg);\n    }\n\n    callback && callback();\n  }),\n\n  /**\n   * @method id\n   * @param  {string} url\n   * Create an ID that can be used to reference an SVG symbol.\n   * @return {string}\n   * @private\n   */\n  id: NGN.privateconst(function (url) {\n    return url.replace(/.*\\:\\/\\/|[^A-Za-z0-9]|www/gi, '');\n  }),\n\n  /**\n   * @method cleanCode\n   * Captures all of the content between the <svg></svg> tag.\n   * @param  {string} code\n   * The code to clean up.\n   * @return {string}\n   * @private\n   */\n  cleanCode: NGN.privateconst(function (code) {\n    try {\n      return code.toString().trim().replace(/(\\r\\n|\\n|\\r)/gm, '').replace(/\\s+/g, ' ').match(/\\<svg.*\\<\\/svg\\>/igm, '')[0];\n    } catch (e) {\n      return '';\n    }\n  }),\n\n  /**\n   * @method viewbox\n   * Retrieves the viewbox attribute from the source code.\n   * @param  {string} code\n   * The code to extract the viewbox attribute from.\n   * @return {string}\n   * @private\n   */\n  viewbox: NGN.privateconst(function (code) {\n    return (/(viewbox=[\"'])(.*?)([\"'])/igm.exec(code.toString().trim())[2] || '0 0 100 100'\n    );\n  }),\n\n  cache: NGN.private(function (url, svg) {\n    this._cache[url] = svg;\n  }),\n\n  fetchFile: NGN.private(function (url, callback) {\n    var _this = this;\n\n    if (NGN.nodelike) {\n      callback && callback(require('fs').readFileSync(require('path').resolve(url).replace('file://', '')).toString());\n    } else {\n      (function () {\n        var me = _this;\n        NGN.NET.get(url, function (res) {\n          callback && callback(res.status !== 200 ? new Error(res.responseText) : me.cleanCode(res.responseText));\n        });\n      })();\n    }\n  }),\n\n  /**\n   * @method update\n   * Replace any <img src=\"*.svg\"> with the SVG equivalent.\n   * @param {HTMLElement|NodeList} section\n   * The HTML DOM element to update. All children of this element will also be updated.\n   * @param {function} callback\n   * Execute this function after the update is complete.\n   */\n  update: NGN.const(function (section, callback) {\n    if (typeof section === 'function') {\n      callback = section;\n      section = document.body;\n    } else {\n      section = section || document.body;\n    }\n\n    if (section.nodeName === '#text') {\n      return;\n    }\n\n    var me = this;\n    section = section.hasOwnProperty('length') === true ? NGN._splice(section) : [section];\n\n    section.forEach(function (sec) {\n      var imgs = sec.querySelectorAll('svg[src]');\n\n      // Loop through images, prime the cache.\n      for (var i = 0; i < imgs.length; i++) {\n        me._cache[imgs[i].getAttribute('src')] = me._cache[imgs[i].getAttribute('src')] || null;\n      }\n\n      // Fetch all of the unrecognized svg files\n      var unfetched = Object.keys(me._cache).filter(function (url) {\n        return me._cache[url] === null;\n      });\n\n      var remaining = unfetched.length;\n      unfetched.forEach(function (url) {\n        me.fetchFile(url, function (content) {\n          if (!(content instanceof Error)) {\n            me.cache(url, content);\n          }\n          remaining--;\n        });\n      });\n\n      // Monitor for download completion\n      var monitor = setInterval(function () {\n        if (remaining === 0) {\n          clearInterval(monitor);\n          me.swap(imgs, callback);\n        }\n      }, 5);\n    });\n  })\n});","/**\n * @class NGN.DOM.svg\n * Provides a way to easily manage SVG images within a document while\n * retaining the ability to style them with external CSS.\n * @singleton\n */\n/* This file should be loaded in the <head>, not at the end of the <body>.\n* By loading this script before the rest of the DOM, it will insert the\n* FOUC (Flash of Unstyled Content) CSS into the page BEFORE unstyled SVG images\n* are loaded. If this script is included in the <body>, the CSS will be loaded\n* AFTER the SVG images are loaded, meaning they may display briefly before\n* proper styling can be applied to the DOM.\n*/\n\n// Prevent FOUC\n// (function () {\n//   let ss = document.createElement('style')\n//   let str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}')\n//   ss.appendChild(str)\n//   document.head.appendChild(ss)\n// })()\nconst fuoc = function () {\n  var ss = document.createElement('style')\n  var str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}')\n  ss.appendChild(str)\n  document.head.appendChild(ss)\n}\nfuoc()\n\n// SVG Controller\nNGN.DOM = NGN.DOM || {}\nNGN.DOM.svg = {}\n\nObject.defineProperties(NGN.DOM.svg, {\n  /**\n   * @property {Object} _cache\n   * A cache of SVG images.\n   */\n  _cache: NGN.private({}),\n\n  /**\n   * @method swap\n   * Replace image tags with the SVG equivalent.\n   * @param {HTMLElement|NodeList} imgs\n   * The HTML element or node list containing the images that should be swapped out for SVG files.\n   * @param {function} [callback]\n   * Executed when the image swap is complete. There are no arguments passed to the callback.\n   * @private\n   */\n  swap: NGN.privateconst(function (svgs, callback) {\n    let me = this\n    for (let i = 0; i < svgs.length; i++) {\n      let attr = svgs[i].attributes\n      let output = me._cache[svgs[i].getAttribute('src')]\n      let attrs = []\n\n      try {\n        attrs = /<svg(\\s.*=[\\\"\\'].*?[\\\"\\'])?>/i.exec(output)[1].trim()\n        let sep = /[\\\"\\']\\s/i.exec(attrs)\n        sep = sep !== null ? sep[0] : '\\\" '\n        attrs = attrs.replace(new RegExp(sep, 'gi'), sep.replace(/\\s/ig, ',')).split(',')\n      } catch (e) {\n        console.error(e)\n      }\n\n      attrs = Array.isArray(attrs) ? attrs : [attrs]\n\n      let map = attrs.map(function (els) {\n        return els.split('=')[0].trim().toLowerCase()\n      })\n\n      for (let x = 0; x < attr.length; x++) {\n        let idx = map.indexOf(attr[x].name.toLowerCase())\n        if (idx < 0) {\n          attrs.push(attr[x].name + '=\"' + attr[x].value + '\"')\n        } else {\n          attrs[idx] = attr[x].name + '=\"' + attr[x].value + '\"'\n        }\n      }\n\n      attrs = attrs.filter(function (a) {\n        return a.split('=')[0].toLowerCase() !== 'src'\n      })\n\n      let svg = '<svg ' + attrs.join(' ') + '>'\n\n      svgs[i].outerHTML = output.replace(/<svg.*?>/i, svg)\n    }\n\n    callback && callback()\n  }),\n\n  /**\n   * @method id\n   * @param  {string} url\n   * Create an ID that can be used to reference an SVG symbol.\n   * @return {string}\n   * @private\n   */\n  id: NGN.privateconst(function (url) {\n    return url.replace(/.*\\:\\/\\/|[^A-Za-z0-9]|www/gi, '')\n  }),\n\n  /**\n   * @method cleanCode\n   * Captures all of the content between the <svg></svg> tag.\n   * @param  {string} code\n   * The code to clean up.\n   * @return {string}\n   * @private\n   */\n  cleanCode: NGN.privateconst(function (code) {\n    try {\n      return code.toString().trim().replace(/(\\r\\n|\\n|\\r)/gm, '').replace(/\\s+/g, ' ').match(/\\<svg.*\\<\\/svg\\>/igm, '')[0]\n    } catch (e) {\n      return ''\n    }\n  }),\n\n  /**\n   * @method viewbox\n   * Retrieves the viewbox attribute from the source code.\n   * @param  {string} code\n   * The code to extract the viewbox attribute from.\n   * @return {string}\n   * @private\n   */\n  viewbox: NGN.privateconst(function (code) {\n    return /(viewbox=[\"'])(.*?)([\"'])/igm.exec(code.toString().trim())[2] || '0 0 100 100'\n  }),\n\n  cache: NGN.private(function (url, svg) {\n    this._cache[url] = svg\n  }),\n\n  fetchFile: NGN.private(function (url, callback) {\n    if (NGN.nodelike) {\n      callback && callback(require('fs').readFileSync(require('path').resolve(url).replace('file://', '')).toString())\n    } else {\n      let me = this\n      NGN.NET.get(url, function (res) {\n        callback && callback(res.status !== 200 ? new Error(res.responseText) : me.cleanCode(res.responseText))\n      })\n    }\n  }),\n\n  /**\n   * @method update\n   * Replace any <img src=\"*.svg\"> with the SVG equivalent.\n   * @param {HTMLElement|NodeList} section\n   * The HTML DOM element to update. All children of this element will also be updated.\n   * @param {function} callback\n   * Execute this function after the update is complete.\n   */\n  update: NGN.const(function (section, callback) {\n    if (typeof section === 'function') {\n      callback = section\n      section = document.body\n    } else {\n      section = section || document.body\n    }\n\n    if (section.nodeName === '#text') {\n      return\n    }\n\n    let me = this\n    section = section.hasOwnProperty('length') === true\n      ? NGN._splice(section)\n      : [section]\n\n    section.forEach(function (sec) {\n      let imgs = sec.querySelectorAll('svg[src]')\n\n      // Loop through images, prime the cache.\n      for (let i = 0; i < imgs.length; i++) {\n        me._cache[imgs[i].getAttribute('src')] = me._cache[imgs[i].getAttribute('src')] || null\n      }\n\n      // Fetch all of the unrecognized svg files\n      let unfetched = Object.keys(me._cache).filter(function (url) {\n        return me._cache[url] === null\n      })\n\n      let remaining = unfetched.length\n      unfetched.forEach(function (url) {\n        me.fetchFile(url, function (content) {\n          if (!(content instanceof Error)) {\n            me.cache(url, content)\n          }\n          remaining--\n        })\n      })\n\n      // Monitor for download completion\n      let monitor = setInterval(function () {\n        if (remaining === 0) {\n          clearInterval(monitor)\n          me.swap(imgs, callback)\n        }\n      }, 5)\n    })\n  })\n})\n"],"sourceRoot":"/source/"}