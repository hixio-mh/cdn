{"version":3,"sources":["model.js","model.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Model","_NGN$EventEmitter","config","this","_this","getPrototypeOf","me","idAttribute","NGN","privateconst","fields","id","required","type","String","default","joins","relationships","virtuals","validators","validation","coalesce","isNew","isDestroyed","oid","autoid","benchmark","setUnmodified","checksum","changelog","allowInvalidSave","disableDataValidation","invalidDataAttributes","initialDataAttributes","_nativeValidators","min","_min","Array","Number","trim","Date","parse","max","_max","enum","valid","indexOf","field","hasOwnProperty","_dataMap","dataMap","_reverseDataMap","raw","rawjoins","_store","allfields","datafields","concat","virtualdatafields","filter","a","Error","join","keys","forEach","addField","v","get","apply","addRelationshipField","events","BUS","eventName","on","args","slice","arguments","push","unshift","emit","property","validator","console","warn","toUpperCase","isArray","test","attribute","_pass","rule","pass","_i","fieldname","_obj","rtn","nonEnumerableProperties","substr","undefined","enumerableProperties","dsc","getOwnPropertyDescriptor","set","name","refs","toJSON","r","data","fieldcfg","suppressEvents","cfg","toLowerCase","DATA","util","GUID","old","c","action","new","validate","addValidator","pattern","val","fn","entityType","Store","model","storeCfg","applyStoreMonitor","applyModelMonitor","delta","_this2","record","pop","splice","back","reverse","change","removeRelationshipField","removeField","reverseMap","tmp","getRelated","load","rawjoin","JSON","stringify","_this3","_ret2","rmap","attr","_this4","d","serialize","EventEmitter","ModelLoader","Entity","nodelike","module","exports"],"mappings":"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","file":"model.min.js","sourcesContent":["'use strict'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nclass Model extends NGN.EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super()\n\n    let me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields ||\n        {\n          id: {\n            required: true,\n            type: String,\n            'default': config.id || null\n          }\n        }\n      ),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum\n        this.changelog = []\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function (min, value) {\n          if (value instanceof Array) {\n            return value.length >= min\n          }\n          if (value instanceof Number) {\n            return value >= min\n          }\n          if (value instanceof String) {\n            return value.trim().length >= min\n          }\n          if (value instanceof Date) {\n            return value.parse() >= min.parse()\n          }\n          return false\n        },\n        max: function (max, value) {\n          if (value instanceof Array) {\n            return value.length <= max\n          }\n          if (value instanceof Number) {\n            return value <= max\n          }\n          if (value instanceof String) {\n            return value.trim().length <= max\n          }\n          if (value instanceof Date) {\n            return value.parse() <= max.parse()\n          }\n          return false\n        },\n        enum: function (valid, value) {\n          return valid.indexOf(value) >= 0\n        },\n        required: function (field) {\n          return this.hasOwnProperty(field)\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    })\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    let allfields = this.datafields.concat(this.virtualdatafields).concat(this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i\n    })\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.')\n    }\n\n    // Make sure an ID reference is available.\n    if (!this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      }\n    }\n\n    // Add fields\n    Object.keys(this.fields).forEach(function (field) {\n      me.addField(field, true)\n    })\n\n    // Add virtuals\n    Object.keys(this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me)\n      }))\n    })\n\n    // Add relationships\n    Object.keys(this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true)\n    })\n\n    let events = [\n      'field.update',\n      'field.create',\n      'field.remove',\n      'field.invalid',\n      'validator.add',\n      'validator.remove',\n      'relationship.create',\n      'relationship.remove'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.push(me)\n          args.unshift(eventName)\n          NGN.BUS.emit.apply(NGN.BUS, args)\n        })\n      })\n    }\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n  get modified () {\n    return this.checksum !== this.benchmark\n  }\n\n  /**\n   * @cfgproperty {String/Number/Date} [id=null]\n   * The unique ID of the model object. If #idAttribute is defined,\n   * this will get/set the #idAttribute value.\n   */\n  get id () {\n    return this.oid\n  }\n\n  set id (value) {\n    this.oid = value\n  }\n\n  /**\n   * @property checksum\n   * The unique checksum of the record (i.e. a record fingerprint).\n   * This will change as the data changes.\n   */\n  get checksum () {\n    return NGN.DATA.util.checksum(JSON.stringify(this.data))\n  }\n\n  /**\n   * @property {Object} dataMap\n   * The current data map.\n   * @private\n   */\n  get dataMap () {\n    return this._dataMap\n  }\n\n  set dataMap (value) {\n    this._dataMap = value\n    this._reverseDataMap = null\n  }\n\n  /**\n   * @property {NGN.DATA.Store} store\n   * If a store is associated with the model, this will\n   * provide a reference to it. If there is no store, this\n   * will return `null`.\n   */\n  get datastore () {\n    return this._store\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the record is valid.\n   */\n  get valid () {\n    return this.invalidDataAttributes.length === 0\n  }\n\n  /**\n   * @property datafields\n   * Provides an array of data fields associated with the model.\n   * @returns {String[]}\n   */\n  get datafields () {\n    return Object.keys(this.fields)\n  }\n\n  /**\n   * @property reslationships\n   * Provides an array of join fields associated with the model.\n   * @returns {String[]}\n   */\n  get relationships () {\n    return Object.keys(this.joins)\n  }\n\n  /**\n   * @property virtualdatafields\n   * Provides an array of virtual data fields associated with the model.\n   * @returns {String[]}\n   */\n  get virtualdatafields () {\n    return Object.keys(this.virtuals)\n  }\n\n  /**\n   * @property {object} reverseMap\n   * Reverses the data map. For example, if the original #dataMap\n   * looks like:\n   *\n   * ```js\n   * {\n   *    firstname: 'gn',\n   *    lastname: 'sn\n   * }\n   * ```\n   *\n   * The reverse map will look like:\n   *\n   * ```js\n   * {\n   *    gn: 'firstname',\n   *    sn: 'lastname\n   * }\n   * ```\n   */\n  get reverseMap () {\n    if (this.dataMap !== null) {\n      if (this._reverseDataMap !== null) {\n        return this._reverseDataMap\n      }\n      let rmap = {}\n      let me = this\n      Object.keys(this._dataMap).forEach(function (attr) {\n        rmap[me._dataMap[attr]] = attr\n      })\n      this._reverseDataMap = rmap\n      return rmap\n    }\n    return null\n  }\n\n  /**\n    * @property data\n    * Creates a JSON representation of the data entity. This is\n    * a record that can be persisted to a database or other data store.\n    * @readonly.\n    */\n  get data () {\n    let d = this.serialize()\n    if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n      d[this.idAttribute] = this[this.idAttribute]\n    }\n    if (this.dataMap) {\n      let me = this\n      // Loop through the map keys\n      Object.keys(this.dataMap).forEach(function (key) {\n        // If the node contains key, make the mapping\n        if (d.hasOwnProperty(key)) {\n          if (d[key] instanceof NGN.DATA.Model) {\n            d[me.dataMap[key]] = d[key].data\n          } else {\n            d[me.dataMap[key]] = d[key]\n          }\n          delete d[key]\n        }\n      })\n    }\n    return d\n  }\n\n  /**\n   * @property history\n   * The history of the entity (i.e. changelog).The history\n   * is shown from most recent to oldest change. Keep in mind that\n   * some actions, such as adding new custom fields on the fly, may\n   * be triggered before other updates.\n   * @returns {array}\n   */\n  get history () {\n    return this.changelog.reverse()\n  }\n\n  /**\n    * @method addValidator\n    * Add or update a validation rule for a specific model property.\n    * @param {String} field\n    * The data field to test.\n    * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n    * The validation used to test the property value. This should return\n    * `true` when the data is valid and `false` when it is not.\n    *\n    * * When this is a _function_, the value is passed to it as an argument.\n    * * When this is a _String_, the value is compared for an exact match (case sensitive)\n    * * When this is a _Number_, the value is compared for equality.\n    * * When this is a _Date_, the value is compared for exact equality.\n    * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n    * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n    * * When this is _an array of dates_, the value is compared to each date for equality.\n    * @fires validator.add\n    */\n  addValidator (property, validator) {\n    if (!this.hasOwnProperty(property)) {\n      console.warn('No validator could be create for ' + property.toUpperCase() + '. It is not an attribute of ' + this.type.toUpperCase() + '.')\n      return\n    }\n\n    switch (typeof validator) {\n      case 'function':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(validator)\n        this.emit('validator.add', property)\n        break\n      case 'object':\n        if (Array.isArray(validator)) {\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.indexOf(value) >= 0\n          })\n          this.emit('validator.add', property)\n        } else if (validator.test) { // RegExp\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.test(value)\n          })\n          this.emit('validator.add', property)\n        } else {\n          console.warn('No validator could be created for ' + property.toUpperCase() + '. The validator appears to be invalid.')\n        }\n        break\n      case 'string':\n      case 'number':\n      case 'date':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(function (value) {\n          return value === validator\n        })\n        this.emit('validator.add', property)\n        break\n      default:\n        console.warn('No validator could be create for ' + property.toUpperCase() + '. The validator appears to be invalid.')\n    }\n  }\n\n  /**\n    * @method removeValidator\n    * Remove a data validator from the object.\n    * @param {String} attribute\n    * The name of the attribute to remove from the validators.\n    * @fires validator.remove\n    */\n  removeValidator (attribute) {\n    if (this.validators.hasOwnProperty(attribute)) {\n      delete this.validators[attribute]\n      this.emit('validator.remove', attribute)\n    }\n  }\n\n  /**\n    * @method validate\n    * Validate one or all attributes of the data.\n    * @param {String} [attribute=null]\n    * Validate a specific attribute. By default, all attributes are tested.\n    * @private\n    * @returns {Boolean}\n    * Returns true or false based on the validity of data.\n    */\n  validate (attribute) {\n    let _pass = true\n    let me = this\n\n    // Single Attribute Validation\n    if (attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        for (let i = 0; i < this.validators[attribute].length; i++) {\n          if (!me.validators[attribute][i](me[attribute])) {\n            me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute)\n            return false\n          }\n        }\n        return true\n      }\n    }\n\n    // Validate All Attributes\n    for (let rule in this.validators) {\n      if (this[rule]) {\n        if (this.validators.hasOwnProperty(rule)) {\n          let pass = true\n          for (let i = 0; i < this.validators[rule].length; i++) {\n            pass = this.validators[rule][i](this[rule])\n            if (!pass) {\n              break\n            }\n          }\n          if (!pass && this.invalidDataAttributes.indexOf(rule) < 0) {\n            this.invalidDataAttributes.push(rule)\n          }\n\n          if (_pass && !pass) {\n            _pass = false\n          }\n        }\n      }\n    }\n\n    return true\n  }\n\n  /**\n   * @method getRelationshipField\n   * Provides specific detail/configuration about a join/relationship.\n   * @param {String} fieldname\n   * The name of the field.\n   * @returns {Object}\n   */\n  getRelationshipField (fieldname) {\n    return this.joins[fieldname]\n  }\n\n  /**\n   * @method hasRelationship\n   * Indicates a data join exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasRelationship (fieldname) {\n    return this.joins.hasOwnProperty(fieldname)\n  }\n\n  /**\n     * @method getDataField\n     * Provides specific detail/configuration about a field.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Object}\n     */\n  getDataField (fieldname) {\n    return this.fields[fieldname]\n  }\n\n  /**\n   * @method hasDataField\n   * Indicates a data field exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasDataField (fieldname) {\n    return this.fields.hasOwnProperty(fieldname)\n  }\n\n  /**\n    * @method serialize\n    * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n    * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n    *\n    * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n    * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n    *\n    * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n    * The model itself can be returned using #getXRef.\n    * @param {Object} [obj]\n    * Defaults to this object.\n    * @protected\n    */\n  serialize (obj) {\n    let _obj = obj || this.raw\n    let rtn = {}\n\n    for (let key in _obj) {\n      _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || ''\n      if (this.fields.hasOwnProperty(key)) {\n        key = key === 'id' ? this.idAttribute : key\n        if ((_obj.hasOwnProperty(key) && (_obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)))) || (_obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0)) {\n          let dsc = Object.getOwnPropertyDescriptor(_obj, key)\n          if (!dsc.set) {\n            // Handle everything else\n            switch (typeof dsc.value) {\n              case 'function':\n                // Support date & regex proxies\n                if (dsc.value.name === 'Date') {\n                  rtn[key] = _obj[key].refs.toJSON()\n                } else if (dsc.value.name === 'RegExp') {\n                  rtn[key] = dsc.value()\n                }\n                break\n              case 'object':\n                // Support array proxies\n                if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                  _obj[key] = _obj[key].slice(0)\n                }\n\n                rtn[key] = _obj[key]\n                break\n              default:\n                rtn[key] = _obj[key]\n                break\n            }\n          }\n        }\n      }\n    }\n\n    let me = this\n    this.relationships.forEach(function (r) {\n      rtn[r] = me[r].data\n    })\n\n    return rtn\n  }\n\n  /**\n   * @method addField\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {object} [fieldonfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (field, fieldcfg, suppressEvents) {\n    if (typeof fieldcfg === 'boolean') {\n      suppressEvents = fieldcfg\n      fieldcfg = null\n    }\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    let me = this\n    let cfg = null\n    if (field.toLowerCase() !== 'id') {\n      if (typeof field === 'object') {\n        if (!field.name) {\n          throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.')\n        }\n        cfg = field\n        field = cfg.name\n        delete cfg.name\n      }\n\n      if (me[field] !== undefined) {\n        console.warn(field + ' data field defined multiple times. Only the last defintion will be used.')\n        delete me[field]\n      }\n\n      // Create the data field as an object attribute & getter/setter\n      me.fields[field] = cfg || me.fields[field] || {}\n      me.fields[field].required = NGN.coalesce(me.fields[field].required, false)\n      me.fields[field].type = NGN.coalesce(me.fields[field].type, String)\n      if (field === me.idAttribute && me.autoid === true) {\n        me.fields[field].type = String\n        me.fields[field]['default'] = NGN.DATA.util.GUID()\n      } else {\n        me.fields[field]['default'] = me.fields[field]['default'] || null\n      }\n      me.raw[field] = me.fields[field]['default']\n      me[field] = me.raw[field]\n\n      Object.defineProperty(me, field, {\n        get: function () {\n          return me.raw[field]\n        },\n        set: function (value) {\n          let old = me.raw[field]\n          me.raw[field] = value\n          let c = {\n            action: 'update',\n            field: field,\n            old: old,\n            new: me.raw[field]\n          }\n          this.changelog.push(c)\n          this.emit('field.update', c)\n          if (!me.validate(field)) {\n            me.emit('field.invalid', {\n              field: field\n            })\n          }\n        }\n      })\n\n      if (!suppressEvents) {\n        let c = {\n          action: 'create',\n          field: field\n        }\n        this.changelog.push(c)\n        this.emit('field.create', c)\n      }\n\n      // Add field validators\n      if (me.fields.hasOwnProperty(field)) {\n        if (me.fields[field].hasOwnProperty('pattern')) {\n          me.addValidator(field, me.fields[field].pattern)\n        }\n        ['min', 'max', 'enum'].forEach(function (v) {\n          if (me.fields[field].hasOwnProperty(v)) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators[v](me.fields[field], val)\n            })\n          }\n        })\n        if (me.fields[field].hasOwnProperty('required')) {\n          if (me.fields[field].required) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators.required(val)\n            })\n          }\n        }\n        if (me.fields[field].hasOwnProperty('validate')) {\n          if (typeof me.fields[field] === 'function') {\n            me.addValidator(field, function (val) {\n              return me.fields[field](val)\n            })\n          } else {\n            console.warn('Invalid custom validation function. The value passed to the validate attribute must be a function.')\n          }\n        }\n      }\n    } else if (me.id === null && me.autoid) {\n      me.id = NGN.DATA.util.GUID()\n    }\n  }\n\n  /**\n   * @method addVirtual\n   * Add a virtual field dynamically.\n   * @param {string} name\n   * The name of the attribute to add.\n   * @param {function} handler\n   * The synchronous method (or generator) that produces\n   * the desired output.\n   */\n  addVirtual (name, fn) {\n    let me = this\n    Object.defineProperty(this, name, {\n      get: function () {\n        return fn.apply(me)\n      }\n    })\n  }\n\n  /**\n   * @method addRelationshipField\n   * Join another model dynamically.\n   * @param {string} name\n   * The name of the field to add.\n   * @param {Object|NGN.DATA.Model} config\n   * The configuration or data model type. This follows the same syntax\n   * defined in the #joins attribute.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addRelationshipField (name, cfg, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n\n    if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n      throw new Error(name + ' already exists. It cannot be added to the model again.')\n    }\n\n    if (typeof cfg === 'function' || typeof cfg === 'object' && !cfg.hasOwnProperty('type')) {\n      cfg = {\n        type: cfg\n      }\n    }\n\n    if (!cfg.type) {\n      throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.')\n    }\n\n    cfg.required = NGN.coalesce(cfg.required, true)\n    cfg.default = cfg.default || null\n\n    const me = this\n    let entityType = 'model'\n    if (cfg.type instanceof NGN.DATA.Store) {\n      entityType = 'store'\n    } else if (typeof cfg.type === 'object') {\n      if (cfg.type.model) {\n        entityType = 'store'\n      }\n    }\n\n    if (entityType === 'store') {\n      let storeCfg = {}\n\n      if (cfg.type instanceof NGN.DATA.Store) {\n        this.rawjoins[name] = cfg.type\n        return\n      } else if (cfg.type.model) {\n        storeCfg = cfg.type\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.')\n      }\n\n      this.rawjoins[name] = new NGN.DATA.Store(storeCfg)\n      this.applyStoreMonitor(name)\n    } else if (!cfg.type.data) {\n      this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type()  // eslint-disable-line new-cap\n      this.applyModelMonitor(name)\n    } else if (cfg.type.data) {\n      this.rawjoins[name] = cfg.type\n      this.applyStoreMonitor(name)\n    } else {\n      throw new Error('Nested store configuration is invalid or was not recognized.')\n    }\n\n    Object.defineProperty(this, name, {\n      enumerable: true,\n      get: function () {\n        return me.rawjoins[name]\n      }\n    })\n\n    if (!suppressEvents) {\n      let c = {\n        action: 'create',\n        field: name\n      }\n      this.changelog.push(c)\n      this.emit('relationship.create', c)\n    }\n  }\n\n  /**\n   * @method applyModelMonitor\n   * Applies event handlers for bubbling model events.\n   * @param {string} field\n   * The relationship field name.\n   * @private\n   */\n  applyModelMonitor (name) {\n    const model = this.rawjoins[name]\n    const me = this\n\n    model.on('field.update', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.old,\n        new: delta.new,\n        join: true\n      })\n    })\n\n    model.on('field.create', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: null,\n        new: null,\n        join: true\n      })\n    })\n\n    model.on('field.remove', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.value,\n        new: null,\n        join: true\n      })\n    })\n  }\n\n  /**\n   * @method applyStoreMonitor\n   * Applies event handlers for store data.\n   * @param {string} name\n   * Name of the raw join.\n   * @private\n   */\n  applyStoreMonitor (name) {\n    if (!this.rawjoins.hasOwnProperty(name)) {\n      return\n    }\n    if (this.rawjoins[name].hasOwnProperty('proxy')) {\n      let me = this\n      this.rawjoins[name].on('record.create', function (record) {\n        let old = me[name].data\n        old.pop()\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n        me.emit('field.update', c)\n      })\n      this.rawjoins[name].on('record.update', function (record, delta) {\n        if (!delta) {\n          return\n        }\n        let c = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          join: true,\n          old: delta.old,\n          new: delta.new\n        }\n        me.emit('field.update', c)\n      })\n      this.rawjoins[name].on('record.delete', function (record) {\n        let old = me[name].data\n        old.push(record.data)\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n        me.emit('field.update', c)\n      })\n    }\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   */\n  removeField (name) {\n    if (this.raw.hasOwnProperty(name)) {\n      let val = this.raw[name]\n      delete this[name]\n      delete this.fields[name] // eslint-disable-line no-undef\n      delete this.raw[name] // eslint-disable-line no-undef\n      if (this.invalidDataAttributes.indexOf(name) >= 0) {\n        this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1)\n      }\n      let c = {\n        action: 'delete',\n        field: name,\n        value: val\n      }\n      this.emit('field.remove', c)\n      this.changelog.push(c)\n    }\n  }\n\n  /**\n   * @method removeVirtual\n   * Remove a virtual field.\n   * @param {string} name\n   * Name of the field.\n   */\n  removeVirtual (name) {\n    delete this[name]\n  }\n\n  /**\n   * @method removeRelationshipField\n   * Remove an existing join dynamically.\n   * @param {string} name\n   * The name of the relationship field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  removeRelationshipField (name, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    if (this.joins.hasOwnProperty(name)) {\n      let val = this.rawjoins[name]\n      delete this.rawjoins[name]\n      delete this[name]\n      delete this.joins[name]\n      if (!suppressEvents) {\n        let c = {\n          action: 'delete',\n          field: name,\n          old: val,\n          join: true\n        }\n        this.changelog.push(c)\n        this.emit('relationship.remove', c)\n      }\n    }\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog. It is possible to undo an undo (i.e. redo).\n   * This works with relationship creating/removing relationship fields,\n   * but not updates to the related model. To undo changes to a relationship\n   * field, the `undo()` method _of the related model_ must be called.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   */\n  undo (back) {\n    back = back || 1\n    let old = this.changelog.splice(this.changelog.length - back, back)\n    let me = this\n\n    old.reverse().forEach(function (change) {\n      if (!(typeof change.join === 'boolean' ? change.join : false)) {\n        switch (change.action) {\n          case 'update':\n            me[change.field] = change.old\n            break\n          case 'create':\n            me.removeField(change.field)\n            break\n          case 'delete':\n            me.addField(change.field)\n            me[change.field] = me.old\n            break\n        }\n      } else {\n        switch (change.action) {\n          case 'create':\n            me.removeRelationshipField(change.field)\n            break\n          case 'delete':\n            me.addRelationshipField(change.field)\n            me[change.field] = change.old\n            break\n        }\n      }\n    })\n  }\n\n  /**\n   * @method load\n   * Load a data record. This clears the #history. #modified\n   * will be set to `false`, as though the record has been untouched.\n   * @param {object} data\n   * The data to apply to the model.\n   */\n  load (data) {\n    data = data || {}\n\n    // Handle data maps\n    let me = this\n    if (this._dataMap !== null) {\n      Object.keys(this.reverseMap).forEach(function (key) {\n        if (data.hasOwnProperty(key)) {\n          data[me.reverseMap[key]] = data[key]\n          delete data[key]\n        }\n      })\n    }\n\n    // Loop through the keys and add data fields\n    Object.keys(data).forEach(function (key) {\n      if (me.fields.hasOwnProperty(key)) {\n        if (me.raw.hasOwnProperty(key)) {\n          me.raw[key] = data[key]\n        } else if (key === me.idAttribute) {\n          me.id = data[key]\n        }\n      } else if (me.joins.hasOwnProperty(key)) {\n        let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n        tmp.load(data[key])\n        me.rawjoin[key] = tmp\n      } else {\n        console.warn(key + ' was specified as a data field but is not defined in the model.')\n      }\n    })\n\n    this.setUnmodified()\n  }\n}\n\nNGN.DATA = NGN.DATA || {}\n\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    const ModelLoader = function (data) {\n      let model = new Model(cfg)\n      if (data) {\n        model.load(data)\n      }\n      return model\n    }\n\n    return ModelLoader\n  }),\n\n  Entity: NGN.private(Model)\n})\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA\n}\n","'use strict';\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Model = function (_NGN$EventEmitter) {\n  _inherits(Model, _NGN$EventEmitter);\n\n  function Model(config) {\n    _classCallCheck(this, Model);\n\n    config = config || {};\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Model).call(this));\n\n    var me = _this;\n\n    Object.defineProperties(_this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields || {\n        id: {\n          required: true,\n          type: String,\n          'default': config.id || null\n        }\n      }),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[_this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum;\n        this.changelog = [];\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function min(_min, value) {\n          if (value instanceof Array) {\n            return value.length >= _min;\n          }\n          if (value instanceof Number) {\n            return value >= _min;\n          }\n          if (value instanceof String) {\n            return value.trim().length >= _min;\n          }\n          if (value instanceof Date) {\n            return value.parse() >= _min.parse();\n          }\n          return false;\n        },\n        max: function max(_max, value) {\n          if (value instanceof Array) {\n            return value.length <= _max;\n          }\n          if (value instanceof Number) {\n            return value <= _max;\n          }\n          if (value instanceof String) {\n            return value.trim().length <= _max;\n          }\n          if (value instanceof Date) {\n            return value.parse() <= _max.parse();\n          }\n          return false;\n        },\n        enum: function _enum(valid, value) {\n          return valid.indexOf(value) >= 0;\n        },\n        required: function required(field) {\n          return this.hasOwnProperty(field);\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    });\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    var allfields = _this.datafields.concat(_this.virtualdatafields).concat(_this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i;\n    });\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.');\n    }\n\n    // Make sure an ID reference is available.\n    if (!_this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      };\n    }\n\n    // Add fields\n    Object.keys(_this.fields).forEach(function (field) {\n      me.addField(field, true);\n    });\n\n    // Add virtuals\n    Object.keys(_this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me);\n      }));\n    });\n\n    // Add relationships\n    Object.keys(_this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true);\n    });\n\n    var events = ['field.update', 'field.create', 'field.remove', 'field.invalid', 'validator.add', 'validator.remove', 'relationship.create', 'relationship.remove'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.push(me);\n          args.unshift(eventName);\n          NGN.BUS.emit.apply(NGN.BUS, args);\n        });\n      });\n    }\n    return _this;\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n\n\n  _createClass(Model, [{\n    key: 'addValidator',\n\n\n    /**\n      * @method addValidator\n      * Add or update a validation rule for a specific model property.\n      * @param {String} field\n      * The data field to test.\n      * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n      * The validation used to test the property value. This should return\n      * `true` when the data is valid and `false` when it is not.\n      *\n      * * When this is a _function_, the value is passed to it as an argument.\n      * * When this is a _String_, the value is compared for an exact match (case sensitive)\n      * * When this is a _Number_, the value is compared for equality.\n      * * When this is a _Date_, the value is compared for exact equality.\n      * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n      * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n      * * When this is _an array of dates_, the value is compared to each date for equality.\n      * @fires validator.add\n      */\n    value: function addValidator(property, validator) {\n      if (!this.hasOwnProperty(property)) {\n        console.warn('No validator could be create for ' + property.toUpperCase() + '. It is not an attribute of ' + this.type.toUpperCase() + '.');\n        return;\n      }\n\n      switch (typeof validator === 'undefined' ? 'undefined' : _typeof(validator)) {\n        case 'function':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(validator);\n          this.emit('validator.add', property);\n          break;\n        case 'object':\n          if (Array.isArray(validator)) {\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.indexOf(value) >= 0;\n            });\n            this.emit('validator.add', property);\n          } else if (validator.test) {\n            // RegExp\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.test(value);\n            });\n            this.emit('validator.add', property);\n          } else {\n            console.warn('No validator could be created for ' + property.toUpperCase() + '. The validator appears to be invalid.');\n          }\n          break;\n        case 'string':\n        case 'number':\n        case 'date':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(function (value) {\n            return value === validator;\n          });\n          this.emit('validator.add', property);\n          break;\n        default:\n          console.warn('No validator could be create for ' + property.toUpperCase() + '. The validator appears to be invalid.');\n      }\n    }\n\n    /**\n      * @method removeValidator\n      * Remove a data validator from the object.\n      * @param {String} attribute\n      * The name of the attribute to remove from the validators.\n      * @fires validator.remove\n      */\n\n  }, {\n    key: 'removeValidator',\n    value: function removeValidator(attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        delete this.validators[attribute];\n        this.emit('validator.remove', attribute);\n      }\n    }\n\n    /**\n      * @method validate\n      * Validate one or all attributes of the data.\n      * @param {String} [attribute=null]\n      * Validate a specific attribute. By default, all attributes are tested.\n      * @private\n      * @returns {Boolean}\n      * Returns true or false based on the validity of data.\n      */\n\n  }, {\n    key: 'validate',\n    value: function validate(attribute) {\n      var _pass = true;\n      var me = this;\n\n      // Single Attribute Validation\n      if (attribute) {\n        if (this.validators.hasOwnProperty(attribute)) {\n          for (var i = 0; i < this.validators[attribute].length; i++) {\n            if (!me.validators[attribute][i](me[attribute])) {\n              me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute);\n              return false;\n            }\n          }\n          return true;\n        }\n      }\n\n      // Validate All Attributes\n      for (var rule in this.validators) {\n        if (this[rule]) {\n          if (this.validators.hasOwnProperty(rule)) {\n            var pass = true;\n            for (var _i = 0; _i < this.validators[rule].length; _i++) {\n              pass = this.validators[rule][_i](this[rule]);\n              if (!pass) {\n                break;\n              }\n            }\n            if (!pass && this.invalidDataAttributes.indexOf(rule) < 0) {\n              this.invalidDataAttributes.push(rule);\n            }\n\n            if (_pass && !pass) {\n              _pass = false;\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n\n    /**\n     * @method getRelationshipField\n     * Provides specific detail/configuration about a join/relationship.\n     * @param {String} fieldname\n     * The name of the field.\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'getRelationshipField',\n    value: function getRelationshipField(fieldname) {\n      return this.joins[fieldname];\n    }\n\n    /**\n     * @method hasRelationship\n     * Indicates a data join exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasRelationship',\n    value: function hasRelationship(fieldname) {\n      return this.joins.hasOwnProperty(fieldname);\n    }\n\n    /**\n       * @method getDataField\n       * Provides specific detail/configuration about a field.\n       * @param {String} fieldname\n       * The name of the data field.\n       * @returns {Object}\n       */\n\n  }, {\n    key: 'getDataField',\n    value: function getDataField(fieldname) {\n      return this.fields[fieldname];\n    }\n\n    /**\n     * @method hasDataField\n     * Indicates a data field exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasDataField',\n    value: function hasDataField(fieldname) {\n      return this.fields.hasOwnProperty(fieldname);\n    }\n\n    /**\n      * @method serialize\n      * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n      * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n      *\n      * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n      * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n      *\n      * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n      * The model itself can be returned using #getXRef.\n      * @param {Object} [obj]\n      * Defaults to this object.\n      * @protected\n      */\n\n  }, {\n    key: 'serialize',\n    value: function serialize(obj) {\n      var _obj = obj || this.raw;\n      var rtn = {};\n\n      for (var key in _obj) {\n        _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || '';\n        if (this.fields.hasOwnProperty(key)) {\n          key = key === 'id' ? this.idAttribute : key;\n          if (_obj.hasOwnProperty(key) && _obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)) || _obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0) {\n            var dsc = Object.getOwnPropertyDescriptor(_obj, key);\n            if (!dsc.set) {\n              // Handle everything else\n              switch (_typeof(dsc.value)) {\n                case 'function':\n                  // Support date & regex proxies\n                  if (dsc.value.name === 'Date') {\n                    rtn[key] = _obj[key].refs.toJSON();\n                  } else if (dsc.value.name === 'RegExp') {\n                    rtn[key] = dsc.value();\n                  }\n                  break;\n                case 'object':\n                  // Support array proxies\n                  if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                    _obj[key] = _obj[key].slice(0);\n                  }\n\n                  rtn[key] = _obj[key];\n                  break;\n                default:\n                  rtn[key] = _obj[key];\n                  break;\n              }\n            }\n          }\n        }\n      }\n\n      var me = this;\n      this.relationships.forEach(function (r) {\n        rtn[r] = me[r].data;\n      });\n\n      return rtn;\n    }\n\n    /**\n     * @method addField\n     * Add a data field after the initial model definition.\n     * @param {string} fieldname\n     * The name of the field.\n     * @param {object} [fieldonfiguration=null]\n     * The field configuration (see cfg#fields for syntax).\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addField',\n    value: function addField(field, fieldcfg, suppressEvents) {\n      if (typeof fieldcfg === 'boolean') {\n        suppressEvents = fieldcfg;\n        fieldcfg = null;\n      }\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      var me = this;\n      var cfg = null;\n      if (field.toLowerCase() !== 'id') {\n        if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object') {\n          if (!field.name) {\n            throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.');\n          }\n          cfg = field;\n          field = cfg.name;\n          delete cfg.name;\n        }\n\n        if (me[field] !== undefined) {\n          console.warn(field + ' data field defined multiple times. Only the last defintion will be used.');\n          delete me[field];\n        }\n\n        // Create the data field as an object attribute & getter/setter\n        me.fields[field] = cfg || me.fields[field] || {};\n        me.fields[field].required = NGN.coalesce(me.fields[field].required, false);\n        me.fields[field].type = NGN.coalesce(me.fields[field].type, String);\n        if (field === me.idAttribute && me.autoid === true) {\n          me.fields[field].type = String;\n          me.fields[field]['default'] = NGN.DATA.util.GUID();\n        } else {\n          me.fields[field]['default'] = me.fields[field]['default'] || null;\n        }\n        me.raw[field] = me.fields[field]['default'];\n        me[field] = me.raw[field];\n\n        Object.defineProperty(me, field, {\n          get: function get() {\n            return me.raw[field];\n          },\n          set: function set(value) {\n            var old = me.raw[field];\n            me.raw[field] = value;\n            var c = {\n              action: 'update',\n              field: field,\n              old: old,\n              new: me.raw[field]\n            };\n            this.changelog.push(c);\n            this.emit('field.update', c);\n            if (!me.validate(field)) {\n              me.emit('field.invalid', {\n                field: field\n              });\n            }\n          }\n        });\n\n        if (!suppressEvents) {\n          var c = {\n            action: 'create',\n            field: field\n          };\n          this.changelog.push(c);\n          this.emit('field.create', c);\n        }\n\n        // Add field validators\n        if (me.fields.hasOwnProperty(field)) {\n          if (me.fields[field].hasOwnProperty('pattern')) {\n            me.addValidator(field, me.fields[field].pattern);\n          }\n          ['min', 'max', 'enum'].forEach(function (v) {\n            if (me.fields[field].hasOwnProperty(v)) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators[v](me.fields[field], val);\n              });\n            }\n          });\n          if (me.fields[field].hasOwnProperty('required')) {\n            if (me.fields[field].required) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators.required(val);\n              });\n            }\n          }\n          if (me.fields[field].hasOwnProperty('validate')) {\n            if (typeof me.fields[field] === 'function') {\n              me.addValidator(field, function (val) {\n                return me.fields[field](val);\n              });\n            } else {\n              console.warn('Invalid custom validation function. The value passed to the validate attribute must be a function.');\n            }\n          }\n        }\n      } else if (me.id === null && me.autoid) {\n        me.id = NGN.DATA.util.GUID();\n      }\n    }\n\n    /**\n     * @method addVirtual\n     * Add a virtual field dynamically.\n     * @param {string} name\n     * The name of the attribute to add.\n     * @param {function} handler\n     * The synchronous method (or generator) that produces\n     * the desired output.\n     */\n\n  }, {\n    key: 'addVirtual',\n    value: function addVirtual(name, fn) {\n      var me = this;\n      Object.defineProperty(this, name, {\n        get: function get() {\n          return fn.apply(me);\n        }\n      });\n    }\n\n    /**\n     * @method addRelationshipField\n     * Join another model dynamically.\n     * @param {string} name\n     * The name of the field to add.\n     * @param {Object|NGN.DATA.Model} config\n     * The configuration or data model type. This follows the same syntax\n     * defined in the #joins attribute.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addRelationshipField',\n    value: function addRelationshipField(name, cfg, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n\n      if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n        throw new Error(name + ' already exists. It cannot be added to the model again.');\n      }\n\n      if (typeof cfg === 'function' || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object' && !cfg.hasOwnProperty('type')) {\n        cfg = {\n          type: cfg\n        };\n      }\n\n      if (!cfg.type) {\n        throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.');\n      }\n\n      cfg.required = NGN.coalesce(cfg.required, true);\n      cfg.default = cfg.default || null;\n\n      var me = this;\n      var entityType = 'model';\n      if (cfg.type instanceof NGN.DATA.Store) {\n        entityType = 'store';\n      } else if (_typeof(cfg.type) === 'object') {\n        if (cfg.type.model) {\n          entityType = 'store';\n        }\n      }\n\n      if (entityType === 'store') {\n        var storeCfg = {};\n\n        if (cfg.type instanceof NGN.DATA.Store) {\n          this.rawjoins[name] = cfg.type;\n          return;\n        } else if (cfg.type.model) {\n          storeCfg = cfg.type;\n        } else {\n          throw new Error('Nested store configuration is invalid or was not recognized.');\n        }\n\n        this.rawjoins[name] = new NGN.DATA.Store(storeCfg);\n        this.applyStoreMonitor(name);\n      } else if (!cfg.type.data) {\n        this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type(); // eslint-disable-line new-cap\n        this.applyModelMonitor(name);\n      } else if (cfg.type.data) {\n        this.rawjoins[name] = cfg.type;\n        this.applyStoreMonitor(name);\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.');\n      }\n\n      Object.defineProperty(this, name, {\n        enumerable: true,\n        get: function get() {\n          return me.rawjoins[name];\n        }\n      });\n\n      if (!suppressEvents) {\n        var c = {\n          action: 'create',\n          field: name\n        };\n        this.changelog.push(c);\n        this.emit('relationship.create', c);\n      }\n    }\n\n    /**\n     * @method applyModelMonitor\n     * Applies event handlers for bubbling model events.\n     * @param {string} field\n     * The relationship field name.\n     * @private\n     */\n\n  }, {\n    key: 'applyModelMonitor',\n    value: function applyModelMonitor(name) {\n      var model = this.rawjoins[name];\n      var me = this;\n\n      model.on('field.update', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.old,\n          new: delta.new,\n          join: true\n        });\n      });\n\n      model.on('field.create', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: null,\n          new: null,\n          join: true\n        });\n      });\n\n      model.on('field.remove', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.value,\n          new: null,\n          join: true\n        });\n      });\n    }\n\n    /**\n     * @method applyStoreMonitor\n     * Applies event handlers for store data.\n     * @param {string} name\n     * Name of the raw join.\n     * @private\n     */\n\n  }, {\n    key: 'applyStoreMonitor',\n    value: function applyStoreMonitor(name) {\n      var _this2 = this;\n\n      if (!this.rawjoins.hasOwnProperty(name)) {\n        return;\n      }\n      if (this.rawjoins[name].hasOwnProperty('proxy')) {\n        (function () {\n          var me = _this2;\n          _this2.rawjoins[name].on('record.create', function (record) {\n            var old = me[name].data;\n            old.pop();\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n            me.emit('field.update', c);\n          });\n          _this2.rawjoins[name].on('record.update', function (record, delta) {\n            if (!delta) {\n              return;\n            }\n            var c = {\n              action: 'update',\n              field: name + '.' + delta.field,\n              join: true,\n              old: delta.old,\n              new: delta.new\n            };\n            me.emit('field.update', c);\n          });\n          _this2.rawjoins[name].on('record.delete', function (record) {\n            var old = me[name].data;\n            old.push(record.data);\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n            me.emit('field.update', c);\n          });\n        })();\n      }\n    }\n\n    /**\n     * @method removeField\n     * Remove a field from the data model.\n     * @param {string} name\n     * Name of the field to remove.\n     */\n\n  }, {\n    key: 'removeField',\n    value: function removeField(name) {\n      if (this.raw.hasOwnProperty(name)) {\n        var val = this.raw[name];\n        delete this[name];\n        delete this.fields[name]; // eslint-disable-line no-undef\n        delete this.raw[name]; // eslint-disable-line no-undef\n        if (this.invalidDataAttributes.indexOf(name) >= 0) {\n          this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1);\n        }\n        var c = {\n          action: 'delete',\n          field: name,\n          value: val\n        };\n        this.emit('field.remove', c);\n        this.changelog.push(c);\n      }\n    }\n\n    /**\n     * @method removeVirtual\n     * Remove a virtual field.\n     * @param {string} name\n     * Name of the field.\n     */\n\n  }, {\n    key: 'removeVirtual',\n    value: function removeVirtual(name) {\n      delete this[name];\n    }\n\n    /**\n     * @method removeRelationshipField\n     * Remove an existing join dynamically.\n     * @param {string} name\n     * The name of the relationship field to remove.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'removeRelationshipField',\n    value: function removeRelationshipField(name, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      if (this.joins.hasOwnProperty(name)) {\n        var val = this.rawjoins[name];\n        delete this.rawjoins[name];\n        delete this[name];\n        delete this.joins[name];\n        if (!suppressEvents) {\n          var c = {\n            action: 'delete',\n            field: name,\n            old: val,\n            join: true\n          };\n          this.changelog.push(c);\n          this.emit('relationship.remove', c);\n        }\n      }\n    }\n\n    /**\n     * @method undo\n     * A rollback function to undo changes. This operation affects\n     * the changelog. It is possible to undo an undo (i.e. redo).\n     * This works with relationship creating/removing relationship fields,\n     * but not updates to the related model. To undo changes to a relationship\n     * field, the `undo()` method _of the related model_ must be called.\n     * @param {number} [OperationCount=1]\n     * The number of operations to \"undo\". Defaults to a single operation.\n     */\n\n  }, {\n    key: 'undo',\n    value: function undo(back) {\n      back = back || 1;\n      var old = this.changelog.splice(this.changelog.length - back, back);\n      var me = this;\n\n      old.reverse().forEach(function (change) {\n        if (!(typeof change.join === 'boolean' ? change.join : false)) {\n          switch (change.action) {\n            case 'update':\n              me[change.field] = change.old;\n              break;\n            case 'create':\n              me.removeField(change.field);\n              break;\n            case 'delete':\n              me.addField(change.field);\n              me[change.field] = me.old;\n              break;\n          }\n        } else {\n          switch (change.action) {\n            case 'create':\n              me.removeRelationshipField(change.field);\n              break;\n            case 'delete':\n              me.addRelationshipField(change.field);\n              me[change.field] = change.old;\n              break;\n          }\n        }\n      });\n    }\n\n    /**\n     * @method load\n     * Load a data record. This clears the #history. #modified\n     * will be set to `false`, as though the record has been untouched.\n     * @param {object} data\n     * The data to apply to the model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load(data) {\n      data = data || {};\n\n      // Handle data maps\n      var me = this;\n      if (this._dataMap !== null) {\n        Object.keys(this.reverseMap).forEach(function (key) {\n          if (data.hasOwnProperty(key)) {\n            data[me.reverseMap[key]] = data[key];\n            delete data[key];\n          }\n        });\n      }\n\n      // Loop through the keys and add data fields\n      Object.keys(data).forEach(function (key) {\n        if (me.fields.hasOwnProperty(key)) {\n          if (me.raw.hasOwnProperty(key)) {\n            me.raw[key] = data[key];\n          } else if (key === me.idAttribute) {\n            me.id = data[key];\n          }\n        } else if (me.joins.hasOwnProperty(key)) {\n          var tmp = new me.getRelated(key).type(); // eslint-disable-line new-cap\n          tmp.load(data[key]);\n          me.rawjoin[key] = tmp;\n        } else {\n          console.warn(key + ' was specified as a data field but is not defined in the model.');\n        }\n      });\n\n      this.setUnmodified();\n    }\n  }, {\n    key: 'modified',\n    get: function get() {\n      return this.checksum !== this.benchmark;\n    }\n\n    /**\n     * @cfgproperty {String/Number/Date} [id=null]\n     * The unique ID of the model object. If #idAttribute is defined,\n     * this will get/set the #idAttribute value.\n     */\n\n  }, {\n    key: 'id',\n    get: function get() {\n      return this.oid;\n    },\n    set: function set(value) {\n      this.oid = value;\n    }\n\n    /**\n     * @property checksum\n     * The unique checksum of the record (i.e. a record fingerprint).\n     * This will change as the data changes.\n     */\n\n  }, {\n    key: 'checksum',\n    get: function get() {\n      return NGN.DATA.util.checksum(JSON.stringify(this.data));\n    }\n\n    /**\n     * @property {Object} dataMap\n     * The current data map.\n     * @private\n     */\n\n  }, {\n    key: 'dataMap',\n    get: function get() {\n      return this._dataMap;\n    },\n    set: function set(value) {\n      this._dataMap = value;\n      this._reverseDataMap = null;\n    }\n\n    /**\n     * @property {NGN.DATA.Store} store\n     * If a store is associated with the model, this will\n     * provide a reference to it. If there is no store, this\n     * will return `null`.\n     */\n\n  }, {\n    key: 'datastore',\n    get: function get() {\n      return this._store;\n    }\n\n    /**\n     * @property {boolean} valid\n     * Indicates the record is valid.\n     */\n\n  }, {\n    key: 'valid',\n    get: function get() {\n      return this.invalidDataAttributes.length === 0;\n    }\n\n    /**\n     * @property datafields\n     * Provides an array of data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'datafields',\n    get: function get() {\n      return Object.keys(this.fields);\n    }\n\n    /**\n     * @property reslationships\n     * Provides an array of join fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'relationships',\n    get: function get() {\n      return Object.keys(this.joins);\n    }\n\n    /**\n     * @property virtualdatafields\n     * Provides an array of virtual data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'virtualdatafields',\n    get: function get() {\n      return Object.keys(this.virtuals);\n    }\n\n    /**\n     * @property {object} reverseMap\n     * Reverses the data map. For example, if the original #dataMap\n     * looks like:\n     *\n     * ```js\n     * {\n     *    firstname: 'gn',\n     *    lastname: 'sn\n     * }\n     * ```\n     *\n     * The reverse map will look like:\n     *\n     * ```js\n     * {\n     *    gn: 'firstname',\n     *    sn: 'lastname\n     * }\n     * ```\n     */\n\n  }, {\n    key: 'reverseMap',\n    get: function get() {\n      var _this3 = this;\n\n      if (this.dataMap !== null) {\n        var _ret2 = function () {\n          if (_this3._reverseDataMap !== null) {\n            return {\n              v: _this3._reverseDataMap\n            };\n          }\n          var rmap = {};\n          var me = _this3;\n          Object.keys(_this3._dataMap).forEach(function (attr) {\n            rmap[me._dataMap[attr]] = attr;\n          });\n          _this3._reverseDataMap = rmap;\n          return {\n            v: rmap\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      }\n      return null;\n    }\n\n    /**\n      * @property data\n      * Creates a JSON representation of the data entity. This is\n      * a record that can be persisted to a database or other data store.\n      * @readonly.\n      */\n\n  }, {\n    key: 'data',\n    get: function get() {\n      var _this4 = this;\n\n      var d = this.serialize();\n      if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n        d[this.idAttribute] = this[this.idAttribute];\n      }\n      if (this.dataMap) {\n        (function () {\n          var me = _this4;\n          // Loop through the map keys\n          Object.keys(_this4.dataMap).forEach(function (key) {\n            // If the node contains key, make the mapping\n            if (d.hasOwnProperty(key)) {\n              if (d[key] instanceof NGN.DATA.Model) {\n                d[me.dataMap[key]] = d[key].data;\n              } else {\n                d[me.dataMap[key]] = d[key];\n              }\n              delete d[key];\n            }\n          });\n        })();\n      }\n      return d;\n    }\n\n    /**\n     * @property history\n     * The history of the entity (i.e. changelog).The history\n     * is shown from most recent to oldest change. Keep in mind that\n     * some actions, such as adding new custom fields on the fly, may\n     * be triggered before other updates.\n     * @returns {array}\n     */\n\n  }, {\n    key: 'history',\n    get: function get() {\n      return this.changelog.reverse();\n    }\n  }]);\n\n  return Model;\n}(NGN.EventEmitter);\n\nNGN.DATA = NGN.DATA || {};\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    var ModelLoader = function ModelLoader(data) {\n      var model = new Model(cfg);\n      if (data) {\n        model.load(data);\n      }\n      return model;\n    };\n\n    return ModelLoader;\n  }),\n\n  Entity: NGN.private(Model)\n});\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA;\n}"],"sourceRoot":"/source/"}