{"version":3,"sources":["model.js","model.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Model","_NGN$EventEmitter","config","this","_this","getPrototypeOf","me","idAttribute","NGN","privateconst","fields","id","required","type","String","default","joins","relationships","virtuals","validators","validation","coalesce","isNew","isDestroyed","oid","autoid","benchmark","setUnmodified","checksum","changelog","allowInvalidSave","disableDataValidation","invalidDataAttributes","initialDataAttributes","_nativeValidators","min","minimum","trim","parse","max","maximum","enum","valid","indexOf","field","hasOwnProperty","_dataMap","dataMap","_reverseDataMap","raw","rawjoins","_store","allfields","datafields","concat","virtualdatafields","filter","a","Error","join","keys","forEach","name","addField","v","get","apply","addRelationshipField","events","BUS","eventName","on","args","slice","arguments","push","unshift","emit","property","validator","console","warn","css","Array","isArray","test","attribute","attr","validateDataType","validate","fieldType","expectedType","fieldname","_obj","rtn","nonEnumerableProperties","substr","undefined","enumerableProperties","dsc","getOwnPropertyDescriptor","set","refs","toJSON","r","data","fieldcfg","suppressEvents","cfg","toLowerCase","source","stack","pop","path","e","charAt","toUpperCase","eval","DATA","util","GUID","old","c","action","new","addValidator","pattern","val","_source","fn","entityType","Store","model","storeCfg","applyStoreMonitor","applyModelMonitor","delta","_this2","record","splice","back","reverse","change","removeRelationshipField","removeField","reverseMap","load","JSON","stringify","_this3","_ret2","rmap","_this4","d","serialize","EventEmitter","ModelLoader","Entity","nodelike","module","exports"],"mappings":"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","file":"model.min.js","sourcesContent":["'use strict'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nclass Model extends NGN.EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields ||\n        {\n          id: {\n            required: true,\n            type: String,\n            'default': config.id || null\n          }\n        }\n      ),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum\n        this.changelog = []\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function (minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum\n          }\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum\n          }\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum\n          }\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse()\n          }\n          return false\n        },\n        max: function (maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum\n          }\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum\n          }\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum\n          }\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse()\n          }\n          return false\n        },\n        enum: function (valid, value) {\n          return valid.indexOf(value) >= 0\n        },\n        required: function (field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    })\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    let allfields = this.datafields.concat(this.virtualdatafields).concat(this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i\n    })\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.')\n    }\n\n    // Make sure an ID reference is available.\n    if (!this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      }\n    }\n\n    // Add fields\n    Object.keys(this.fields).forEach(function (field) {\n      if (typeof me.fields[field] !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        }\n      }\n      me.addField(field, true)\n    })\n\n    // Add virtuals\n    Object.keys(this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me)\n      }))\n    })\n\n    // Add relationships\n    Object.keys(this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true)\n    })\n\n    let events = [\n      'field.update',\n      'field.create',\n      'field.remove',\n      'field.invalid',\n      'validator.add',\n      'validator.remove',\n      'relationship.create',\n      'relationship.remove'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.push(me)\n          args.unshift(eventName)\n          NGN.BUS.emit.apply(NGN.BUS, args)\n        })\n      })\n    }\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n  get modified () {\n    return this.checksum !== this.benchmark\n  }\n\n  /**\n   * @cfgproperty {String/Number/Date} [id=null]\n   * The unique ID of the model object. If #idAttribute is defined,\n   * this will get/set the #idAttribute value.\n   */\n  get id () {\n    return this.oid\n  }\n\n  set id (value) {\n    this.oid = value\n  }\n\n  /**\n   * @property checksum\n   * The unique checksum of the record (i.e. a record fingerprint).\n   * This will change as the data changes.\n   */\n  get checksum () {\n    return NGN.DATA.util.checksum(JSON.stringify(this.data))\n  }\n\n  /**\n   * @property {Object} dataMap\n   * The current data map.\n   * @private\n   */\n  get dataMap () {\n    return this._dataMap\n  }\n\n  set dataMap (value) {\n    this._dataMap = value\n    this._reverseDataMap = null\n  }\n\n  /**\n   * @property {NGN.DATA.Store} store\n   * If a store is associated with the model, this will\n   * provide a reference to it. If there is no store, this\n   * will return `null`.\n   */\n  get datastore () {\n    return this._store\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the record is valid.\n   */\n  get valid () {\n    this.validate()\n    return this.invalidDataAttributes.length === 0\n  }\n\n  /**\n   * @property datafields\n   * Provides an array of data fields associated with the model.\n   * @returns {String[]}\n   */\n  get datafields () {\n    return Object.keys(this.fields)\n  }\n\n  /**\n   * @property reslationships\n   * Provides an array of join fields associated with the model.\n   * @returns {String[]}\n   */\n  get relationships () {\n    return Object.keys(this.joins)\n  }\n\n  /**\n   * @property virtualdatafields\n   * Provides an array of virtual data fields associated with the model.\n   * @returns {String[]}\n   */\n  get virtualdatafields () {\n    return Object.keys(this.virtuals)\n  }\n\n  /**\n   * @property {object} reverseMap\n   * Reverses the data map. For example, if the original #dataMap\n   * looks like:\n   *\n   * ```js\n   * {\n   *    firstname: 'gn',\n   *    lastname: 'sn\n   * }\n   * ```\n   *\n   * The reverse map will look like:\n   *\n   * ```js\n   * {\n   *    gn: 'firstname',\n   *    sn: 'lastname\n   * }\n   * ```\n   */\n  get reverseMap () {\n    if (this.dataMap !== null) {\n      if (this._reverseDataMap !== null) {\n        return this._reverseDataMap\n      }\n      let rmap = {}\n      const me = this\n      Object.keys(this._dataMap).forEach(function (attr) {\n        rmap[me._dataMap[attr]] = attr\n      })\n      this._reverseDataMap = rmap\n      return rmap\n    }\n    return null\n  }\n\n  /**\n    * @property data\n    * Creates a JSON representation of the data entity. This is\n    * a record that can be persisted to a database or other data store.\n    * @readonly.\n    */\n  get data () {\n    let d = this.serialize()\n    if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n      d[this.idAttribute] = this[this.idAttribute]\n    }\n    if (this.dataMap) {\n      const me = this\n      // Loop through the map keys\n      Object.keys(this.dataMap).forEach(function (key) {\n        // If the node contains key, make the mapping\n        if (d.hasOwnProperty(key)) {\n          if (d[key] instanceof NGN.DATA.Model) {\n            d[me.dataMap[key]] = d[key].data\n          } else {\n            d[me.dataMap[key]] = d[key]\n          }\n          delete d[key]\n        }\n      })\n    }\n    return d\n  }\n\n  /**\n   * @property history\n   * The history of the entity (i.e. changelog).The history\n   * is shown from most recent to oldest change. Keep in mind that\n   * some actions, such as adding new custom fields on the fly, may\n   * be triggered before other updates.\n   * @returns {array}\n   */\n  get history () {\n    return this.changelog.reverse()\n  }\n\n  /**\n    * @method addValidator\n    * Add or update a validation rule for a specific model property.\n    * @param {String} field\n    * The data field to test.\n    * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n    * The validation used to test the property value. This should return\n    * `true` when the data is valid and `false` when it is not.\n    *\n    * * When this is a _function_, the value is passed to it as an argument.\n    * * When this is a _String_, the value is compared for an exact match (case sensitive)\n    * * When this is a _Number_, the value is compared for equality.\n    * * When this is a _Date_, the value is compared for exact equality.\n    * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n    * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n    * * When this is _an array of dates_, the value is compared to each date for equality.\n    * @fires validator.add\n    */\n  addValidator (property, validator) {\n    if (!this.hasOwnProperty(property)) {\n      console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '')\n      return\n    }\n\n    switch (typeof validator) {\n      case 'function':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(validator)\n        this.emit('validator.add', property)\n        break\n      case 'object':\n        if (Array.isArray(validator)) {\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.indexOf(value) >= 0\n          })\n          this.emit('validator.add', property)\n        } else if (validator.test) { // RegExp\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.test(value)\n          })\n          this.emit('validator.add', property)\n        } else {\n          console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n        }\n        break\n      case 'string':\n      case 'number':\n      case 'date':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(function (value) {\n          return value === validator\n        })\n        this.emit('validator.add', property)\n        break\n      default:\n        console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n    }\n  }\n\n  /**\n    * @method removeValidator\n    * Remove a data validator from the object.\n    * @param {String} attribute\n    * The name of the attribute to remove from the validators.\n    * @fires validator.remove\n    */\n  removeValidator (attribute) {\n    if (this.validators.hasOwnProperty(attribute)) {\n      delete this.validators[attribute]\n      this.emit('validator.remove', attribute)\n    }\n  }\n\n  /**\n    * @method validate\n    * Validate one or all attributes of the data.\n    * @param {String} [attribute=null]\n    * Validate a specific attribute. By default, all attributes are tested.\n    * @private\n    * @returns {Boolean}\n    * Returns true or false based on the validity of data.\n    */\n  validate (attribute) {\n    const me = this\n\n    // Single Attribute Validation\n    if (attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        for (let i = 0; i < this.validators[attribute].length; i++) {\n          if (!me.validators[attribute][i](me[attribute])) {\n            me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute)\n            return false\n          } else {\n            me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n              return attribute !== attr\n            })\n          }\n        }\n\n        if (!this.validateDataType(attribute)) {\n          this.invalidDataAttributes.push(attribute)\n          return false\n        }\n      }\n\n      return true\n    }\n\n    // Validate data type of each attribute\n    this.datafields.forEach(function (field) {\n      me.validate(field)\n    })\n  }\n\n  /**\n   * @method validateDataType\n   * Indicates the data types match.\n   * @param {string} fieldname\n   * Name of the field whose data should be validated.\n   * @private\n   * @return {boolean}\n   */\n  validateDataType (field) {\n    const fieldType = NGN.typeof(this[field])\n    const expectedType = NGN.typeof(this.fields[field].type)\n\n    if (fieldType !== 'null') {\n      return fieldType === expectedType\n    }\n\n    if (this[field] === null && this.fields[field].required) {\n      if (this.autoid && field === this.idAttribute) {\n        return true\n      }\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * @method getRelationshipField\n   * Provides specific detail/configuration about a join/relationship.\n   * @param {String} fieldname\n   * The name of the field.\n   * @returns {Object}\n   */\n  getRelationshipField (fieldname) {\n    return this.joins[fieldname]\n  }\n\n  /**\n   * @method hasRelationship\n   * Indicates a data join exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasRelationship (fieldname) {\n    return this.joins.hasOwnProperty(fieldname)\n  }\n\n  /**\n     * @method getDataField\n     * Provides specific detail/configuration about a field.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Object}\n     */\n  getDataField (fieldname) {\n    return this.fields[fieldname]\n  }\n\n  /**\n   * @method hasDataField\n   * Indicates a data field exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasDataField (fieldname) {\n    return this.fields.hasOwnProperty(fieldname)\n  }\n\n  /**\n    * @method serialize\n    * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n    * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n    *\n    * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n    * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n    *\n    * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n    * The model itself can be returned using #getXRef.\n    * @param {Object} [obj]\n    * Defaults to this object.\n    * @protected\n    */\n  serialize (obj) {\n    let _obj = obj || this.raw\n    let rtn = {}\n\n    for (let key in _obj) {\n      _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || ''\n      if (this.fields.hasOwnProperty(key)) {\n        key = key === 'id' ? this.idAttribute : key\n        if ((_obj.hasOwnProperty(key) && (_obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)))) || (_obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0)) {\n          let dsc = Object.getOwnPropertyDescriptor(_obj, key)\n          if (!dsc.set) {\n            // Handle everything else\n            switch (typeof dsc.value) {\n              case 'function':\n                // Support date & regex proxies\n                if (dsc.value.name === 'Date') {\n                  rtn[key] = _obj[key].refs.toJSON()\n                } else if (dsc.value.name === 'RegExp') {\n                  rtn[key] = dsc.value()\n                }\n                break\n              case 'object':\n                // Support array proxies\n                if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                  _obj[key] = _obj[key].slice(0)\n                }\n\n                rtn[key] = _obj[key]\n                break\n              default:\n                rtn[key] = _obj[key]\n                break\n            }\n          }\n        }\n      }\n    }\n\n    const me = this\n    this.relationships.forEach(function (r) {\n      rtn[r] = me.rawjoins[r].data\n    })\n\n    return rtn\n  }\n\n  /**\n   * @method addField\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {object} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (field, fieldcfg, suppressEvents) {\n    if (typeof fieldcfg === 'boolean') {\n      suppressEvents = fieldcfg\n      fieldcfg = null\n    }\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    const me = this\n    let cfg = null\n    if (field.toLowerCase() !== 'id') {\n      if (typeof field === 'object') {\n        if (!field.name) {\n          throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.')\n        }\n        cfg = field\n        field = cfg.name\n        delete cfg.name\n      }\n\n      if (me[field] !== undefined) {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '')\n        }\n        delete me[field]\n      }\n\n      // Create the data field as an object attribute & getter/setter\n      me.fields[field] = cfg || me.fields[field] || {}\n      me.fields[field].required = NGN.coalesce(me.fields[field].required, false)\n\n      if (!me.fields[field].hasOwnProperty('type')) {\n        if (me.fields[field].hasOwnProperty('default')) {\n          let type = NGN.typeof(me.fields[field].default)\n          type = type.charAt(0).toUpperCase() + type.slice(1)\n          me.fields[field].type = eval(type)\n        }\n      }\n      me.fields[field].type = NGN.coalesce(me.fields[field].type, String)\n      if (field === me.idAttribute && me.autoid === true) {\n        me.fields[field].type = String\n        me.fields[field]['default'] = NGN.DATA.util.GUID()\n      } else {\n        me.fields[field]['default'] = me.fields[field]['default'] || null\n      }\n      me.raw[field] = me.fields[field]['default']\n      me[field] = me.raw[field]\n\n      Object.defineProperty(me, field, {\n        get: function () {\n          return me.raw[field]\n        },\n        set: function (value) {\n          let old = me.raw[field]\n          me.raw[field] = value\n          let c = {\n            action: 'update',\n            field: field,\n            old: old,\n            new: me.raw[field]\n          }\n          this.changelog.push(c)\n          this.emit('field.update', c)\n          if (!me.validate(field)) {\n            me.emit('field.invalid', {\n              field: field\n            })\n          }\n        }\n      })\n\n      if (!suppressEvents) {\n        let c = {\n          action: 'create',\n          field: field\n        }\n        this.changelog.push(c)\n        this.emit('field.create', c)\n      }\n\n      // Add field validators\n      if (me.fields.hasOwnProperty(field)) {\n        if (me.fields[field].hasOwnProperty('pattern')) {\n          me.addValidator(field, me.fields[field].pattern)\n        }\n        ['min', 'max', 'enum'].forEach(function (v) {\n          if (me.fields[field].hasOwnProperty(v)) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators[v](me.fields[field][v], val)\n            })\n          }\n        })\n        if (me.fields[field].hasOwnProperty('required')) {\n          if (me.fields[field].required) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators.required(field, val)\n            })\n          }\n        }\n        if (me.fields[field].hasOwnProperty('validate')) {\n          if (typeof me.fields[field] === 'function') {\n            me.addValidator(field, function (val) {\n              return me.fields[field](val)\n            })\n          } else {\n            const source = NGN.stack.pop()\n            console.warn('Invalid custom validation function (in %c' + source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '')\n          }\n        }\n      }\n    } else if (me.id === null && me.autoid) {\n      me.id = NGN.DATA.util.GUID()\n    }\n  }\n\n  /**\n   * @method addVirtual\n   * Add a virtual field dynamically.\n   * @param {string} name\n   * The name of the attribute to add.\n   * @param {function} handler\n   * The synchronous method (or generator) that produces\n   * the desired output.\n   */\n  addVirtual (name, fn) {\n    const me = this\n    Object.defineProperty(this, name, {\n      get: function () {\n        return fn.apply(me)\n      }\n    })\n  }\n\n  /**\n   * @method addRelationshipField\n   * Join another model dynamically.\n   * @param {string} name\n   * The name of the field to add.\n   * @param {Object|NGN.DATA.Model} config\n   * The configuration or data model type. This follows the same syntax\n   * defined in the #joins attribute.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addRelationshipField (name, cfg, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n\n    if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n      throw new Error(name + ' already exists. It cannot be added to the model again.')\n    }\n\n    if (typeof cfg === 'function' || typeof cfg === 'object' && !cfg.hasOwnProperty('type')) {\n      cfg = {\n        type: cfg\n      }\n    }\n\n    if (!cfg.type) {\n      throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.')\n    }\n\n    cfg.required = NGN.coalesce(cfg.required, true)\n    cfg.default = cfg.default || null\n\n    const me = this\n    let entityType = 'model'\n    if (cfg.type instanceof NGN.DATA.Store) {\n      entityType = 'store'\n    } else if (NGN.typeof(cfg.type) === 'array') {\n      if (cfg.type.length === 0) {\n        throw new Error(name + ' cannot be an empty store. A model must be provided.')\n      }\n      entityType = 'collection'\n    } else if (typeof cfg.type === 'object') {\n      if (cfg.type.model) {\n        entityType = 'store'\n      }\n    }\n\n    if (entityType === 'store') {\n      let storeCfg = {}\n      if (cfg.type instanceof NGN.DATA.Store) {\n        this.rawjoins[name] = cfg.type\n        storeCfg = null\n      } else if (cfg.type.model) {\n        storeCfg = cfg.type\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.')\n      }\n\n      if (storeCfg !== null) {\n        this.rawjoins[name] = new NGN.DATA.Store(storeCfg)\n      }\n      this.applyStoreMonitor(name)\n    } else if (entityType === 'collection') {\n      this.rawjoins[name] = new NGN.DATA.Store({\n        model: cfg.type[0]\n      })\n      this.applyStoreMonitor(name)\n    } else if (!cfg.type.data) {\n      this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type()  // eslint-disable-line new-cap\n      this.applyModelMonitor(name)\n    } else if (cfg.type.data) {\n      this.rawjoins[name] = cfg.type\n      this.applyStoreMonitor(name)\n    } else {\n      throw new Error('Nested store configuration is invalid or was not recognized.')\n    }\n\n    Object.defineProperty(this, name, {\n      enumerable: true,\n      get: function () {\n        return me.rawjoins[name]\n      }\n    })\n\n    if (!suppressEvents) {\n      let c = {\n        action: 'create',\n        field: name\n      }\n      this.changelog.push(c)\n      this.emit('relationship.create', c)\n    }\n  }\n\n  /**\n   * @method applyModelMonitor\n   * Applies event handlers for bubbling model events.\n   * @param {string} field\n   * The relationship field name.\n   * @private\n   */\n  applyModelMonitor (name) {\n    const model = this.rawjoins[name]\n    const me = this\n\n    model.on('field.update', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.old,\n        new: delta.new,\n        join: true\n      })\n    })\n\n    model.on('field.create', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: null,\n        new: null,\n        join: true\n      })\n    })\n\n    model.on('field.remove', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.value,\n        new: null,\n        join: true\n      })\n    })\n  }\n\n  /**\n   * @method applyStoreMonitor\n   * Applies event handlers for store data.\n   * @param {string} name\n   * Name of the raw join.\n   * @private\n   */\n  applyStoreMonitor (name) {\n    if (!this.rawjoins.hasOwnProperty(name)) {\n      return\n    }\n    if (this.rawjoins[name].hasOwnProperty('proxy')) {\n      const me = this\n\n      this.rawjoins[name].on('record.create', function (record) {\n        let old = me[name].data\n        old.pop()\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n        me.emit('field.update', c)\n      })\n      this.rawjoins[name].on('record.update', function (record, delta) {\n        if (!delta) {\n          return\n        }\n        let c = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          join: true,\n          old: delta.old,\n          new: delta.new\n        }\n        me.emit('field.update', c)\n      })\n      this.rawjoins[name].on('record.delete', function (record) {\n        let old = me[name].data\n        old.push(record.data)\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n        me.emit('field.update', c)\n      })\n    }\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   */\n  removeField (name) {\n    if (this.raw.hasOwnProperty(name)) {\n      let val = this.raw[name]\n      delete this[name]\n      delete this.fields[name] // eslint-disable-line no-undef\n      delete this.raw[name] // eslint-disable-line no-undef\n      if (this.invalidDataAttributes.indexOf(name) >= 0) {\n        this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1)\n      }\n      let c = {\n        action: 'delete',\n        field: name,\n        value: val\n      }\n      this.emit('field.remove', c)\n      this.changelog.push(c)\n    }\n  }\n\n  /**\n   * @method removeVirtual\n   * Remove a virtual field.\n   * @param {string} name\n   * Name of the field.\n   */\n  removeVirtual (name) {\n    delete this[name]\n  }\n\n  /**\n   * @method removeRelationshipField\n   * Remove an existing join dynamically.\n   * @param {string} name\n   * The name of the relationship field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  removeRelationshipField (name, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    if (this.joins.hasOwnProperty(name)) {\n      let val = this.rawjoins[name]\n      delete this.rawjoins[name]\n      delete this[name]\n      delete this.joins[name]\n      if (!suppressEvents) {\n        let c = {\n          action: 'delete',\n          field: name,\n          old: val,\n          join: true\n        }\n        this.changelog.push(c)\n        this.emit('relationship.remove', c)\n      }\n    }\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog. It is possible to undo an undo (i.e. redo).\n   * This works with relationship creating/removing relationship fields,\n   * but not updates to the related model. To undo changes to a relationship\n   * field, the `undo()` method _of the related model_ must be called.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   */\n  undo (back) {\n    back = back || 1\n    let old = this.changelog.splice(this.changelog.length - back, back)\n    const me = this\n\n    old.reverse().forEach(function (change) {\n      if (!(typeof change.join === 'boolean' ? change.join : false)) {\n        switch (change.action) {\n          case 'update':\n            me[change.field] = change.old\n            break\n          case 'create':\n            me.removeField(change.field)\n            break\n          case 'delete':\n            me.addField(change.field)\n            me[change.field] = me.old\n            break\n        }\n      } else {\n        switch (change.action) {\n          case 'create':\n            me.removeRelationshipField(change.field)\n            break\n          case 'delete':\n            me.addRelationshipField(change.field)\n            me[change.field] = change.old\n            break\n        }\n      }\n    })\n  }\n\n  /**\n   * @method load\n   * Load a data record. This clears the #history. #modified\n   * will be set to `false`, as though the record has been untouched.\n   * @param {object} data\n   * The data to apply to the model.\n   */\n  load (data) {\n    data = data || {}\n\n    // Handle data maps\n    const me = this\n    if (this._dataMap !== null) {\n      Object.keys(this.reverseMap).forEach(function (key) {\n        if (data.hasOwnProperty(key)) {\n          data[me.reverseMap[key]] = data[key]\n          delete data[key]\n        }\n      })\n    }\n\n    // Loop through the keys and add data fields\n    Object.keys(data).forEach(function (key) {\n      if (me.fields.hasOwnProperty(key)) {\n        if (me.raw.hasOwnProperty(key)) {\n          me.raw[key] = data[key]\n        } else if (key === me.idAttribute) {\n          me.id = data[key]\n        }\n      } else if (me.joins.hasOwnProperty(key)) {\n        // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n        // tmp.load(data[key])\n        // me.rawjoin[key] = tmp\n        me.rawjoins[key].load(data[key])\n      } else {\n        const source = NGN.stack.pop()\n        console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '')\n      }\n    })\n\n    this.setUnmodified()\n  }\n}\n\nNGN.DATA = NGN.DATA || {}\n\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    const ModelLoader = function (data) {\n      let model = new Model(cfg)\n      if (data) {\n        model.load(data)\n      }\n      return model\n    }\n\n    return ModelLoader\n  }),\n\n  Entity: NGN.private(Model)\n})\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA\n}\n","'use strict';\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Model = function (_NGN$EventEmitter) {\n  _inherits(Model, _NGN$EventEmitter);\n\n  function Model(config) {\n    _classCallCheck(this, Model);\n\n    config = config || {};\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Model).call(this));\n\n    var me = _this;\n\n    Object.defineProperties(_this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields || {\n        id: {\n          required: true,\n          type: String,\n          'default': config.id || null\n        }\n      }),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[_this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum;\n        this.changelog = [];\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function min(minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum;\n          }\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum;\n          }\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum;\n          }\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse();\n          }\n          return false;\n        },\n        max: function max(maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum;\n          }\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum;\n          }\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum;\n          }\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse();\n          }\n          return false;\n        },\n        enum: function _enum(valid, value) {\n          return valid.indexOf(value) >= 0;\n        },\n        required: function required(field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null;\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    });\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    var allfields = _this.datafields.concat(_this.virtualdatafields).concat(_this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i;\n    });\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.');\n    }\n\n    // Make sure an ID reference is available.\n    if (!_this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      };\n    }\n\n    // Add fields\n    Object.keys(_this.fields).forEach(function (field) {\n      if (_typeof(me.fields[field]) !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        };\n      }\n      me.addField(field, true);\n    });\n\n    // Add virtuals\n    Object.keys(_this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me);\n      }));\n    });\n\n    // Add relationships\n    Object.keys(_this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true);\n    });\n\n    var events = ['field.update', 'field.create', 'field.remove', 'field.invalid', 'validator.add', 'validator.remove', 'relationship.create', 'relationship.remove'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.push(me);\n          args.unshift(eventName);\n          NGN.BUS.emit.apply(NGN.BUS, args);\n        });\n      });\n    }\n    return _this;\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n\n\n  _createClass(Model, [{\n    key: 'addValidator',\n\n\n    /**\n      * @method addValidator\n      * Add or update a validation rule for a specific model property.\n      * @param {String} field\n      * The data field to test.\n      * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n      * The validation used to test the property value. This should return\n      * `true` when the data is valid and `false` when it is not.\n      *\n      * * When this is a _function_, the value is passed to it as an argument.\n      * * When this is a _String_, the value is compared for an exact match (case sensitive)\n      * * When this is a _Number_, the value is compared for equality.\n      * * When this is a _Date_, the value is compared for exact equality.\n      * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n      * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n      * * When this is _an array of dates_, the value is compared to each date for equality.\n      * @fires validator.add\n      */\n    value: function addValidator(property, validator) {\n      if (!this.hasOwnProperty(property)) {\n        console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '');\n        return;\n      }\n\n      switch (typeof validator === 'undefined' ? 'undefined' : _typeof(validator)) {\n        case 'function':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(validator);\n          this.emit('validator.add', property);\n          break;\n        case 'object':\n          if (Array.isArray(validator)) {\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.indexOf(value) >= 0;\n            });\n            this.emit('validator.add', property);\n          } else if (validator.test) {\n            // RegExp\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.test(value);\n            });\n            this.emit('validator.add', property);\n          } else {\n            console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n          }\n          break;\n        case 'string':\n        case 'number':\n        case 'date':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(function (value) {\n            return value === validator;\n          });\n          this.emit('validator.add', property);\n          break;\n        default:\n          console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n      }\n    }\n\n    /**\n      * @method removeValidator\n      * Remove a data validator from the object.\n      * @param {String} attribute\n      * The name of the attribute to remove from the validators.\n      * @fires validator.remove\n      */\n\n  }, {\n    key: 'removeValidator',\n    value: function removeValidator(attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        delete this.validators[attribute];\n        this.emit('validator.remove', attribute);\n      }\n    }\n\n    /**\n      * @method validate\n      * Validate one or all attributes of the data.\n      * @param {String} [attribute=null]\n      * Validate a specific attribute. By default, all attributes are tested.\n      * @private\n      * @returns {Boolean}\n      * Returns true or false based on the validity of data.\n      */\n\n  }, {\n    key: 'validate',\n    value: function validate(attribute) {\n      var me = this;\n\n      // Single Attribute Validation\n      if (attribute) {\n        if (this.validators.hasOwnProperty(attribute)) {\n          for (var i = 0; i < this.validators[attribute].length; i++) {\n            if (!me.validators[attribute][i](me[attribute])) {\n              me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute);\n              return false;\n            } else {\n              me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n                return attribute !== attr;\n              });\n            }\n          }\n\n          if (!this.validateDataType(attribute)) {\n            this.invalidDataAttributes.push(attribute);\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      // Validate data type of each attribute\n      this.datafields.forEach(function (field) {\n        me.validate(field);\n      });\n    }\n\n    /**\n     * @method validateDataType\n     * Indicates the data types match.\n     * @param {string} fieldname\n     * Name of the field whose data should be validated.\n     * @private\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'validateDataType',\n    value: function validateDataType(field) {\n      var fieldType = NGN.typeof(this[field]);\n      var expectedType = NGN.typeof(this.fields[field].type);\n\n      if (fieldType !== 'null') {\n        return fieldType === expectedType;\n      }\n\n      if (this[field] === null && this.fields[field].required) {\n        if (this.autoid && field === this.idAttribute) {\n          return true;\n        }\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * @method getRelationshipField\n     * Provides specific detail/configuration about a join/relationship.\n     * @param {String} fieldname\n     * The name of the field.\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'getRelationshipField',\n    value: function getRelationshipField(fieldname) {\n      return this.joins[fieldname];\n    }\n\n    /**\n     * @method hasRelationship\n     * Indicates a data join exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasRelationship',\n    value: function hasRelationship(fieldname) {\n      return this.joins.hasOwnProperty(fieldname);\n    }\n\n    /**\n       * @method getDataField\n       * Provides specific detail/configuration about a field.\n       * @param {String} fieldname\n       * The name of the data field.\n       * @returns {Object}\n       */\n\n  }, {\n    key: 'getDataField',\n    value: function getDataField(fieldname) {\n      return this.fields[fieldname];\n    }\n\n    /**\n     * @method hasDataField\n     * Indicates a data field exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasDataField',\n    value: function hasDataField(fieldname) {\n      return this.fields.hasOwnProperty(fieldname);\n    }\n\n    /**\n      * @method serialize\n      * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n      * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n      *\n      * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n      * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n      *\n      * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n      * The model itself can be returned using #getXRef.\n      * @param {Object} [obj]\n      * Defaults to this object.\n      * @protected\n      */\n\n  }, {\n    key: 'serialize',\n    value: function serialize(obj) {\n      var _obj = obj || this.raw;\n      var rtn = {};\n\n      for (var key in _obj) {\n        _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || '';\n        if (this.fields.hasOwnProperty(key)) {\n          key = key === 'id' ? this.idAttribute : key;\n          if (_obj.hasOwnProperty(key) && _obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)) || _obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0) {\n            var dsc = Object.getOwnPropertyDescriptor(_obj, key);\n            if (!dsc.set) {\n              // Handle everything else\n              switch (_typeof(dsc.value)) {\n                case 'function':\n                  // Support date & regex proxies\n                  if (dsc.value.name === 'Date') {\n                    rtn[key] = _obj[key].refs.toJSON();\n                  } else if (dsc.value.name === 'RegExp') {\n                    rtn[key] = dsc.value();\n                  }\n                  break;\n                case 'object':\n                  // Support array proxies\n                  if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                    _obj[key] = _obj[key].slice(0);\n                  }\n\n                  rtn[key] = _obj[key];\n                  break;\n                default:\n                  rtn[key] = _obj[key];\n                  break;\n              }\n            }\n          }\n        }\n      }\n\n      var me = this;\n      this.relationships.forEach(function (r) {\n        rtn[r] = me.rawjoins[r].data;\n      });\n\n      return rtn;\n    }\n\n    /**\n     * @method addField\n     * Add a data field after the initial model definition.\n     * @param {string} fieldname\n     * The name of the field.\n     * @param {object} [fieldConfiguration=null]\n     * The field configuration (see cfg#fields for syntax).\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addField',\n    value: function addField(field, fieldcfg, suppressEvents) {\n      if (typeof fieldcfg === 'boolean') {\n        suppressEvents = fieldcfg;\n        fieldcfg = null;\n      }\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      var me = this;\n      var cfg = null;\n      if (field.toLowerCase() !== 'id') {\n        if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object') {\n          if (!field.name) {\n            throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.');\n          }\n          cfg = field;\n          field = cfg.name;\n          delete cfg.name;\n        }\n\n        if (me[field] !== undefined) {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '');\n          }\n          delete me[field];\n        }\n\n        // Create the data field as an object attribute & getter/setter\n        me.fields[field] = cfg || me.fields[field] || {};\n        me.fields[field].required = NGN.coalesce(me.fields[field].required, false);\n\n        if (!me.fields[field].hasOwnProperty('type')) {\n          if (me.fields[field].hasOwnProperty('default')) {\n            var type = NGN.typeof(me.fields[field].default);\n            type = type.charAt(0).toUpperCase() + type.slice(1);\n            me.fields[field].type = eval(type);\n          }\n        }\n        me.fields[field].type = NGN.coalesce(me.fields[field].type, String);\n        if (field === me.idAttribute && me.autoid === true) {\n          me.fields[field].type = String;\n          me.fields[field]['default'] = NGN.DATA.util.GUID();\n        } else {\n          me.fields[field]['default'] = me.fields[field]['default'] || null;\n        }\n        me.raw[field] = me.fields[field]['default'];\n        me[field] = me.raw[field];\n\n        Object.defineProperty(me, field, {\n          get: function get() {\n            return me.raw[field];\n          },\n          set: function set(value) {\n            var old = me.raw[field];\n            me.raw[field] = value;\n            var c = {\n              action: 'update',\n              field: field,\n              old: old,\n              new: me.raw[field]\n            };\n            this.changelog.push(c);\n            this.emit('field.update', c);\n            if (!me.validate(field)) {\n              me.emit('field.invalid', {\n                field: field\n              });\n            }\n          }\n        });\n\n        if (!suppressEvents) {\n          var c = {\n            action: 'create',\n            field: field\n          };\n          this.changelog.push(c);\n          this.emit('field.create', c);\n        }\n\n        // Add field validators\n        if (me.fields.hasOwnProperty(field)) {\n          if (me.fields[field].hasOwnProperty('pattern')) {\n            me.addValidator(field, me.fields[field].pattern);\n          }\n          ['min', 'max', 'enum'].forEach(function (v) {\n            if (me.fields[field].hasOwnProperty(v)) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators[v](me.fields[field][v], val);\n              });\n            }\n          });\n          if (me.fields[field].hasOwnProperty('required')) {\n            if (me.fields[field].required) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators.required(field, val);\n              });\n            }\n          }\n          if (me.fields[field].hasOwnProperty('validate')) {\n            if (typeof me.fields[field] === 'function') {\n              me.addValidator(field, function (val) {\n                return me.fields[field](val);\n              });\n            } else {\n              var _source = NGN.stack.pop();\n              console.warn('Invalid custom validation function (in %c' + _source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '');\n            }\n          }\n        }\n      } else if (me.id === null && me.autoid) {\n        me.id = NGN.DATA.util.GUID();\n      }\n    }\n\n    /**\n     * @method addVirtual\n     * Add a virtual field dynamically.\n     * @param {string} name\n     * The name of the attribute to add.\n     * @param {function} handler\n     * The synchronous method (or generator) that produces\n     * the desired output.\n     */\n\n  }, {\n    key: 'addVirtual',\n    value: function addVirtual(name, fn) {\n      var me = this;\n      Object.defineProperty(this, name, {\n        get: function get() {\n          return fn.apply(me);\n        }\n      });\n    }\n\n    /**\n     * @method addRelationshipField\n     * Join another model dynamically.\n     * @param {string} name\n     * The name of the field to add.\n     * @param {Object|NGN.DATA.Model} config\n     * The configuration or data model type. This follows the same syntax\n     * defined in the #joins attribute.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addRelationshipField',\n    value: function addRelationshipField(name, cfg, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n\n      if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n        throw new Error(name + ' already exists. It cannot be added to the model again.');\n      }\n\n      if (typeof cfg === 'function' || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object' && !cfg.hasOwnProperty('type')) {\n        cfg = {\n          type: cfg\n        };\n      }\n\n      if (!cfg.type) {\n        throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.');\n      }\n\n      cfg.required = NGN.coalesce(cfg.required, true);\n      cfg.default = cfg.default || null;\n\n      var me = this;\n      var entityType = 'model';\n      if (cfg.type instanceof NGN.DATA.Store) {\n        entityType = 'store';\n      } else if (NGN.typeof(cfg.type) === 'array') {\n        if (cfg.type.length === 0) {\n          throw new Error(name + ' cannot be an empty store. A model must be provided.');\n        }\n        entityType = 'collection';\n      } else if (_typeof(cfg.type) === 'object') {\n        if (cfg.type.model) {\n          entityType = 'store';\n        }\n      }\n\n      if (entityType === 'store') {\n        var storeCfg = {};\n        if (cfg.type instanceof NGN.DATA.Store) {\n          this.rawjoins[name] = cfg.type;\n          storeCfg = null;\n        } else if (cfg.type.model) {\n          storeCfg = cfg.type;\n        } else {\n          throw new Error('Nested store configuration is invalid or was not recognized.');\n        }\n\n        if (storeCfg !== null) {\n          this.rawjoins[name] = new NGN.DATA.Store(storeCfg);\n        }\n        this.applyStoreMonitor(name);\n      } else if (entityType === 'collection') {\n        this.rawjoins[name] = new NGN.DATA.Store({\n          model: cfg.type[0]\n        });\n        this.applyStoreMonitor(name);\n      } else if (!cfg.type.data) {\n        this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type(); // eslint-disable-line new-cap\n        this.applyModelMonitor(name);\n      } else if (cfg.type.data) {\n        this.rawjoins[name] = cfg.type;\n        this.applyStoreMonitor(name);\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.');\n      }\n\n      Object.defineProperty(this, name, {\n        enumerable: true,\n        get: function get() {\n          return me.rawjoins[name];\n        }\n      });\n\n      if (!suppressEvents) {\n        var c = {\n          action: 'create',\n          field: name\n        };\n        this.changelog.push(c);\n        this.emit('relationship.create', c);\n      }\n    }\n\n    /**\n     * @method applyModelMonitor\n     * Applies event handlers for bubbling model events.\n     * @param {string} field\n     * The relationship field name.\n     * @private\n     */\n\n  }, {\n    key: 'applyModelMonitor',\n    value: function applyModelMonitor(name) {\n      var model = this.rawjoins[name];\n      var me = this;\n\n      model.on('field.update', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.old,\n          new: delta.new,\n          join: true\n        });\n      });\n\n      model.on('field.create', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: null,\n          new: null,\n          join: true\n        });\n      });\n\n      model.on('field.remove', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.value,\n          new: null,\n          join: true\n        });\n      });\n    }\n\n    /**\n     * @method applyStoreMonitor\n     * Applies event handlers for store data.\n     * @param {string} name\n     * Name of the raw join.\n     * @private\n     */\n\n  }, {\n    key: 'applyStoreMonitor',\n    value: function applyStoreMonitor(name) {\n      var _this2 = this;\n\n      if (!this.rawjoins.hasOwnProperty(name)) {\n        return;\n      }\n      if (this.rawjoins[name].hasOwnProperty('proxy')) {\n        (function () {\n          var me = _this2;\n\n          _this2.rawjoins[name].on('record.create', function (record) {\n            var old = me[name].data;\n            old.pop();\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n            me.emit('field.update', c);\n          });\n          _this2.rawjoins[name].on('record.update', function (record, delta) {\n            if (!delta) {\n              return;\n            }\n            var c = {\n              action: 'update',\n              field: name + '.' + delta.field,\n              join: true,\n              old: delta.old,\n              new: delta.new\n            };\n            me.emit('field.update', c);\n          });\n          _this2.rawjoins[name].on('record.delete', function (record) {\n            var old = me[name].data;\n            old.push(record.data);\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n            me.emit('field.update', c);\n          });\n        })();\n      }\n    }\n\n    /**\n     * @method removeField\n     * Remove a field from the data model.\n     * @param {string} name\n     * Name of the field to remove.\n     */\n\n  }, {\n    key: 'removeField',\n    value: function removeField(name) {\n      if (this.raw.hasOwnProperty(name)) {\n        var val = this.raw[name];\n        delete this[name];\n        delete this.fields[name]; // eslint-disable-line no-undef\n        delete this.raw[name]; // eslint-disable-line no-undef\n        if (this.invalidDataAttributes.indexOf(name) >= 0) {\n          this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1);\n        }\n        var c = {\n          action: 'delete',\n          field: name,\n          value: val\n        };\n        this.emit('field.remove', c);\n        this.changelog.push(c);\n      }\n    }\n\n    /**\n     * @method removeVirtual\n     * Remove a virtual field.\n     * @param {string} name\n     * Name of the field.\n     */\n\n  }, {\n    key: 'removeVirtual',\n    value: function removeVirtual(name) {\n      delete this[name];\n    }\n\n    /**\n     * @method removeRelationshipField\n     * Remove an existing join dynamically.\n     * @param {string} name\n     * The name of the relationship field to remove.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'removeRelationshipField',\n    value: function removeRelationshipField(name, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      if (this.joins.hasOwnProperty(name)) {\n        var val = this.rawjoins[name];\n        delete this.rawjoins[name];\n        delete this[name];\n        delete this.joins[name];\n        if (!suppressEvents) {\n          var c = {\n            action: 'delete',\n            field: name,\n            old: val,\n            join: true\n          };\n          this.changelog.push(c);\n          this.emit('relationship.remove', c);\n        }\n      }\n    }\n\n    /**\n     * @method undo\n     * A rollback function to undo changes. This operation affects\n     * the changelog. It is possible to undo an undo (i.e. redo).\n     * This works with relationship creating/removing relationship fields,\n     * but not updates to the related model. To undo changes to a relationship\n     * field, the `undo()` method _of the related model_ must be called.\n     * @param {number} [OperationCount=1]\n     * The number of operations to \"undo\". Defaults to a single operation.\n     */\n\n  }, {\n    key: 'undo',\n    value: function undo(back) {\n      back = back || 1;\n      var old = this.changelog.splice(this.changelog.length - back, back);\n      var me = this;\n\n      old.reverse().forEach(function (change) {\n        if (!(typeof change.join === 'boolean' ? change.join : false)) {\n          switch (change.action) {\n            case 'update':\n              me[change.field] = change.old;\n              break;\n            case 'create':\n              me.removeField(change.field);\n              break;\n            case 'delete':\n              me.addField(change.field);\n              me[change.field] = me.old;\n              break;\n          }\n        } else {\n          switch (change.action) {\n            case 'create':\n              me.removeRelationshipField(change.field);\n              break;\n            case 'delete':\n              me.addRelationshipField(change.field);\n              me[change.field] = change.old;\n              break;\n          }\n        }\n      });\n    }\n\n    /**\n     * @method load\n     * Load a data record. This clears the #history. #modified\n     * will be set to `false`, as though the record has been untouched.\n     * @param {object} data\n     * The data to apply to the model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load(data) {\n      data = data || {};\n\n      // Handle data maps\n      var me = this;\n      if (this._dataMap !== null) {\n        Object.keys(this.reverseMap).forEach(function (key) {\n          if (data.hasOwnProperty(key)) {\n            data[me.reverseMap[key]] = data[key];\n            delete data[key];\n          }\n        });\n      }\n\n      // Loop through the keys and add data fields\n      Object.keys(data).forEach(function (key) {\n        if (me.fields.hasOwnProperty(key)) {\n          if (me.raw.hasOwnProperty(key)) {\n            me.raw[key] = data[key];\n          } else if (key === me.idAttribute) {\n            me.id = data[key];\n          }\n        } else if (me.joins.hasOwnProperty(key)) {\n          // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n          // tmp.load(data[key])\n          // me.rawjoin[key] = tmp\n          me.rawjoins[key].load(data[key]);\n        } else {\n          var source = NGN.stack.pop();\n          console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '');\n        }\n      });\n\n      this.setUnmodified();\n    }\n  }, {\n    key: 'modified',\n    get: function get() {\n      return this.checksum !== this.benchmark;\n    }\n\n    /**\n     * @cfgproperty {String/Number/Date} [id=null]\n     * The unique ID of the model object. If #idAttribute is defined,\n     * this will get/set the #idAttribute value.\n     */\n\n  }, {\n    key: 'id',\n    get: function get() {\n      return this.oid;\n    },\n    set: function set(value) {\n      this.oid = value;\n    }\n\n    /**\n     * @property checksum\n     * The unique checksum of the record (i.e. a record fingerprint).\n     * This will change as the data changes.\n     */\n\n  }, {\n    key: 'checksum',\n    get: function get() {\n      return NGN.DATA.util.checksum(JSON.stringify(this.data));\n    }\n\n    /**\n     * @property {Object} dataMap\n     * The current data map.\n     * @private\n     */\n\n  }, {\n    key: 'dataMap',\n    get: function get() {\n      return this._dataMap;\n    },\n    set: function set(value) {\n      this._dataMap = value;\n      this._reverseDataMap = null;\n    }\n\n    /**\n     * @property {NGN.DATA.Store} store\n     * If a store is associated with the model, this will\n     * provide a reference to it. If there is no store, this\n     * will return `null`.\n     */\n\n  }, {\n    key: 'datastore',\n    get: function get() {\n      return this._store;\n    }\n\n    /**\n     * @property {boolean} valid\n     * Indicates the record is valid.\n     */\n\n  }, {\n    key: 'valid',\n    get: function get() {\n      this.validate();\n      return this.invalidDataAttributes.length === 0;\n    }\n\n    /**\n     * @property datafields\n     * Provides an array of data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'datafields',\n    get: function get() {\n      return Object.keys(this.fields);\n    }\n\n    /**\n     * @property reslationships\n     * Provides an array of join fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'relationships',\n    get: function get() {\n      return Object.keys(this.joins);\n    }\n\n    /**\n     * @property virtualdatafields\n     * Provides an array of virtual data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'virtualdatafields',\n    get: function get() {\n      return Object.keys(this.virtuals);\n    }\n\n    /**\n     * @property {object} reverseMap\n     * Reverses the data map. For example, if the original #dataMap\n     * looks like:\n     *\n     * ```js\n     * {\n     *    firstname: 'gn',\n     *    lastname: 'sn\n     * }\n     * ```\n     *\n     * The reverse map will look like:\n     *\n     * ```js\n     * {\n     *    gn: 'firstname',\n     *    sn: 'lastname\n     * }\n     * ```\n     */\n\n  }, {\n    key: 'reverseMap',\n    get: function get() {\n      var _this3 = this;\n\n      if (this.dataMap !== null) {\n        var _ret2 = function () {\n          if (_this3._reverseDataMap !== null) {\n            return {\n              v: _this3._reverseDataMap\n            };\n          }\n          var rmap = {};\n          var me = _this3;\n          Object.keys(_this3._dataMap).forEach(function (attr) {\n            rmap[me._dataMap[attr]] = attr;\n          });\n          _this3._reverseDataMap = rmap;\n          return {\n            v: rmap\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      }\n      return null;\n    }\n\n    /**\n      * @property data\n      * Creates a JSON representation of the data entity. This is\n      * a record that can be persisted to a database or other data store.\n      * @readonly.\n      */\n\n  }, {\n    key: 'data',\n    get: function get() {\n      var _this4 = this;\n\n      var d = this.serialize();\n      if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n        d[this.idAttribute] = this[this.idAttribute];\n      }\n      if (this.dataMap) {\n        (function () {\n          var me = _this4;\n          // Loop through the map keys\n          Object.keys(_this4.dataMap).forEach(function (key) {\n            // If the node contains key, make the mapping\n            if (d.hasOwnProperty(key)) {\n              if (d[key] instanceof NGN.DATA.Model) {\n                d[me.dataMap[key]] = d[key].data;\n              } else {\n                d[me.dataMap[key]] = d[key];\n              }\n              delete d[key];\n            }\n          });\n        })();\n      }\n      return d;\n    }\n\n    /**\n     * @property history\n     * The history of the entity (i.e. changelog).The history\n     * is shown from most recent to oldest change. Keep in mind that\n     * some actions, such as adding new custom fields on the fly, may\n     * be triggered before other updates.\n     * @returns {array}\n     */\n\n  }, {\n    key: 'history',\n    get: function get() {\n      return this.changelog.reverse();\n    }\n  }]);\n\n  return Model;\n}(NGN.EventEmitter);\n\nNGN.DATA = NGN.DATA || {};\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    var ModelLoader = function ModelLoader(data) {\n      var model = new Model(cfg);\n      if (data) {\n        model.load(data);\n      }\n      return model;\n    };\n\n    return ModelLoader;\n  }),\n\n  Entity: NGN.private(Model)\n});\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA;\n}"],"sourceRoot":"/source/"}