{"version":3,"sources":["store.js","store.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Store","_NGN$EventEmitter","cfg","this","_this","getPrototypeOf","model","NGN","_data","_filters","_index","index","_created","_deleted","_loading","proxy","allowDuplicates","coalesce","errorOnDuplicate","forEach","events","BUS","me","eventName","on","args","slice","arguments","shift","push","emit","data","suppressEvent","record","DATA","Entity","JSON","parse","e","Error","hasOwnProperty","_store","dupe","isDuplicate","listen","applyIndices","indexOf","filter","rec","checksum","delta","updateIndice","field","old","undefined","event","add","array","Array","isArray","bulk","clear","findIndex","el","suppressEvents","_this2","removedRecord","dataIndex","Model","m","toString","splice","unapplyIndices","keys","query","ignoreFilters","_this3","resultSet","_ret3","indice","getIndices","idAttribute","trim","v","recordSet","contains","match","noindex","queryKeys","concat","x","map","y","applyFilters","fn","removed","pop","records","stringify","dupes","find","duplicate","remove","_this4","sort","functionKeys","a","b","toLowerCase","reindex","console","warn","exists","store","deleteIndex","number","indexes","values","num","oldValue","newValue","ct","unshift","dataArray","clearIndices","get","d","EventEmitter"],"mappings":"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","file":"store.min.js","sourcesContent":["'use strict'\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n */\nclass Store extends NGN.EventEmitter {\n  constructor (cfg) {\n    cfg = cfg || {}\n    super(cfg)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {NGN.DATA.Model} model\n       * An NGN Data Model to which data records conform.\n       */\n      model: NGN.const(cfg.model || null),\n\n      // The raw data collection\n      _data: NGN.private([]),\n\n      // The raw filters\n      _filters: NGN.private([]),\n\n      // The raw indexes\n      _index: NGN.private(cfg.index || []),\n\n      // Placeholders to track the data that's added/removed\n      // during the lifespan of the store. Modified data is\n      // tracked within each model record.\n      _created: NGN.private([]),\n      _deleted: NGN.private([]),\n      _loading: NGN.private(false),\n\n      /**\n       * @property {NGN.DATA.Proxy} proxy\n       * The proxy used to transmit data over a network.\n       * @private\n       */\n      proxy: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [allowDuplicates=true]\n       * Set to `false` to prevent duplicate records from being added.\n       * If a duplicate record is added, it will be ignored and an\n       * error will be thrown.\n       */\n      allowDuplicates: NGN.public(NGN.coalesce(cfg.allowDuplicates, true)),\n\n      /**\n       * @cfg {boolean} [errorOnDuplicate=false]\n       * Set to `true` to throw an error when a duplicate record is detected.\n       * If this is not set, it will default to the value of #allowDuplicates.\n       * If #allowDuplicates is not defined either, this will be `true`\n       */\n      errorOnDuplicate: NGN.const(NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, true))\n    })\n\n    let obj = {}\n    this._index.forEach(function (i) {\n      obj[i] = []\n    })\n    this._index = obj\n\n    let events = [\n      'record.duplicate',\n      'record.create',\n      'record.update',\n      'record.delete',\n      'clear',\n      'filter.create',\n      'filter.delete',\n      'index.create',\n      'index.delete'\n    ]\n\n    if (NGN.BUS) {\n      const me = this\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.shift()\n          args.push(me)\n          NGN.BUS.emit(eventName, args)\n        })\n      })\n    }\n  }\n\n  /**\n   * @property {array} data\n   * The complete and unfiltered raw underlying dataset. This data\n   * is usually persisted to a database.\n   * @readonly\n   */\n  get data () {\n    return this._data.map(function (d) {\n      return d.data\n    })\n  }\n\n  /**\n   * @property {array} records\n   * An array of NGN.DATA.Model records. If the store has\n   * filters applied, the records will reflect the filtration.\n   * @readonly\n   */\n  get records () {\n    return this.applyFilters(this._data)\n  }\n\n  /**\n   * @property recordCount\n   * The total number of #records in the collection.\n   * @readonly\n   */\n  get recordCount () {\n    return this.applyFilters(this._data).length\n  }\n\n  /**\n   * @property {array} filtered\n   * An array of NGN.DATA.Model records that have been filtered out.\n   * The results reflect the inverse of #records.\n   */\n  get filtered () {\n    let records = this.records\n    return this._data.filter(function (record) {\n      return records.filter(function (rec) {\n        return rec.checksum === record.checksum\n      }).length === 0\n    })\n  }\n\n  /**\n   * @property {NGN.DATA.Model} first\n   * Return the first record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get first () {\n    if (this.records.length === 0) {\n      return null\n    }\n    return this.records[0]\n  }\n\n  /**\n   * @property {NGN.DATA.Model} last\n   * Return the last record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get last () {\n    if (this.records.length === 0) {\n      return null\n    }\n    return this.records[this.records.length - 1]\n  }\n\n  /**\n   * @method add\n   * Add a data record.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  add (data, suppressEvent) {\n    let record\n    const me = this\n\n    if (!(data instanceof NGN.DATA.Entity)) {\n      try { data = JSON.parse(data) } catch (e) {}\n      if (typeof data !== 'object') {\n        throw new Error('Cannot add a non-object record.')\n      }\n      if (this.model) {\n        record = new this.model(data) // eslint-disable-line new-cap\n      } else {\n        record = data\n      }\n    } else {\n      record = data\n    }\n\n    if (record.hasOwnProperty('_store')) {\n      record._store = me\n    }\n\n    let dupe = this.isDuplicate(record)\n    if (dupe) {\n      this.emit('record.duplicate', record)\n      if (!this.allowDuplicates) {\n        if (this.errorOnDuplicate) {\n          throw new Error('Cannot add duplicate record (allowDuplicates = false).')\n        }\n        return\n      }\n    }\n\n    this.listen(record)\n    this.applyIndices(record, this._data.length)\n    this._data.push(record)\n    !this._loading && this._created.indexOf(record) < 0 && this._created.push(record)\n    !NGN.coalesce(suppressEvent, false) && this.emit('record.create', record)\n    return record\n  }\n\n  /**\n   * @method isDuplicate\n   * Indicates whether the specified record is a duplicate.\n   * This compares checksum values. Any match is considered a\n   * duplicate. It will also check for duplication of raw JSON\n   * objects (i.e. non-NGN.DATA.Model records).\n   * @param  {NGN.DATA.Model|Object} record\n   * The record or JSON object.\n   * @return {boolean}\n   */\n  isDuplicate (record) {\n    if (this._data.indexOf(record) >= 0) {\n      return false\n    }\n    return this._data.filter(function (rec) {\n      return rec.checksum === record.checksum\n    }).length > 0\n  }\n\n  /**\n   * @method listen\n   * Listen to a specific record's events and respond.\n   * @param {NGN.DATA.Model} record\n   * The record to listen to.\n   * @fires record.update\n   * Fired when a record is updated. The #record is passed as an argument to\n   * the event handler.\n   * @private\n   */\n  listen (record) {\n    const me = this\n    record.on('field.update', function (delta) {\n      me.updateIndice(delta.field, delta.old, delta.new, me._data.indexOf(record))\n      me.emit('record.update', record, delta)\n    })\n    record.on('field.delete', function (delta) {\n      me.updateIndice(delta.field, delta.old, undefined, me._data.indexOf(record))\n      me.emit('record.update', record, delta)\n    })\n  }\n\n  /**\n   * @method bulk\n   * Bulk load data.\n   * @param {string} eventName\n   * @param {array} data\n   * @private\n   */\n  bulk (event, data) {\n    this._loading = true\n    const me = this\n    data.forEach(function (record) {\n      me.add(record, true)\n    })\n    this._loading = false\n    this._deleted = []\n    this._created = []\n    this.emit(event || 'load')\n  }\n\n  /**\n   * @method load\n   * Bulk load data. This acts the same as adding records,\n   * but it suppresses individual record creation events.\n   * This will add data to the existing collection. If you\n   * want to load fresh data, use the #reload method.\n   * @param {array} data\n   * An array of data. Each array element should be an\n   * NGN.DATA.Model or a JSON object that can be applied\n   * to the store's #model.\n   */\n  load () {\n    let array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments)\n    this.bulk('load', array)\n  }\n\n  /**\n   * @method reload\n   * Reload data. This is the same as running #clear followed\n   * by #load.\n   */\n  reload (data) {\n    this.clear()\n    let array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments)\n    this.bulk('reload', array)\n  }\n\n  /**\n   * @method indexOf\n   * Find the index number of a record within the collection.\n   * @param  {NGN.DATA.Model} record\n   * The record whose index should be identified.\n   * @return {Number}\n   * Returns a number from `0-collection length`. Returns `-1` if\n   * the record is not found in the collection.\n   */\n  indexOf (record) {\n    if (typeof record !== 'object' || (!(record instanceof NGN.DATA.Entity) && !record.checksum)) {\n      return -1\n    }\n    return this._data.findIndex(function (el) {\n      return el.checksum === record.checksum\n    })\n  }\n\n  /**\n   * @method contains\n   * A convenience method that indicates whether a record is in\n   * the store or not.\n   * @param {NGN.DATA.Model} record\n   * The record to check for inclusion in the data collection.\n   * @return {Boolean}\n   */\n  contains (record) {\n    return this.indexOf(record) >= 0\n  }\n\n  /**\n   * @method remove\n   * Remove a record.\n   * @param {NGN.DATA.Model|object|number} data\n   * Accepts an existing NGN Data Model, JSON object,\n   * or index number. Using a JSON object is slower\n   * than using a reference to a data model or an index\n   * number (index is fastest).\n   * @fires record.delete\n   * @returns {NGN.DATA.Model}\n   * Returns the data model that was just removed. If a model\n   * is unavailable (i.e. remove didn't find the specified record),\n   * this will return `null`.\n   */\n  remove (data, suppressEvents) {\n    let removedRecord = []\n    let dataIndex\n\n    if (typeof data === 'number') {\n      dataIndex = data\n    } else if (data && data.checksum && data.checksum !== null || data instanceof NGN.DATA.Model) {\n      dataIndex = this.indexOf(data)\n    } else {\n      let m = new this.model(data, true) // eslint-disable-line new-cap\n      dataIndex = this._data.findIndex(function (el) {\n        return el.checksum === m.checksum\n      })\n    }\n\n    // If no record is found, the operation fails.\n    if (dataIndex < 0) {\n      throw new Error('Record removal failed (record not found at index ' + (dataIndex || '').toString() + ').')\n    }\n\n    removedRecord = this._data.splice(dataIndex, 1)\n\n    if (removedRecord.length > 0) {\n      removedRecord = removedRecord[0]\n      this.unapplyIndices(dataIndex)\n      if (!this._loading) {\n        let i = this._created.indexOf(removedRecord)\n        if (i >= 0) {\n          i >= 0 && this._created.splice(i, 1)\n        } else if (this._deleted.indexOf(removedRecord) < 0) {\n          this._deleted.push(removedRecord)\n        }\n      }\n\n      if (!NGN.coalesce(suppressEvents, false)) {\n        this.emit('record.delete', removedRecord)\n      }\n\n      return removedRecord\n    }\n\n    return null\n  }\n\n  /**\n   * @method clear\n   * Removes all data.\n   * @fires clear\n   * Fired when all data is removed\n   */\n  clear () {\n    this._data = []\n    const me = this\n    Object.keys(this._index).forEach(function (index) {\n      me._index[index] = []\n    })\n    this.emit('clear')\n  }\n\n  /**\n   * @method find\n   * Retrieve a specific record or set of records.\n   * @param {number|function|string|object} [query=null]\n   * When this is set to a `number`, the corresponding zero-based\n   * record will be returned. A `function` can also be used, which\n   * acts like a filter. Each record is passed to this function.\n   *\n   * For example, if we want to find all administrators within a\n   * set of users, the following could be used:\n   *\n   * ```js\n   *   let record = MyStore.find(function (record) {\n   *     return record.usertype = 'admin'\n   *   })\n   * ```\n   *\n   * It's also possible to supply a String. When this is supplied,\n   * the store will look for a record whose ID (see NGN.DATA.Model#idAttribute)\n   * matches the string. Numberic ID's are matched on their string\n   * equivalent for search purposes (data is not modified).\n   *\n   * An object can be used to search for specific field values. For example:\n   *\n   * ```js\n   * MyStore.find({\n   *   firstname: 'Corey',\n   *   lastname: /Butler|Doe/\n   * })\n   * ```\n   *\n   * The code above will find everyone named Corey Butler or Corey Doe. The\n   * first attribute must match the value exactly whereas `lastname` will\n   * match against the regular expression.\n   *\n   * If this parameter is `undefined` or `null`, all records will be\n   * returned (i.e. no search criteria specified, so return everything).\n   *\n   * If you're using a large dataset, indexing can speed up queries. To take\n   * full advantage of indexing, all of the query elements should be indexed.\n   * For example, if you have `lastname`, 'firstname' in your query and\n   * both of those are indexed, the response time will be substantially faster\n   * than if they're not (in large data sets). However; if one of those\n   * elements is _not_ indexed, performance may not increase.\n   * @param {boolean} [ignoreFilters=false]\n   * Set this to `true` to search the full unfiltered record set.\n   * @return {NGN.DATA.Model|array|null}\n   * An array is returned when a function is specified for the query.\n   * Otherwise the specific record is return. This method assumes\n   * records have unique ID's.\n   */\n  find (query, ignoreFilters) {\n    if (this._data.length === 0) {\n      return []\n    }\n\n    let resultSet = []\n    const me = this\n\n    switch (typeof query) {\n      case 'function':\n        resultSet = this._data.filter(query)\n        break\n      case 'number':\n        resultSet = (query < 0 || query >= this._data.length) ? null : this._data[query]\n        break\n      case 'string':\n        let indice = this.getIndices(this._data[0].idAttribute, query.trim())\n        if (indice !== null && indice.length > 0) {\n          indice.forEach(function (index) {\n            resultSet.push(me._data[index])\n          })\n          return resultSet\n        }\n\n        let recordSet = this._data.filter(function (record) {\n          return (record[record.idAttribute] || '').toString().trim() === query.trim()\n        })\n\n        resultSet = recordSet.length === 0 ? null : recordSet[0]\n\n        break\n      case 'object':\n        if (query instanceof NGN.DATA.Model) {\n          if (this.contains(query)) {\n            return query\n          }\n          return null\n        }\n\n        let match = []\n        let noindex = []\n        let queryKeys = Object.keys(query)\n\n        queryKeys.forEach(function (field) {\n          let index = me.getIndices(field, query[field])\n          if (index) {\n            match = match.concat(index || [])\n          } else {\n            field !== null && noindex.push(field)\n          }\n        })\n\n        // Deduplicate\n        match.filter(function (index, i) {\n          return match.indexOf(index) === i\n        })\n\n        // Get non-indexed matches\n        if (noindex.length > 0) {\n          resultSet = this._data.filter(function (record, i) {\n            if (match.indexOf(i) >= 0) {\n              return false\n            }\n            for (let x = 0; x < noindex.length; x++) {\n              if (record[noindex[x]] !== query[noindex[x]]) {\n                return false\n              }\n            }\n            return true\n          })\n        }\n\n        // If a combined indexable + nonindexable query\n        resultSet = resultSet.concat(match.map(function (index) {\n          return me._data[index]\n        })).filter(function (record) {\n          for (let y = 0; y < queryKeys.length; y++) {\n            if (query[queryKeys[y]] !== record[queryKeys[y]]) {\n              return false\n            }\n          }\n          return true\n        })\n        break\n      default:\n        resultSet = this._data\n    }\n\n    if (resultSet === null) {\n      return null\n    }\n\n    if (!NGN.coalesce(ignoreFilters, false)) {\n      this.applyFilters(resultSet instanceof Array ? resultSet : [resultSet])\n    }\n\n    return resultSet\n  }\n\n  /**\n   * @method applyFilters\n   * Apply filters to a data set.\n   * @param {array} data\n   * The array of data to apply filters to.\n   * @private\n   */\n  applyFilters (data) {\n    if (this._filters.length === 0) {\n      return data\n    }\n\n    this._filters.forEach(function (filter) {\n      data = data.filter(filter)\n    })\n\n    return data\n  }\n\n  /**\n   * @method addFilter\n   * Add a filter to the record set.\n   * @param {function} fn\n   * The filter function. This function should comply\n   * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n   * returning a boolean value.\n   * The item passed to the filter will be the NGN.DATA.Model specified\n   * in the cfg#model.\n   * @fires filter.create\n   * Fired when a filter is created.\n   */\n  addFilter (fn) {\n    this._filters.push(fn)\n    this.emit('filter.create', fn)\n  }\n\n  /**\n   * @method removeFilter\n   * Remove a filter from the record set.\n   * @param {function|index} filter\n   * This can be the function which was originally passed to\n   * the #addFilter method, or the zero-based #filters index\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing one the creation of the filter.\n   * @fires filter.delete\n   * Fired when a filter is removed.\n   */\n  removeFilter (fn, suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, false)\n\n    let removed = []\n\n    if (typeof fn === 'number') {\n      removed = this._filters.splice(fn, 1)\n    } else {\n      removed = this._filters.splice(this._filters.indexOf(fn), 1)\n    }\n\n    if (removed.length > 0 && !suppressEvents) {\n      this.emit('filter.delete', removed[0])\n    }\n  }\n\n  /**\n   * @method clearFilters\n   * Remove all filters.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing one the removal of each filter.\n   */\n  clearFilters (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, false)\n\n    if (suppressEvents) {\n      this._filters = []\n      return\n    }\n\n    const me = this\n    while (this._filters.length > 0) {\n      me.emit('filter.delete', this._filters.pop())\n    }\n  }\n\n  /**\n   * @method deduplicate\n   * Deduplicates the recordset. This compares the checksum of\n   * each of the records to each other and removes duplicates.\n   * This suppresses the removal\n   * @param {boolean} [suppressEvents=true]\n   * Suppress the event that gets fired when a record is removed.\n   */\n  deduplicate (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, true)\n\n    let records = this.data.map(function (rec) {\n      return JSON.stringify(rec)\n    })\n\n    let dupes = []\n    const me = this\n\n    records.forEach(function (record, i) {\n      if (records.indexOf(record) < i) {\n        dupes.push(me.find(i))\n      }\n    })\n\n    dupes.forEach(function (duplicate) {\n      me.remove(duplicate)\n    })\n  }\n\n  /**\n   * @method sort\n   * Sort the #records. This forces a #reindex, which may potentially be\n   * an expensive operation on large data sets.\n   * @param {function|object} sorter\n   * Using a function is exactly the same as using the\n   * [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsort) method\n   * (this is the compare function). The arguments passed to the\n   * method are NGN.DATA.Model objects.\n   * Alternatively, it is possible to sort by one or more model\n   * attributes. Each attribute For example:\n   *\n   * ```js\n   * let Person = new NGN.DATA.Model({\n   *   fields: {\n   *     fname: null,\n   *     lname: null\n   *   }\n   * })\n   *\n   * let People = new NGN.DATA.Store({\n   *   model: Person\n   * })\n   *\n   * People.add({\n   *   fname: 'John',\n   *   lname: 'Doe',\n   *   age: 37\n   * }, {\n   *   fname: 'Jane',\n   *   lname: 'Doe',\n   *   age: 36\n   * }, {\n   *   fname: 'Jane',\n   *   lname: 'Vaughn',\n   *   age: 42\n   * })\n   *\n   * People.sort({\n   *   lname: 'asc',  // Sort by last name in normal alphabetical order.\n   *   age: 'desc'    // Sort by age, oldest to youngest.\n   * })\n   *\n   * People.records.forEach(function (p) {\n   *   console.log(fname, lname, age)\n   * })\n   *\n   * // DISPLAYS\n   * // John Doe 37\n   * // Jane Doe 36\n   * // Jane Vaughn 42\n   *\n   * People.sort({\n   *   age: 'desc',  // Sort by age, oldest to youngest.\n   *   lname: 'asc'  // Sort by name in normal alphabetical order.\n   * })\n   *\n   * People.records.forEach(function (p) {\n   *   console.log(fname, lname, age)\n   * })\n   *\n   * // DISPLAYS\n   * // Jane Vaughn 42\n   * // John Doe 37\n   * // Jane Doe 36\n   * ```\n   *\n   * It is also posible to provide complex sorters. For example:\n   *\n   * ```js\n   * People.sort({\n   *   lname: 'asc',\n   *   age: function (a, b) {\n   *     if (a.age < 40) {\n   *       return 1\n   *     }\n   *     return a.age < b.age\n   *   }\n   * })\n   * ```\n   *\n   * The sorter above says \"sort alphabetically by last name,\n   * then by age where anyone under 40yrs old shows up before\n   * everyone else, but sort the remainder ages in descending order.\n   */\n  sort (fn) {\n    if (typeof fn === 'function') {\n      this.records.sort(fn)\n    } else if (typeof fn === 'object') {\n      let functionKeys = Object.keys(fn)\n\n      this.records.sort(function (a, b) {\n        for (let i = 0; i < functionKeys.length; i++) {\n          // Make sure both objects have the same sorting key\n          if (a.hasOwnProperty(functionKeys[i]) && !b.hasOwnProperty(functionKeys[i])) {\n            return 1\n          }\n\n          if (!a.hasOwnProperty(functionKeys[i]) && b.hasOwnProperty(functionKeys[i])) {\n            return -1\n          }\n\n          // For objects who have the key, sort in the order defined in object.\n          if (a[functionKeys[i]] !== b[functionKeys[i]]) {\n            switch (fn[functionKeys[i]].toString().trim().toLowerCase()) {\n              case 'asc':\n                return a[functionKeys[i]] > b[functionKeys[i]] ? 1 : -1\n              case 'desc':\n                return a[functionKeys[i]] < b[functionKeys[i]] ? 1 : -1\n              default:\n                if (typeof fn[functionKeys[i]] === 'function') {\n                  return fn[functionKeys[i]](a, b)\n                }\n                return 0\n            }\n          }\n        }\n\n        // Everything is equal\n        return 0\n      })\n    }\n\n    this.reindex()\n  }\n\n  /**\n   * @method createIndex\n   * Add a simple index to the recordset.\n   * @param {string} datafield\n   * The #model data field to index.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing on the creation of the index.\n   * @fires index.create\n   * Fired when an index is created. The datafield name and\n   * store are supplied as an argument to event handlers.\n   */\n  createIndex (field, suppressEvents) {\n    if (!this.model.hasOwnProperty(field)) {\n      console.warn(\"The store's model does not contain a data field called \" + field + '.')\n    }\n\n    let exists = this._index.hasOwnProperty(field)\n\n    this._index[field] = this._index[field] || []\n    if (!NGN.coalesce(suppressEvents, false) && !exists) {\n      this.emit('index.created', {\n        field: field,\n        store: this\n      })\n    }\n  }\n\n  /**\n   * @method deleteIndex\n   * Remove an index.\n   * @param {string} datafield\n   * The #model data field to stop indexing.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing on the removal of the index.\n   * @fires index.delete\n   * Fired when an index is deleted. The datafield name and\n   * store are supplied as an argument to event handlers.\n   */\n  deleteIndex (field, suppressEvents) {\n    if (this._index.hasOwnProperty(field)) {\n      delete this._index[field]\n      if (!NGN.coalesce(suppressEvents, false)) {\n        this.emit('index.created', {\n          field: field,\n          store: this\n        })\n      }\n    }\n  }\n\n  /**\n   * @method clearIndices\n   * Clear all indices from the indexes.\n   */\n  clearIndices () {\n    const me = this\n\n    Object.keys(this._index).forEach(function (key) {\n      me._index[key] = []\n    })\n  }\n\n  /**\n   * @method deleteIndexes\n   * Remove all indexes.\n   * @param {boolean} [suppressEvents=true]\n   * Prevent events from firing on the removal of each index.\n   */\n  deleteIndexes (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, true)\n\n    const me = this\n\n    Object.keys(this._index).forEach(function (key) {\n      me.deleteIndex(key, suppressEvents)\n    })\n  }\n\n  /**\n   * @method applyIndices\n   * Apply the values to the index.\n   * @param {NGN.DATA.Model} record\n   * The record which should be applied to the index.\n   * @param {number} number\n   * The record index number.\n   * @private\n   */\n  applyIndices (record, number) {\n    let indexes = Object.keys(this._index)\n\n    if (indexes.length === 0) {\n      return\n    }\n\n    const me = this\n\n    indexes.forEach(function (field) {\n      if (record.hasOwnProperty(field)) {\n        let values = me._index[field]\n\n        // Check existing records for similar values\n        for (let i = 0; i < values.length; i++) {\n          if (values[i][0] === record[field]) {\n            me._index[field][i].push(number)\n            return\n          }\n        }\n\n        // No matching words, create a new one.\n        me._index[field].push([record[field], number])\n      }\n    })\n  }\n\n  /**\n   * @method unapplyIndices\n   * This removes a record from all relevant indexes simultaneously.\n   * Commonly used when removing a record from the store.\n   * @param  {number} indexNumber\n   * The record index.\n   * @private\n   */\n  unapplyIndices (num) {\n    const me = this\n\n    Object.keys(this._index).forEach(function (field) {\n      let i = me._index[field].indexOf(num)\n      if (i >= 0) {\n        me._index[field].splice(i, 1)\n      }\n    })\n  }\n\n  /**\n   * @method updateIndice\n   * Update the index with new values.\n   * @param  {string} fieldname\n   * The name of the indexed field.\n   * @param  {any} oldValue\n   * The original value. This is used to remove the old value from the index.\n   * @param  {any} newValue\n   * The new value.\n   * @param  {number} indexNumber\n   * The number of the record index.\n   * @private\n   */\n  updateIndice (field, oldValue, newValue, num) {\n    if (!this._index.hasOwnProperty(field) || oldValue === newValue) {\n      return\n    }\n\n    let ct = 0\n    const me = this\n\n    for (let i = 0; i < me._index[field].length; i++) {\n      let value = me._index[field][i][0]\n\n      if (value === oldValue) {\n        me._index[field][i].splice(me._index[field][i].indexOf(num), 1)\n        ct++\n      } else if (newValue === undefined) {\n        // If thr new value is undefined, the field was removed for the record.\n        // This can be skipped.\n        ct++\n      } else if (value === newValue) {\n        me._index[field][i].push(num)\n        me._index[field][i].shift()\n        me._index[field][i].sort()\n        me._index[field][i].unshift(value)\n        ct++\n      }\n\n      if (ct === 2) {\n        return\n      }\n    }\n  }\n\n  /**\n   * @method getIndices\n   * Retrieve a list of index numbers pertaining to a field value.\n   * @param  {string} field\n   * Name of the data field.\n   * @param  {any} value\n   * The value of the index to match against.\n   * @return {array}\n   * Returns an array of integers representing the index where the\n   * values exist in the record set.\n   */\n  getIndices (field, value) {\n    if (!this._index.hasOwnProperty(field)) {\n      return null\n    }\n\n    let indexes = this._index[field].filter(function (dataArray) {\n      return dataArray.length > 0 && dataArray[0] === value\n    })\n\n    if (indexes.length === 1) {\n      indexes[0].shift()\n      return indexes[0]\n    }\n\n    return []\n  }\n\n  /**\n   * @method reindex\n   * Reindex the entire record set. This can be expensive operation.\n   * Use with caution.\n   * @private\n   */\n  reindex () {\n    this.clearIndices()\n    const me = this\n    this._data.forEach(function (record, index) {\n      me.applyIndices(record, index)\n    })\n  }\n}\n\n/**\n * indexes\n * An index consists of an object whose key is name of the\n * data field being indexed. The value is an array of record values\n * and their corresponding index numbers. For example:\n *\n * ```js\n * {\n *   \"lastname\": [[\"Butler\", 0, 1, 3], [\"Doe\", 2, 4]]\n * }\n * ```\n * The above example indicates the store has two unique `lastname`\n * values, \"Butler\" and \"Doe\". Records containing a `lastname` of\n * \"Butler\" exist in the record store as the first, 2nd, and 4th\n * records. Records with the last name \"Doe\" are 3rd and 5th.\n * Remember indexes are zero based since records are stored as an\n * array.\n */\n\nNGN.DATA.Store = Store\n","'use strict';\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Store = function (_NGN$EventEmitter) {\n  _inherits(Store, _NGN$EventEmitter);\n\n  function Store(cfg) {\n    _classCallCheck(this, Store);\n\n    cfg = cfg || {};\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Store).call(this, cfg));\n\n    Object.defineProperties(_this, {\n      /**\n       * @cfg {NGN.DATA.Model} model\n       * An NGN Data Model to which data records conform.\n       */\n      model: NGN.const(cfg.model || null),\n\n      // The raw data collection\n      _data: NGN.private([]),\n\n      // The raw filters\n      _filters: NGN.private([]),\n\n      // The raw indexes\n      _index: NGN.private(cfg.index || []),\n\n      // Placeholders to track the data that's added/removed\n      // during the lifespan of the store. Modified data is\n      // tracked within each model record.\n      _created: NGN.private([]),\n      _deleted: NGN.private([]),\n      _loading: NGN.private(false),\n\n      /**\n       * @property {NGN.DATA.Proxy} proxy\n       * The proxy used to transmit data over a network.\n       * @private\n       */\n      proxy: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [allowDuplicates=true]\n       * Set to `false` to prevent duplicate records from being added.\n       * If a duplicate record is added, it will be ignored and an\n       * error will be thrown.\n       */\n      allowDuplicates: NGN.public(NGN.coalesce(cfg.allowDuplicates, true)),\n\n      /**\n       * @cfg {boolean} [errorOnDuplicate=false]\n       * Set to `true` to throw an error when a duplicate record is detected.\n       * If this is not set, it will default to the value of #allowDuplicates.\n       * If #allowDuplicates is not defined either, this will be `true`\n       */\n      errorOnDuplicate: NGN.const(NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, true))\n    });\n\n    var obj = {};\n    _this._index.forEach(function (i) {\n      obj[i] = [];\n    });\n    _this._index = obj;\n\n    var events = ['record.duplicate', 'record.create', 'record.update', 'record.delete', 'clear', 'filter.create', 'filter.delete', 'index.create', 'index.delete'];\n\n    if (NGN.BUS) {\n      (function () {\n        var me = _this;\n        events.forEach(function (eventName) {\n          me.on(eventName, function () {\n            var args = NGN.slice(arguments);\n            args.shift();\n            args.push(me);\n            NGN.BUS.emit(eventName, args);\n          });\n        });\n      })();\n    }\n    return _this;\n  }\n\n  /**\n   * @property {array} data\n   * The complete and unfiltered raw underlying dataset. This data\n   * is usually persisted to a database.\n   * @readonly\n   */\n\n\n  _createClass(Store, [{\n    key: 'add',\n\n\n    /**\n     * @method add\n     * Add a data record.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n    value: function add(data, suppressEvent) {\n      var record = void 0;\n      var me = this;\n\n      if (!(data instanceof NGN.DATA.Entity)) {\n        try {\n          data = JSON.parse(data);\n        } catch (e) {}\n        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n          throw new Error('Cannot add a non-object record.');\n        }\n        if (this.model) {\n          record = new this.model(data); // eslint-disable-line new-cap\n        } else {\n          record = data;\n        }\n      } else {\n        record = data;\n      }\n\n      if (record.hasOwnProperty('_store')) {\n        record._store = me;\n      }\n\n      var dupe = this.isDuplicate(record);\n      if (dupe) {\n        this.emit('record.duplicate', record);\n        if (!this.allowDuplicates) {\n          if (this.errorOnDuplicate) {\n            throw new Error('Cannot add duplicate record (allowDuplicates = false).');\n          }\n          return;\n        }\n      }\n\n      this.listen(record);\n      this.applyIndices(record, this._data.length);\n      this._data.push(record);\n      !this._loading && this._created.indexOf(record) < 0 && this._created.push(record);\n      !NGN.coalesce(suppressEvent, false) && this.emit('record.create', record);\n      return record;\n    }\n\n    /**\n     * @method isDuplicate\n     * Indicates whether the specified record is a duplicate.\n     * This compares checksum values. Any match is considered a\n     * duplicate. It will also check for duplication of raw JSON\n     * objects (i.e. non-NGN.DATA.Model records).\n     * @param  {NGN.DATA.Model|Object} record\n     * The record or JSON object.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isDuplicate',\n    value: function isDuplicate(record) {\n      if (this._data.indexOf(record) >= 0) {\n        return false;\n      }\n      return this._data.filter(function (rec) {\n        return rec.checksum === record.checksum;\n      }).length > 0;\n    }\n\n    /**\n     * @method listen\n     * Listen to a specific record's events and respond.\n     * @param {NGN.DATA.Model} record\n     * The record to listen to.\n     * @fires record.update\n     * Fired when a record is updated. The #record is passed as an argument to\n     * the event handler.\n     * @private\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(record) {\n      var me = this;\n      record.on('field.update', function (delta) {\n        me.updateIndice(delta.field, delta.old, delta.new, me._data.indexOf(record));\n        me.emit('record.update', record, delta);\n      });\n      record.on('field.delete', function (delta) {\n        me.updateIndice(delta.field, delta.old, undefined, me._data.indexOf(record));\n        me.emit('record.update', record, delta);\n      });\n    }\n\n    /**\n     * @method bulk\n     * Bulk load data.\n     * @param {string} eventName\n     * @param {array} data\n     * @private\n     */\n\n  }, {\n    key: 'bulk',\n    value: function bulk(event, data) {\n      this._loading = true;\n      var me = this;\n      data.forEach(function (record) {\n        me.add(record, true);\n      });\n      this._loading = false;\n      this._deleted = [];\n      this._created = [];\n      this.emit(event || 'load');\n    }\n\n    /**\n     * @method load\n     * Bulk load data. This acts the same as adding records,\n     * but it suppresses individual record creation events.\n     * This will add data to the existing collection. If you\n     * want to load fresh data, use the #reload method.\n     * @param {array} data\n     * An array of data. Each array element should be an\n     * NGN.DATA.Model or a JSON object that can be applied\n     * to the store's #model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments);\n      this.bulk('load', array);\n    }\n\n    /**\n     * @method reload\n     * Reload data. This is the same as running #clear followed\n     * by #load.\n     */\n\n  }, {\n    key: 'reload',\n    value: function reload(data) {\n      this.clear();\n      var array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments);\n      this.bulk('reload', array);\n    }\n\n    /**\n     * @method indexOf\n     * Find the index number of a record within the collection.\n     * @param  {NGN.DATA.Model} record\n     * The record whose index should be identified.\n     * @return {Number}\n     * Returns a number from `0-collection length`. Returns `-1` if\n     * the record is not found in the collection.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(record) {\n      if ((typeof record === 'undefined' ? 'undefined' : _typeof(record)) !== 'object' || !(record instanceof NGN.DATA.Entity) && !record.checksum) {\n        return -1;\n      }\n      return this._data.findIndex(function (el) {\n        return el.checksum === record.checksum;\n      });\n    }\n\n    /**\n     * @method contains\n     * A convenience method that indicates whether a record is in\n     * the store or not.\n     * @param {NGN.DATA.Model} record\n     * The record to check for inclusion in the data collection.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(record) {\n      return this.indexOf(record) >= 0;\n    }\n\n    /**\n     * @method remove\n     * Remove a record.\n     * @param {NGN.DATA.Model|object|number} data\n     * Accepts an existing NGN Data Model, JSON object,\n     * or index number. Using a JSON object is slower\n     * than using a reference to a data model or an index\n     * number (index is fastest).\n     * @fires record.delete\n     * @returns {NGN.DATA.Model}\n     * Returns the data model that was just removed. If a model\n     * is unavailable (i.e. remove didn't find the specified record),\n     * this will return `null`.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(data, suppressEvents) {\n      var _this2 = this;\n\n      var removedRecord = [];\n      var dataIndex = void 0;\n\n      if (typeof data === 'number') {\n        dataIndex = data;\n      } else if (data && data.checksum && data.checksum !== null || data instanceof NGN.DATA.Model) {\n        dataIndex = this.indexOf(data);\n      } else {\n        (function () {\n          var m = new _this2.model(data, true); // eslint-disable-line new-cap\n          dataIndex = _this2._data.findIndex(function (el) {\n            return el.checksum === m.checksum;\n          });\n        })();\n      }\n\n      // If no record is found, the operation fails.\n      if (dataIndex < 0) {\n        throw new Error('Record removal failed (record not found at index ' + (dataIndex || '').toString() + ').');\n      }\n\n      removedRecord = this._data.splice(dataIndex, 1);\n\n      if (removedRecord.length > 0) {\n        removedRecord = removedRecord[0];\n        this.unapplyIndices(dataIndex);\n        if (!this._loading) {\n          var i = this._created.indexOf(removedRecord);\n          if (i >= 0) {\n            i >= 0 && this._created.splice(i, 1);\n          } else if (this._deleted.indexOf(removedRecord) < 0) {\n            this._deleted.push(removedRecord);\n          }\n        }\n\n        if (!NGN.coalesce(suppressEvents, false)) {\n          this.emit('record.delete', removedRecord);\n        }\n\n        return removedRecord;\n      }\n\n      return null;\n    }\n\n    /**\n     * @method clear\n     * Removes all data.\n     * @fires clear\n     * Fired when all data is removed\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this._data = [];\n      var me = this;\n      Object.keys(this._index).forEach(function (index) {\n        me._index[index] = [];\n      });\n      this.emit('clear');\n    }\n\n    /**\n     * @method find\n     * Retrieve a specific record or set of records.\n     * @param {number|function|string|object} [query=null]\n     * When this is set to a `number`, the corresponding zero-based\n     * record will be returned. A `function` can also be used, which\n     * acts like a filter. Each record is passed to this function.\n     *\n     * For example, if we want to find all administrators within a\n     * set of users, the following could be used:\n     *\n     * ```js\n     *   let record = MyStore.find(function (record) {\n     *     return record.usertype = 'admin'\n     *   })\n     * ```\n     *\n     * It's also possible to supply a String. When this is supplied,\n     * the store will look for a record whose ID (see NGN.DATA.Model#idAttribute)\n     * matches the string. Numberic ID's are matched on their string\n     * equivalent for search purposes (data is not modified).\n     *\n     * An object can be used to search for specific field values. For example:\n     *\n     * ```js\n     * MyStore.find({\n     *   firstname: 'Corey',\n     *   lastname: /Butler|Doe/\n     * })\n     * ```\n     *\n     * The code above will find everyone named Corey Butler or Corey Doe. The\n     * first attribute must match the value exactly whereas `lastname` will\n     * match against the regular expression.\n     *\n     * If this parameter is `undefined` or `null`, all records will be\n     * returned (i.e. no search criteria specified, so return everything).\n     *\n     * If you're using a large dataset, indexing can speed up queries. To take\n     * full advantage of indexing, all of the query elements should be indexed.\n     * For example, if you have `lastname`, 'firstname' in your query and\n     * both of those are indexed, the response time will be substantially faster\n     * than if they're not (in large data sets). However; if one of those\n     * elements is _not_ indexed, performance may not increase.\n     * @param {boolean} [ignoreFilters=false]\n     * Set this to `true` to search the full unfiltered record set.\n     * @return {NGN.DATA.Model|array|null}\n     * An array is returned when a function is specified for the query.\n     * Otherwise the specific record is return. This method assumes\n     * records have unique ID's.\n     */\n\n  }, {\n    key: 'find',\n    value: function find(query, ignoreFilters) {\n      var _this3 = this;\n\n      if (this._data.length === 0) {\n        return [];\n      }\n\n      var resultSet = [];\n      var me = this;\n\n      var _ret3 = function () {\n        switch (typeof query === 'undefined' ? 'undefined' : _typeof(query)) {\n          case 'function':\n            resultSet = _this3._data.filter(query);\n            break;\n          case 'number':\n            resultSet = query < 0 || query >= _this3._data.length ? null : _this3._data[query];\n            break;\n          case 'string':\n            var indice = _this3.getIndices(_this3._data[0].idAttribute, query.trim());\n            if (indice !== null && indice.length > 0) {\n              indice.forEach(function (index) {\n                resultSet.push(me._data[index]);\n              });\n              return {\n                v: resultSet\n              };\n            }\n\n            var recordSet = _this3._data.filter(function (record) {\n              return (record[record.idAttribute] || '').toString().trim() === query.trim();\n            });\n\n            resultSet = recordSet.length === 0 ? null : recordSet[0];\n\n            break;\n          case 'object':\n            if (query instanceof NGN.DATA.Model) {\n              if (_this3.contains(query)) {\n                return {\n                  v: query\n                };\n              }\n              return {\n                v: null\n              };\n            }\n\n            var match = [];\n            var noindex = [];\n            var queryKeys = Object.keys(query);\n\n            queryKeys.forEach(function (field) {\n              var index = me.getIndices(field, query[field]);\n              if (index) {\n                match = match.concat(index || []);\n              } else {\n                field !== null && noindex.push(field);\n              }\n            });\n\n            // Deduplicate\n            match.filter(function (index, i) {\n              return match.indexOf(index) === i;\n            });\n\n            // Get non-indexed matches\n            if (noindex.length > 0) {\n              resultSet = _this3._data.filter(function (record, i) {\n                if (match.indexOf(i) >= 0) {\n                  return false;\n                }\n                for (var x = 0; x < noindex.length; x++) {\n                  if (record[noindex[x]] !== query[noindex[x]]) {\n                    return false;\n                  }\n                }\n                return true;\n              });\n            }\n\n            // If a combined indexable + nonindexable query\n            resultSet = resultSet.concat(match.map(function (index) {\n              return me._data[index];\n            })).filter(function (record) {\n              for (var y = 0; y < queryKeys.length; y++) {\n                if (query[queryKeys[y]] !== record[queryKeys[y]]) {\n                  return false;\n                }\n              }\n              return true;\n            });\n            break;\n          default:\n            resultSet = _this3._data;\n        }\n      }();\n\n      if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n      if (resultSet === null) {\n        return null;\n      }\n\n      if (!NGN.coalesce(ignoreFilters, false)) {\n        this.applyFilters(resultSet instanceof Array ? resultSet : [resultSet]);\n      }\n\n      return resultSet;\n    }\n\n    /**\n     * @method applyFilters\n     * Apply filters to a data set.\n     * @param {array} data\n     * The array of data to apply filters to.\n     * @private\n     */\n\n  }, {\n    key: 'applyFilters',\n    value: function applyFilters(data) {\n      if (this._filters.length === 0) {\n        return data;\n      }\n\n      this._filters.forEach(function (filter) {\n        data = data.filter(filter);\n      });\n\n      return data;\n    }\n\n    /**\n     * @method addFilter\n     * Add a filter to the record set.\n     * @param {function} fn\n     * The filter function. This function should comply\n     * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n     * returning a boolean value.\n     * The item passed to the filter will be the NGN.DATA.Model specified\n     * in the cfg#model.\n     * @fires filter.create\n     * Fired when a filter is created.\n     */\n\n  }, {\n    key: 'addFilter',\n    value: function addFilter(fn) {\n      this._filters.push(fn);\n      this.emit('filter.create', fn);\n    }\n\n    /**\n     * @method removeFilter\n     * Remove a filter from the record set.\n     * @param {function|index} filter\n     * This can be the function which was originally passed to\n     * the #addFilter method, or the zero-based #filters index\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing one the creation of the filter.\n     * @fires filter.delete\n     * Fired when a filter is removed.\n     */\n\n  }, {\n    key: 'removeFilter',\n    value: function removeFilter(fn, suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, false);\n\n      var removed = [];\n\n      if (typeof fn === 'number') {\n        removed = this._filters.splice(fn, 1);\n      } else {\n        removed = this._filters.splice(this._filters.indexOf(fn), 1);\n      }\n\n      if (removed.length > 0 && !suppressEvents) {\n        this.emit('filter.delete', removed[0]);\n      }\n    }\n\n    /**\n     * @method clearFilters\n     * Remove all filters.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing one the removal of each filter.\n     */\n\n  }, {\n    key: 'clearFilters',\n    value: function clearFilters(suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, false);\n\n      if (suppressEvents) {\n        this._filters = [];\n        return;\n      }\n\n      var me = this;\n      while (this._filters.length > 0) {\n        me.emit('filter.delete', this._filters.pop());\n      }\n    }\n\n    /**\n     * @method deduplicate\n     * Deduplicates the recordset. This compares the checksum of\n     * each of the records to each other and removes duplicates.\n     * This suppresses the removal\n     * @param {boolean} [suppressEvents=true]\n     * Suppress the event that gets fired when a record is removed.\n     */\n\n  }, {\n    key: 'deduplicate',\n    value: function deduplicate(suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, true);\n\n      var records = this.data.map(function (rec) {\n        return JSON.stringify(rec);\n      });\n\n      var dupes = [];\n      var me = this;\n\n      records.forEach(function (record, i) {\n        if (records.indexOf(record) < i) {\n          dupes.push(me.find(i));\n        }\n      });\n\n      dupes.forEach(function (duplicate) {\n        me.remove(duplicate);\n      });\n    }\n\n    /**\n     * @method sort\n     * Sort the #records. This forces a #reindex, which may potentially be\n     * an expensive operation on large data sets.\n     * @param {function|object} sorter\n     * Using a function is exactly the same as using the\n     * [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsort) method\n     * (this is the compare function). The arguments passed to the\n     * method are NGN.DATA.Model objects.\n     * Alternatively, it is possible to sort by one or more model\n     * attributes. Each attribute For example:\n     *\n     * ```js\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     fname: null,\n     *     lname: null\n     *   }\n     * })\n     *\n     * let People = new NGN.DATA.Store({\n     *   model: Person\n     * })\n     *\n     * People.add({\n     *   fname: 'John',\n     *   lname: 'Doe',\n     *   age: 37\n     * }, {\n     *   fname: 'Jane',\n     *   lname: 'Doe',\n     *   age: 36\n     * }, {\n     *   fname: 'Jane',\n     *   lname: 'Vaughn',\n     *   age: 42\n     * })\n     *\n     * People.sort({\n     *   lname: 'asc',  // Sort by last name in normal alphabetical order.\n     *   age: 'desc'    // Sort by age, oldest to youngest.\n     * })\n     *\n     * People.records.forEach(function (p) {\n     *   console.log(fname, lname, age)\n     * })\n     *\n     * // DISPLAYS\n     * // John Doe 37\n     * // Jane Doe 36\n     * // Jane Vaughn 42\n     *\n     * People.sort({\n     *   age: 'desc',  // Sort by age, oldest to youngest.\n     *   lname: 'asc'  // Sort by name in normal alphabetical order.\n     * })\n     *\n     * People.records.forEach(function (p) {\n     *   console.log(fname, lname, age)\n     * })\n     *\n     * // DISPLAYS\n     * // Jane Vaughn 42\n     * // John Doe 37\n     * // Jane Doe 36\n     * ```\n     *\n     * It is also posible to provide complex sorters. For example:\n     *\n     * ```js\n     * People.sort({\n     *   lname: 'asc',\n     *   age: function (a, b) {\n     *     if (a.age < 40) {\n     *       return 1\n     *     }\n     *     return a.age < b.age\n     *   }\n     * })\n     * ```\n     *\n     * The sorter above says \"sort alphabetically by last name,\n     * then by age where anyone under 40yrs old shows up before\n     * everyone else, but sort the remainder ages in descending order.\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(fn) {\n      var _this4 = this;\n\n      if (typeof fn === 'function') {\n        this.records.sort(fn);\n      } else if ((typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === 'object') {\n        (function () {\n          var functionKeys = Object.keys(fn);\n\n          _this4.records.sort(function (a, b) {\n            for (var i = 0; i < functionKeys.length; i++) {\n              // Make sure both objects have the same sorting key\n              if (a.hasOwnProperty(functionKeys[i]) && !b.hasOwnProperty(functionKeys[i])) {\n                return 1;\n              }\n\n              if (!a.hasOwnProperty(functionKeys[i]) && b.hasOwnProperty(functionKeys[i])) {\n                return -1;\n              }\n\n              // For objects who have the key, sort in the order defined in object.\n              if (a[functionKeys[i]] !== b[functionKeys[i]]) {\n                switch (fn[functionKeys[i]].toString().trim().toLowerCase()) {\n                  case 'asc':\n                    return a[functionKeys[i]] > b[functionKeys[i]] ? 1 : -1;\n                  case 'desc':\n                    return a[functionKeys[i]] < b[functionKeys[i]] ? 1 : -1;\n                  default:\n                    if (typeof fn[functionKeys[i]] === 'function') {\n                      return fn[functionKeys[i]](a, b);\n                    }\n                    return 0;\n                }\n              }\n            }\n\n            // Everything is equal\n            return 0;\n          });\n        })();\n      }\n\n      this.reindex();\n    }\n\n    /**\n     * @method createIndex\n     * Add a simple index to the recordset.\n     * @param {string} datafield\n     * The #model data field to index.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing on the creation of the index.\n     * @fires index.create\n     * Fired when an index is created. The datafield name and\n     * store are supplied as an argument to event handlers.\n     */\n\n  }, {\n    key: 'createIndex',\n    value: function createIndex(field, suppressEvents) {\n      if (!this.model.hasOwnProperty(field)) {\n        console.warn(\"The store's model does not contain a data field called \" + field + '.');\n      }\n\n      var exists = this._index.hasOwnProperty(field);\n\n      this._index[field] = this._index[field] || [];\n      if (!NGN.coalesce(suppressEvents, false) && !exists) {\n        this.emit('index.created', {\n          field: field,\n          store: this\n        });\n      }\n    }\n\n    /**\n     * @method deleteIndex\n     * Remove an index.\n     * @param {string} datafield\n     * The #model data field to stop indexing.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing on the removal of the index.\n     * @fires index.delete\n     * Fired when an index is deleted. The datafield name and\n     * store are supplied as an argument to event handlers.\n     */\n\n  }, {\n    key: 'deleteIndex',\n    value: function deleteIndex(field, suppressEvents) {\n      if (this._index.hasOwnProperty(field)) {\n        delete this._index[field];\n        if (!NGN.coalesce(suppressEvents, false)) {\n          this.emit('index.created', {\n            field: field,\n            store: this\n          });\n        }\n      }\n    }\n\n    /**\n     * @method clearIndices\n     * Clear all indices from the indexes.\n     */\n\n  }, {\n    key: 'clearIndices',\n    value: function clearIndices() {\n      var me = this;\n\n      Object.keys(this._index).forEach(function (key) {\n        me._index[key] = [];\n      });\n    }\n\n    /**\n     * @method deleteIndexes\n     * Remove all indexes.\n     * @param {boolean} [suppressEvents=true]\n     * Prevent events from firing on the removal of each index.\n     */\n\n  }, {\n    key: 'deleteIndexes',\n    value: function deleteIndexes(suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, true);\n\n      var me = this;\n\n      Object.keys(this._index).forEach(function (key) {\n        me.deleteIndex(key, suppressEvents);\n      });\n    }\n\n    /**\n     * @method applyIndices\n     * Apply the values to the index.\n     * @param {NGN.DATA.Model} record\n     * The record which should be applied to the index.\n     * @param {number} number\n     * The record index number.\n     * @private\n     */\n\n  }, {\n    key: 'applyIndices',\n    value: function applyIndices(record, number) {\n      var indexes = Object.keys(this._index);\n\n      if (indexes.length === 0) {\n        return;\n      }\n\n      var me = this;\n\n      indexes.forEach(function (field) {\n        if (record.hasOwnProperty(field)) {\n          var values = me._index[field];\n\n          // Check existing records for similar values\n          for (var i = 0; i < values.length; i++) {\n            if (values[i][0] === record[field]) {\n              me._index[field][i].push(number);\n              return;\n            }\n          }\n\n          // No matching words, create a new one.\n          me._index[field].push([record[field], number]);\n        }\n      });\n    }\n\n    /**\n     * @method unapplyIndices\n     * This removes a record from all relevant indexes simultaneously.\n     * Commonly used when removing a record from the store.\n     * @param  {number} indexNumber\n     * The record index.\n     * @private\n     */\n\n  }, {\n    key: 'unapplyIndices',\n    value: function unapplyIndices(num) {\n      var me = this;\n\n      Object.keys(this._index).forEach(function (field) {\n        var i = me._index[field].indexOf(num);\n        if (i >= 0) {\n          me._index[field].splice(i, 1);\n        }\n      });\n    }\n\n    /**\n     * @method updateIndice\n     * Update the index with new values.\n     * @param  {string} fieldname\n     * The name of the indexed field.\n     * @param  {any} oldValue\n     * The original value. This is used to remove the old value from the index.\n     * @param  {any} newValue\n     * The new value.\n     * @param  {number} indexNumber\n     * The number of the record index.\n     * @private\n     */\n\n  }, {\n    key: 'updateIndice',\n    value: function updateIndice(field, oldValue, newValue, num) {\n      if (!this._index.hasOwnProperty(field) || oldValue === newValue) {\n        return;\n      }\n\n      var ct = 0;\n      var me = this;\n\n      for (var i = 0; i < me._index[field].length; i++) {\n        var value = me._index[field][i][0];\n\n        if (value === oldValue) {\n          me._index[field][i].splice(me._index[field][i].indexOf(num), 1);\n          ct++;\n        } else if (newValue === undefined) {\n          // If thr new value is undefined, the field was removed for the record.\n          // This can be skipped.\n          ct++;\n        } else if (value === newValue) {\n          me._index[field][i].push(num);\n          me._index[field][i].shift();\n          me._index[field][i].sort();\n          me._index[field][i].unshift(value);\n          ct++;\n        }\n\n        if (ct === 2) {\n          return;\n        }\n      }\n    }\n\n    /**\n     * @method getIndices\n     * Retrieve a list of index numbers pertaining to a field value.\n     * @param  {string} field\n     * Name of the data field.\n     * @param  {any} value\n     * The value of the index to match against.\n     * @return {array}\n     * Returns an array of integers representing the index where the\n     * values exist in the record set.\n     */\n\n  }, {\n    key: 'getIndices',\n    value: function getIndices(field, value) {\n      if (!this._index.hasOwnProperty(field)) {\n        return null;\n      }\n\n      var indexes = this._index[field].filter(function (dataArray) {\n        return dataArray.length > 0 && dataArray[0] === value;\n      });\n\n      if (indexes.length === 1) {\n        indexes[0].shift();\n        return indexes[0];\n      }\n\n      return [];\n    }\n\n    /**\n     * @method reindex\n     * Reindex the entire record set. This can be expensive operation.\n     * Use with caution.\n     * @private\n     */\n\n  }, {\n    key: 'reindex',\n    value: function reindex() {\n      this.clearIndices();\n      var me = this;\n      this._data.forEach(function (record, index) {\n        me.applyIndices(record, index);\n      });\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      return this._data.map(function (d) {\n        return d.data;\n      });\n    }\n\n    /**\n     * @property {array} records\n     * An array of NGN.DATA.Model records. If the store has\n     * filters applied, the records will reflect the filtration.\n     * @readonly\n     */\n\n  }, {\n    key: 'records',\n    get: function get() {\n      return this.applyFilters(this._data);\n    }\n\n    /**\n     * @property recordCount\n     * The total number of #records in the collection.\n     * @readonly\n     */\n\n  }, {\n    key: 'recordCount',\n    get: function get() {\n      return this.applyFilters(this._data).length;\n    }\n\n    /**\n     * @property {array} filtered\n     * An array of NGN.DATA.Model records that have been filtered out.\n     * The results reflect the inverse of #records.\n     */\n\n  }, {\n    key: 'filtered',\n    get: function get() {\n      var records = this.records;\n      return this._data.filter(function (record) {\n        return records.filter(function (rec) {\n          return rec.checksum === record.checksum;\n        }).length === 0;\n      });\n    }\n\n    /**\n     * @property {NGN.DATA.Model} first\n     * Return the first record in the store. Returns `null`\n     * if the store is empty.\n     */\n\n  }, {\n    key: 'first',\n    get: function get() {\n      if (this.records.length === 0) {\n        return null;\n      }\n      return this.records[0];\n    }\n\n    /**\n     * @property {NGN.DATA.Model} last\n     * Return the last record in the store. Returns `null`\n     * if the store is empty.\n     */\n\n  }, {\n    key: 'last',\n    get: function get() {\n      if (this.records.length === 0) {\n        return null;\n      }\n      return this.records[this.records.length - 1];\n    }\n  }]);\n\n  return Store;\n}(NGN.EventEmitter);\n\n/**\n * indexes\n * An index consists of an object whose key is name of the\n * data field being indexed. The value is an array of record values\n * and their corresponding index numbers. For example:\n *\n * ```js\n * {\n *   \"lastname\": [[\"Butler\", 0, 1, 3], [\"Doe\", 2, 4]]\n * }\n * ```\n * The above example indicates the store has two unique `lastname`\n * values, \"Butler\" and \"Doe\". Records containing a `lastname` of\n * \"Butler\" exist in the record store as the first, 2nd, and 4th\n * records. Records with the last name \"Doe\" are 3rd and 5th.\n * Remember indexes are zero based since records are stored as an\n * array.\n */\n\nNGN.DATA.Store = Store;"],"sourceRoot":"/source/"}