{"version":3,"sources":["chassis.legacy.min.js","eventemitter.js","polyfill.js","core.js","ngn.js","exception.js","dom.js","bus.js","reference.js","net.js","svg.js","utility.js","model.js","store.js","proxy.js"],"names":["_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","TypeError","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_classCallCheck","instance","Constructor","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Array","findIndex","predicate","this","Error","list","thisArg","arguments","window","NGN","e","w","c","v","public","define","private","const","privateconst","get","fn","set","extend","attribute","specification","inherit","source","dest","getOwnPropertyNames","forEach","attr","definition","getOwnPropertyDescriptor","slice","splice","coalesce","arg","undefined","nodelike","node","require","dedupe","array","filter","element","index","indexOf","typeof","el","toString","split","replace","toLowerCase","name","stack","me","item","map","location","origin","process","cwd","trim","path","substr","file","line","parseInt","column","reverse","css","global","document","addEventListener","body","classList","add","EventEmitter","cfg","handlers","adhoc","maxlisteners","defaultMaxListeners","eventName","keys","concat","callback","prepend","emit","listenerCount","on","apply","args","push","once","handlerFn","deleteEventHandler","type","scope","_ret","result","handler","off","onceoff","_this","clear","shift","events","getAllEvents","event","adhocEvent","pop","regularEvents","adhocEvents","allEvents","RegExp","test","subscriberList","queued","pool","prefix","group","topic","console","warn","attach","preventDefaultAction","hasOwnProperty","preventDefault","unshift","bind","triggers","payload","listener","trigger","argList","remove","queue","delay","_this2","_arguments","setTimeout","CustomException","_Error","config","_this3","getPrototypeOf","message","custom","severity","category","prepareStackTrace","_","_err","captureStackTrace","rawstack","err","cause","help","info","frame","getFileName","__filename","join","filename","getLineNumber","getColumnNumber","functionname","getFunctionName","native","isNative","eval","isEval","getTypeName","module","exports","DOM","ready","destroy","str","querySelectorAll","parentNode","removeChild","log","findParent","selector","maxDepth","currentNode","querySelector","nodeName","indexOfParent","children","ref","requireBUS","nm","BUS","error","qs","all","_find","reference","find","tmpref","html","els","isArray","base","evt","removeEventListener","forward","cleankey","cleanKey","val","ck","json","parser","DOMParser","fs","Network","xhr","res","XMLHttpRequest","onreadystatechange","readyState","run","method","url","NET","open","send","applyRequestSettings","params","parms","parm","encodeURIComponent","header","headers","setRequestHeader","JSON","stringify","form","FormData","append","withCredentials","username","password","btoa","accessToken","getFile","rsp","status","existsSync","responseText","readFileSync","normalizeUrl","uri","processImport","before","createTextNode","_ret3","out","insertBefore","appendChild","domainRoot","r","search","match","host","isCrossOrigin","prelink","rel","cor","head","p","createElement","href","pathname","setAttribute","importCache","parseFromString","applyData","tpl","data","re","parse","bypassCache","_this4","_ret4","num","int","setInterval","clearInterval","ext","s","onload","getElementsByTagName","doc","domain","protocol","fuoc","ss","svg","_cache","swap","svgs","attributes","output","getAttribute","attrs","exec","sep","x","idx","a","outerHTML","id","cleanCode","code","viewbox","cache","fetchFile","_this5","content","resolve","__dirname","ee","update","section","_splice","sec","imgs","unfetched","remaining","monitor","DATA","util","crcTable","makeCRCTable","n","k","checksum","crc","charCodeAt","GUID","lut","d0","Math","random","d1","d2","d3","Model","_NGN$EventEmitter","_this6","idAttribute","fields","required","String","default","joins","relationships","virtuals","validators","validation","isNew","isRecordDestroyed","oid","autoid","benchmark","expiration","expirationTimeout","hasExpired","ignoreTTL","createDate","Date","now","setUnmodified","changelog","allowInvalidSave","disableDataValidation","invalidDataAttributes","initialDataAttributes","_nativeValidators","min","minimum","max","maximum","enum","valid","field","_dataMap","dataMap","_reverseDataMap","raw","rawjoins","_store","allfields","datafields","virtualdatafields","addField","addRelationshipField","expires","duration","expired","clearTimeout","property","validator","validateDataType","validate","fieldType","expectedType","fieldname","_obj","rtn","nonEnumerableProperties","enumerableProperties","dsc","refs","toJSON","fieldcfg","suppressEvents","charAt","toUpperCase","old","wasInvalid","action","new","addValidator","pattern","entityType","Store","model","storeCfg","applyStoreMonitor","applyModelMonitor","delta","originalEvent","record","_this7","back","change","removeRelationshipField","removeField","reverseMap","load","_this8","currentDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","expire","waitPeriod","_this9","_ret9","rmap","_this10","d","serialize","ModelLoader","Entity","_NGN$EventEmitter2","_this11","_data","_filters","_index","_created","_deleted","_loading","_softarchive","proxy","allowDuplicates","errorOnDuplicate","autoRemoveExpiredRecords","softDelete","softDeleteTtl","suppressEvent","dupe","isDuplicate","listen","applyIndices","insert","position","move","rec","_this12","updateIndice","_this13","bulk","_this14","removedRecord","dataIndex","m","isDestroyed","unapplyIndices","purgeDeletedRecord","purgedRecord","findArchivedRecord","removeAllListeners","_this15","purge","query","ignoreFilters","_this16","resultSet","_ret13","indice","getIndices","recordSet","contains","noindex","queryKeys","y","applyFilters","removed","_this17","records","dupes","duplicate","_this18","sort","functionKeys","b","localeCompare","reindex","exists","store","_this19","_this20","deleteIndex","number","_this21","indexes","values","_this22","oldValue","newValue","ct","dataArray","getRecordIndex","oldIndex","newIndex","_this23","clearIndices","Proxy","_NGN$EventEmitter3","_this24","token","modified","delete"],"mappings":";;;;AAAA,YAMA,SAASA,4BAA2BC,EAAMC,GAAQ,IAAKD,EAAQ,KAAM,IAAIE,gBAAe,4DAAgE,QAAOD,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BD,EAAPC,EAElO,QAASE,WAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIC,WAAU,iEAAoED,GAAeD,GAASG,UAAYC,OAAOC,OAAOJ,GAAcA,EAAWE,WAAaG,aAAeC,MAAOP,EAAUQ,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeT,IAAYG,OAAOO,eAAiBP,OAAOO,eAAeX,EAAUC,GAAcD,EAASY,UAAYX,GAEje,QAASY,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIb,WAAU,qCARhH,GAAIc,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIb,cAAgBW,OAAS,eAAkBE,IAEtOC,aAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWlB,WAAakB,EAAWlB,aAAc,EAAOkB,EAAWhB,cAAe,EAAU,SAAWgB,KAAYA,EAAWjB,UAAW,GAAML,OAAOuB,eAAeL,EAAQI,EAAWE,IAAKF,IAAiB,MAAO,UAAUX,EAAac,EAAYC,GAAiJ,MAA9HD,IAAYR,EAAiBN,EAAYZ,UAAW0B,GAAiBC,GAAaT,EAAiBN,EAAae,GAAqBf,KCFhiB,ICAAgB,MAAA5B,UAAA6B,YACAD,MAAA5B,UAAA6B,UAAA,SAAAC,GACA,GAAA,OAAAC,KACA,KAAA,IAAAC,OAAA,wDAUA,KAAA,GAFA5B,GAHA6B,EAAAhC,OAAA8B,MACAT,EAAAW,EAAAX,SAAA,EACAY,EAAAC,UAAA,GAGAd,EAAA,EAAAA,EAAAC,EAAAD,IAEA,GADAjB,EAAA6B,EAAAZ,GACAS,EAAApC,KAAAwC,EAAA9B,EAAAiB,EAAAY,GACA,MAAAZ,EAGA,YCnBAe,OAAAC,OAiCApC,OAAAuB,eAAAa,IAAA,UACAhC,YAAA,EACAC,UAAA,EACAC,cAAA,EACAH,MAAA,SAAAkC,EAAAC,EAAAC,EAAAC,GACA,OACApC,WAAAiC,EACAhC,SAAAiC,EACAhC,aAAAiC,EACApC,MAAAqC,MAKAxC,OAAAiB,iBAAAmB,KAsBAK,SAAAL,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAvC,GACA,MAAAiC,KAAAM,QAAA,EAAA,kBAAAvC,IAAA,EAAAA,KAwBAwC,UAAAP,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAvC,GACA,MAAAiC,KAAAM,QAAA,EAAA,kBAAAvC,IAAA,EAAAA,KAwBAyC,QAAAR,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAvC,GACA,MAAAiC,KAAAM,QAAA,GAAA,GAAA,EAAAvC,KAwBA0C,aAAAT,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAvC,GACA,MAAAiC,KAAAM,QAAA,GAAA,GAAA,EAAAvC,KA2BA2C,IAAAV,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAK,GACA,OACA3C,YAAA,EACA0C,IAAAC,KA4BAC,IAAAZ,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAK,GACA,OACA3C,YAAA,EACA4C,IAAAD,OAKA/C,OAAAiB,iBAAAmB,KAgDAa,OAAAb,IAAAS,aAAA,SAAAK,EAAAC,GACAnD,OAAAuB,eAAAO,KAAAoB,EAAAC,KAWAC,QAAAhB,IAAAA,SAAA,SAAAiB,EAAAC,GACAD,GAAAC,IAGAD,EAAA,kBAAAA,GAAAA,EAAAtD,UAAAsD,EACAC,EAAA,kBAAAA,GAAAA,EAAAvD,UAAAuD,EACAtD,OAAAuD,oBAAAF,GAAAG,QAAA,SAAAC,GACA,GAAAC,GAAA1D,OAAA2D,yBAAAN,EAAAI,EACAzD,QAAAuB,eAAA+B,EAAAG,EAAAC,QAkBAE,MAAAxB,IAAAA,WAAA,SAAArB,GACA,MAAAY,OAAA5B,UAAA6D,MAAAnE,KAAAsB,KAiBA8C,OAAAzB,IAAAA,WAAA,SAAArB,GACA,MAAAY,OAAA5B,UAAA8D,OAAApE,KAAAsB,KAWA+C,SAAA1B,IAAAA,UAAA,WACA,IAAA,GAAA2B,KAAA7B,WACA,GAAA8B,SAAA9B,UAAA6B,IAAA,OAAA7B,UAAA6B,GACA,MAAA7B,WAAA6B,EAGA,OAAA,QAUAE,SAAA7B,IAAAU,IAAA,WACA,GAAAoB,IAAA,CACA,KACAA,EAAAF,SAAAG,QACA,MAAA9B,IACA,MAAA6B,KAYAE,OAAAhC,IAAAA,WAAA,SAAAiC,GACA,MAAAA,GAAAC,OAAA,SAAAC,EAAAC,GACA,MAAAH,GAAAI,QAAAF,KAAAC,MAYAE,SAAAtC,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAiC,GACA,GAAAxE,GAAAH,OAAAD,UAAA6E,SAAAnF,KAAAkF,GAAAE,MAAA,KAAA,GAAAC,QAAA,UAAA,IAAAC,aACA,IAAA,aAAA5E,EAAA,CACA,IAAAwE,EAAAK,KACA,MAAAL,GAAAC,WAAAE,QAAA,OAAA,IAAAA,QAAA,uBAAA,IAAAC,aAEA5E,GAAAwE,EAAAK,MAAA,WAGA,MAAA7E,GAAA4E,gBA8DAE,MAAA7C,IAAAU,IAAA,WACA,GAAAoC,GAAApD,KAEAmD,IADA,GAAAlD,QAAAkD,MAAAJ,MAAA,OACA,GAAA9C,QAAAkD,MAAAJ,MAAA,UAuBA,OArBAI,GAAAA,EAAAX,OAAA,SAAAa,GACA,MAAAA,GAAAN,MAAA,KAAAxD,OAAA,IACA+D,IAAA,SAAAD,GAWA,MAVAA,GAAAA,EACAL,QAAA,WAAA,IACAA,QAAA,OAAA,IACAA,QAAA,SAAA,IACAA,QAAAd,SAAA7B,OAAAA,OAAAkD,SAAAC,OAAAtB,SAAAuB,QAAAA,QAAAC,MAAA,GAAA,IACAV,QAAA,YAAA,IACAA,QAAA,yBAAA,IACAA,QAAA,cAAA,WACAW,OAAAZ,MAAA,MAGAa,KAAAP,EAAA,GAAAQ,OAAAT,EAAAjB,SAAA,EAAA,EAAAkB,EAAA,GAAA9D,QAAA6D,EAAAjB,SAAA,EAAA,IAAA,IAAAkB,EAAA,GAAA,IAAAA,EAAA,GACAS,KAAAT,EAAA,GAAAQ,OAAAT,EAAAjB,SAAA,EAAA,EAAAkB,EAAA,GAAA9D,QAAA6D,EAAAjB,SAAA,EAAA,IACA4B,KAAAC,SAAAX,EAAA,GAAA,IACAY,OAAAD,SAAAX,EAAA,GAAA,OAIA,IAAAF,EAAA5D,SAEAqE,KAAA,UACAE,KAAA,UACAC,KAAA,EACAE,OAAA,KAEAb,EAAAjB,UACAgB,EAAAe,UAGAf,KAcAgB,IAAA7D,IAAAS,aAAA,wBChfA7C,OAAAuB,eAAAa,IAAA,SAAAA,IAAAS,aAAAT,IAAA6B,SAAAiC,OAAA/D,SAGAgE,SAAAC,iBAAA,mBAAA,WACAD,SAAAE,KAAAC,UAAAC,IAAA,UHJApE,OAAAC,IACA,KAAA,IAAAL,OAAA,8DD2iBA,ICjiBAyE,cDiiBmB,WCthBnB,QAAAA,GAAAC,GAAAhG,gBAAAqB,KAAA0E,GACAC,EAAAA,MACAzG,OAAAiB,iBAAAa,MACA4E,SAAAtE,IAAAA,eACAuE,MAAAvE,IAAAA,eACAwE,aAAAxE,IAAAA,WAAAqE,EAAAI,qBAAA,MD+8BE,MAjaA7F,cAAawF,IACXhF,IAAK,gBASLrB,MAAO,SCxgBX2G,GACA,OAAAhF,KAAA4E,SAAAI,QAAAzF,QACAS,KAAA6E,MAAAG,QAAAzF,UDihBIG,IAAK,kBACLrB,MAAO,WCzgBX,MAAA2B,MAAA+E,uBDmhBIrF,IAAK,kBACLrB,MAAO,SC7gBXA,GACA2B,KAAA+E,oBAAA1G,KDuhBIqB,IAAK,aACLrB,MAAO,WC/gBX,GAAAuG,GAAA1G,OAAA+G,KAAAjF,KAAA4E,UACAC,EAAA3G,OAAA+G,KAAAjF,KAAA6E,MACA,OAAAvE,KAAAgC,OAAAsC,EAAAM,OAAAL,OD4hBInF,IAAK,YACLrB,MAAO,SCnhBX2G,GACA,GAAAJ,GAAA5E,KAAA4E,SAAAI,OACAH,EAAA7E,KAAA6E,MAAAG,MACA,OAAAJ,GAAAM,OAAAL,MDmiBInF,IAAK,KACLrB,MAAO,SCthBX2G,EAAAG,EAAAC,GAIA,GAHApF,KAAA4E,SAAAI,GAAAhF,KAAA4E,SAAAI,OACAhF,KAAA4E,SAAAI,GAAA1E,IAAA0B,SAAAoD,GAAA,GAAA,UAAA,QAAAD,GACAnF,KAAAqF,KAAA,cAAAL,EAAAG,GACAnF,KAAAsF,cAAAN,GAAAhF,KAAA8E,aACA,KAAA,IAAA7E,OAAA,mFDgiBIP,IAAK,cACLrB,MAAO,WCxhBX2B,KAAAuF,GAAAC,MAAAxF,KAAAI,cDuiBIV,IAAK,kBACLrB,MAAO,WC3hBX,GAAAoH,GAAAnF,IAAAwB,MAAA1B,WAAAsF,MAAA,EACA1F,MAAAuF,GAAAC,MAAAxF,KAAAyF,MD+iBI/F,IAAK,OACLrB,MAAO,SC/hBX2G,EAAAG,EAAAC,GAIA,GAHApF,KAAA6E,MAAAG,GAAAhF,KAAA6E,MAAAG,OACAhF,KAAA6E,MAAAG,GAAA1E,IAAA0B,SAAAoD,GAAA,GAAA,UAAA,QAAAD,GACAnF,KAAAqF,KAAA,cAAAL,EAAAG,GACAnF,KAAAsF,cAAAN,GAAAhF,KAAA8E,aACA,KAAA,IAAA7E,OAAA,mFD8iBIP,IAAK,sBACLrB,MAAO,WCjiBX,GAAAoH,GAAAnF,IAAAwB,MAAA1B,WAAAsF,MAAA,EACA1F,MAAA2F,KAAAH,MAAAxF,KAAAyF,MDgjBI/F,IAAK,MACLrB,MAAO,SCriBX2G,EAAAY,GACA5F,KAAA6F,mBAAA,WAAAb,EAAAY,MDmjBIlG,IAAK,UACLrB,MAAO,SCxiBX2G,EAAAY,GACA5F,KAAA6F,mBAAA,QAAAb,EAAAY,MDwjBIlG,IAAK,qBACLrB,MAAO,SC3iBXyH,EAAAd,EAAAY,GACA,GAAAG,GAAA/F,KAAA8F,EAEA,IAAAC,EAAAf,GAAA,CAAA,GAAAgB,GAAA,WACA,IAAAJ,EAEA,aADAG,GAAAf,IACAtE,EAAA,OAGA,IAAAuF,KAOA,OANAF,GAAAf,GAAAtD,QAAA,SAAAwE,GACAA,EAAApD,aAAA8C,EAAA9C,YACAmD,EAAAP,KAAAQ,KAIA,IAAAD,EAAA1G,cACAwG,GAAAf,IACAtE,EAAA,cAGAqF,EAAAf,GAAAiB,KAlBA,IAAA,YAAA,mBAAAD,GAAA,YAAAlH,QAAAkH,IAAA,MAAAA,GAAAtF,MD+kBIhB,IAAK,iBACLrB,MAAO,WCrjBX2B,KAAAmG,IAAAX,MAAAxF,KAAAI,WACAJ,KAAAoG,QAAAZ,MAAAxF,KAAAI,cD+jBIV,IAAK,QACLrB,MAAO,WCzjBX,GAAAgI,GAAArG,IACAI,WAAAb,OAAA,EACAe,IAAAwB,MAAA1B,WAAAsB,QAAA,SAAAsD,SACAqB,GAAAzB,SAAAI,SACAqB,GAAAxB,MAAAG,MAGAhF,KAAA4E,YACA5E,KAAA6E,aDqkBInF,IAAK,qBACLrB,MAAO,WC7jBX2B,KAAAsG,MAAAd,MAAAxF,KAAAI,cDolBIV,IAAK,OACLrB,MAAO,WChkBX,GAAAoH,GAAAnF,IAAAwB,MAAA1B,WACA4E,EAAAS,EAAAc,QACAC,EAAAxG,KAAAyG,aAAAzB,GAEAe,GACAW,MAAA1B,EAGA,KAAA,GAAA9B,KAAAsD,GAAA,CACA,GAAAG,GAAA3G,KAAA6E,MAAA2B,EAAAtD,GAEA,IAAAyD,EAGA,UAFA3G,MAAA6E,MAAA2B,EAAAtD,IAEAyD,EAAApH,OAAA,GAAA,CACA,GAAA0B,GAAA0F,EAAAC,KACAb,GAAAG,QAAAjF,EACAA,EAAAuE,MAAAO,EAAAN,GAKA,GAAAS,GAAAlG,KAAA4E,SAAA4B,EAAAtD,GACA,IAAAgD,EACA,IAAA,GAAAjF,KAAAiF,GACAH,EAAAG,QAAAA,EAAAjF,GACAiF,EAAAjF,GAAAuE,MAAAO,EAAAN,ODqlBI/F,IAAK,eACLrB,MAAO,SCpkBX2G,GACA,GAAA6B,GAAA3I,OAAA+G,KAAAjF,KAAA4E,UACAkC,EAAA5I,OAAA+G,KAAAjF,KAAA6E,OACAkC,EAAAzG,IAAAgC,OAAAuE,EAAA3B,OAAA4B,GAsBA,OApBAC,GAAAA,EAAAvE,OAAA,SAAAkE,GAEA,MAAAA,KAAA1B,IAKA,WAAA1E,IAAAA,UAAAoG,IAAAA,EAAA/D,QAAA,MAAA,KAEA,WAAArC,IAAAA,UAAAoG,KACAA,EAAA,GAAAM,QAAAN,EAAA1D,QAAA,IAAA,KAAA,QAGA0D,EAAAO,KAAAjC,SD8kBItF,IAAK,cACLsB,IAAK,WCj6BT,GAAAkG,KAEA,KAAA,GAAAlC,KAAAhF,MAAA4E,SACAsC,EAAAlC,IACAkB,QAAAlG,KAAA4E,SAAAI,GAAAzF,OACAsF,MAAA,EAIA,KAAA,GAAAG,KAAAhF,MAAA6E,MACAqC,EAAAlC,GAAAkC,EAAAlC,KACAkB,QAAA,GAGAgB,EAAAlC,GAAAH,MAAA7E,KAAA6E,MAAAG,GAAAzF,MAGA,OAAA2H,MD26BIxH,IAAK,sBACLsB,IAAK,WCp6BT,MAAAhB,MAAA8E,cDu6BI5D,IAAK,SCp6BT7C,GACA2B,KAAA8E,aAAAzG,MDw6BSqG,ICxmBTpE,KAAAa,OAAA,eAAAb,IAAAA,WAAAoE,eA9XApE,IAAAgB,QAAApD,OAAAiB,qBACAgI,OAAA7G,IAAAA,eAiBA8G,KAAA9G,IAAAA,SAAA,SAAA+G,EAAAC,EAAAnC,GACA,gBAAAkC,KACAC,EAAAD,EACAA,EAAA,GAGA,IAAAD,KAEA,KAAA,GAAApC,KAAAsC,GAAA,CACA,GAAAC,IAAAF,EAAA1D,QAAA,IAAAqB,CACA,mBAAAsC,GAAAtC,GACAoC,EAAApC,GAAAhF,KAAAuF,GAAAgC,EAAAD,EAAAtC,IAEAwC,QAAAC,KAAA,KAAAF,EAAA,oFAAAjH,IAAA6D,IAAA,IAGAgB,GACAA,EAAAiC,KA8BAM,OAAApH,IAAAA,SAAA,SAAA0E,EAAA2C,GACA,GAAAvE,GAAApD,IAGA,OAFA2H,GAAArH,IAAA0B,SAAA2F,GAAA,GAEA,SAAApH,GACAoH,GAAApH,EAAAqH,eAAA,mBACArH,EAAAsH,gBAEA,IAAApC,GAAAnF,IAAAwB,MAAA1B,UACAqF,GAAAqC,QAAA9C,GACA5B,EAAAiC,KAAAG,MAAApC,EAAAqC,MA2BAsC,KAAAzH,IAAAA,SAAA,SAAA0E,EAAAgD,EAAAC,GACAD,EAAA,gBAAAA,IAAAA,GAAAA,CAEA,IAAA5E,GAAApD,KACAkI,EAAA,WACA,GAAAzC,GAAAnF,IAAAwB,MAAA1B,UAEA6H,IACAxC,EAAAC,KAAAuC,EAGA,KAAA,GAAAE,KAAAH,GAAA,CACA,GAAAI,GAAA3C,EAAA3D,OACAsG,GAAAN,QAAAE,EAAAG,IACA/E,EAAAiC,KAAAG,MAAApC,EAAAgF,IAOA,OAHApI,MAAAuF,GAAAP,EAAAkD,IAIAG,OAAA,WACAjF,EAAA+C,IAAAnB,EAAAkD,OAkFAI,MAAAhI,IAAAA,SAAA,SAAA0E,EAAAuD,GAAA,GAAAC,GAAAxI,KAAAyI,EAAArI,SACAJ,MAAAmH,OAAAS,eAAA5C,KAAA,WACA,GAAA5B,GAAAA,EACAqC,EAAAnF,IAAAwB,MAAA2G,EACAhD,GAAA1D,OAAA,EAAA,GAEAyG,EAAArB,OAAAnC,GAAA0D,WAAA,iBACAtF,GAAA+D,OAAAnC,GACA5B,EAAAiC,KAAAG,MAAApC,EAAAqC,IACA8C,UAGAjI,IAAAoE,aD0/BA,IKztCAiE,iBLytCsB,SAAUC,GKxtChC,QAAAD,GAAAE,GAAAlK,gBAAAqB,KAAA2I,EAAA,IAAAG,GAAArL,2BAAAuC,MAAA2I,EAAAjK,WAAAR,OAAA6K,eAAAJ,IAAAhL,KAAAqC,MAGA6I,GAAAA,MACAA,EAAA,gBAAAA,IAAAG,QAAAH,GAAAA,EACAA,EAAAI,OAAAJ,EAAAI,UAEA,IAAA7F,GAAAA,CAEA0F,GAAA5F,KAAA2F,EAAA3F,MAAA,WACA4F,EAAAhD,KAAA+C,EAAA/C,MAAA,YACAgD,EAAAI,SAAAL,EAAAK,UAAA,QACAJ,EAAAE,QAAAH,EAAAG,SAAA,gBACAF,EAAAK,SAAAN,EAAAM,UAAA,cAGAL,EAAA5F,KAAA4F,EAAA5F,KAAAF,QAAA,kBAAA,GAGA,KAAA,GAAArB,KAAAkH,GAAAI,OACAJ,EAAAI,OAAArB,eAAAjG,KACAmH,EAAAnH,GAAAkH,EAAAI,OAAAtH,GAKA,IAFAmH,EAAAlB,eAAA,iBAAAkB,GAAAG,OAEA3I,IAAA6B,UAAAlC,MAAAmJ,kBAAA,CAGAnJ,MAAAmJ,kBAAA,SAAAC,EAAAlG,GAAA,MAAAA,GAEA,IAAAmG,GAAA,GAAArJ,MACAA,OAAAsJ,kBAAAD,EAAAR,GAEAA,EAAAU,SAAAF,EAAAnG,MAEAlD,MAAAmJ,kBAAA,SAAAK,EAAAtG,GAIA,MAHAC,GAAAsG,OAAAlC,QAAAC,KAAArE,EAAAsG,OACAtG,EAAAuG,MAAAnC,QAAAoC,KAAAxG,EAAAuG,MAEAvG,EAAAF,KAAA,KAAAE,EAAA4F,QAAA,KAAA7F,EAAAX,OAAA,SAAAqH,GACA,MAAAA,GAAAC,gBAAAC,YAAAF,EAAAC,gBACAxG,IAAA,SAAAT,GACA,MAAA,UAAAA,IACAmH,KAAA,OAIA/J,MAAAsJ,kBAAAT,GAhDA,MAAAA,GL6zCE,MApGAjL,WAAU8K,EAAiBC,GAiF3B1J,aAAayJ,IACXjJ,IAAK,QACLsB,IAAK,WKruCT,MAAAhB,MAAAwJ,SAAAhH,OAAA,SAAAqH,GACA,MAAAA,GAAAC,gBAAAC,YAAAF,EAAAC,gBACAxG,IAAA,SAAAuG,GACA,OACAI,SAAAJ,EAAAC,cACA/F,KAAA8F,EAAAK,gBACAjG,OAAA4F,EAAAM,kBACAC,aAAAP,EAAAQ,kBACAC,SAAAT,EAAAU,WACAC,KAAAX,EAAAY,SACA3E,KAAA+D,EAAAa,qBL4uCS/B,GK9zCT1I,MAwFAK,KAAA6B,WACAwI,OAAAC,QAAAjC,iBAlCArI,IAAAa,OAAA,kBAAAb,IAAAA,UAAA,SAAAuI,GACAA,EAAAA,MACAA,EAAA,gBAAAA,IAAAG,QAAAH,GAAAA,EACAA,EAAA3F,KAAA2F,EAAA3F,MAAA,WACA2F,EAAA3F,KAAA2F,EAAA3F,KAAAF,QAAA,kBAAA,IAGA1C,IAAA8D,OAAAyE,EAAA3F,MAAA,WAIA,MAHA9C,WAAAb,OAAA,IACAsJ,EAAAG,QAAA5I,UAAA,IAEA,GAAAuI,iBAAAE,OChEAvI,IAAAuK,OAEA3M,OAAAiB,iBAAAmB,IAAAuK,KAOAC,MAAAxK,IAAAA,SAAA,SAAA6E,GACAd,SAAAC,iBAAA,mBAAAa,KAUA4F,QAAAzK,IAAAA,SAAA,SAAAmC,GAEA,GAAA,gBAAAA,GAAA,CACA,GAAAuI,GAAAvI,CAGA,IAFAA,EAAA4B,SAAA4G,iBAAAxI,GAEA,IAAAA,EAAAlD,OAEA,WADAiI,SAAAC,KAAA,QAAAuD,EAAA,0CAIA1K,KAAAwB,MAAAW,GAAAf,QAAA1B,KAAA+K,aAEA,QAAAzK,IAAAA,UAAAmC,IACA,IAAA,QAEA,WADAA,GAAAf,QAAA1B,KAAA+K,QAEA,KAAA,WAEA,WADAzK,KAAAwB,MAAAW,GAAAf,QAAA1B,KAAA+K,QAEA,KAAA,cAEA,WADAtI,GAAAyI,WAAAC,YAAA1I,EAEA,SACA,GAAA,kBAAAwE,KAAA3G,IAAAA,UAAAmC,IAEA,WADAA,GAAAyI,WAAAC,YAAA1I,EAGA+E,SAAAC,KAAA,kEACAD,QAAA4D,IAAA,kBAAA3I,MA2DA4I,WAAA/K,IAAAA,SAAA,SAAA8B,EAAAkJ,EAAAC,GACA,GAAA,gBAAAnJ,GAAA,CAEA,GADAA,EAAAiC,SAAA4G,iBAAA7I,GACA,IAAAA,EAAA7C,OAEA,MADAiI,SAAAC,KAAA,IAAArF,EAAA,sEACA,IAEAA,GAAAA,EAAA,GAGA,GAAAoJ,GAAApJ,EAAA8I,WACA5L,EAAA,CAGA,KAFAiM,EAAA,gBAAAA,GAAAA,KAEA,OAAAC,EAAAN,WAAAO,cAAAH,IAAA,SAAAE,EAAAE,UAAA,CAEA,GADApM,IACAiM,EAAA,GAAAjM,EAAAiM,EACA,MAAA,KAEAC,GAAAA,EAAAN,WAGA,MAAAM,KA0BAG,cAAArL,IAAAA,SAAA,SAAAmC,GACA,MAAAnC,KAAAwB,MAAAW,EAAAyI,WAAAU,UAAAjJ,QAAAF,OCtHAnC,IAAAa,OAAA,MAAAb,IAAAA,SAAA,GAAAA,KAAAoE,eCpCApE,IAAAuL,IAAA,GAAA,YACA,GAAAC,GAAA,SAAA3D,EAAAzB,EAAAX,EAAAgG,EAAAlE,GACA,GAAA3F,SAAA5B,IAAA0L,IACA,MAAAxE,SAAAyE,MAAA,iCAAAF,EAAA,MAEAlE,GAAAvH,IAAA0B,SAAA6F,GAAA,EACA,IAAA5G,GAAA,SAAAV,GACAsH,GAAAtH,EAAAsH,gBACAtH,EAAAsH,iBAEAvH,IAAA0L,IAAA3G,KAAAqB,EAAAnG,GAEAwF,GAAAzB,iBAAA6D,EAAAlH,IAGAiL,EAAA,SAAA7N,EAAAiN,EAAAa,GACA,MAAA,gBAAA9N,GACAgG,SAAA8H,EAAA,gBAAA,qBAAA9N,EAAA,MAAAiN,GAAA3H,QAEAtF,EAAA8N,EAAA,gBAAA,oBAAAb,EAAA3H,QAGAzF,QAAAiB,iBAAAa,MAEAiF,KAAA3E,IAAAM,QAAA,GAAA,GAAA,MAEAwL,MAAA9L,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAvC,EAAAiN,GACA,GAAA,gBAAAjN,GAAA,CACA,GAAAgO,GAAA/L,IAAAuL,IAAAS,MAAAjO,EAAA,MAAAiN,GAAA3H,OACA,IAAA,IAAA0I,EAAA9M,OAAA,CACA,GAAAgN,GAAAjM,IAAAuL,IAAAS,KAAAjO,EAAAsF,QAAA,GAAAuH,WAAAD,iBAAAK,EACA,IAAAiB,EAAAhN,OAAA,EACA,MAAA,KAAAgN,EAAAhN,OACAgN,EAAA,GAEAA,EAGA,MAAAF,GAEA,MAAA/L,KAAAuL,IAAAS,KAAAjO,EAAA4M,iBAAAK,MAaAgB,KAAAhM,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAvC,GACA,GAAAmO,GAAA,gBAAAnO,GACAoO,EAAAD,KAAA,EAAAnI,SAAA4G,iBAAA5M,GAAAA,EACA4H,EAAA,IAEA,IAAA,IAAAwG,EAAAlN,OACAkN,EAAA,GAAA7E,eAAA,YACA1J,OAAAiB,iBAAAsN,EAAA,IACAC,QAAApM,IAAAU,IAAA,WACA,OAAA,IACA,KAIAyL,EAAA,GAAA7E,eAAA,SACA1J,OAAAuB,eAAAgN,EAAA,GAAA,OAAAnM,IAAAA,SAAA,SAAAgL,GACA,MAAAhL,KAAAuL,IAAAO,MAAA/N,EAAAiN,MAIAmB,EAAA,GAAA7E,eAAA,YACA1J,OAAAuB,eAAAgN,EAAA,GAAA,UAAAnM,IAAAA,SAAA,SAAA6H,EAAAzB,GACAoF,EAAA3D,EAAAzB,EAAA1G,KAAA,cAIAyM,EAAA,GAAA7E,eAAA,OACA1J,OAAAuB,eAAAgN,EAAA,GAAA,KAAAnM,IAAAA,SAAA,WACAN,KAAAsE,iBAAAkB,MAAAxF,KAAAI,cAIA6F,EAAAwG,EAAA,OACA,CACA,GAAAE,GAAArM,IAAAwB,MAAA2K,EACA,cAAAnM,IAAAA,UAAAmM,IAAA,IAAAE,EAAApN,SACAoN,EAAAA,EAAA,IAIAzO,OAAAiB,iBAAAwN,GACAlB,cAAAnL,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAA0K,GACAY,EAAA7N,EAAAiN,KAGAL,iBAAA3K,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAA0K,GACAY,EAAA7N,EAAAiN,GAAA,KAGAhH,iBAAAhE,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAgM,EAAA3L,GACA,IAAA,GAAA4B,GAAA,EAAAA,EAAA7C,KAAAT,OAAAsD,IACA7C,KAAA6C,GAAAyB,iBAAAsI,EAAA3L,KAIA4L,oBAAAvM,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAgM,EAAA3L,GACA,IAAA,GAAA4B,GAAA,EAAAA,EAAA7C,KAAAT,OAAAsD,IACA7C,KAAA6C,GAAAgK,oBAAAD,EAAA3L,KAIAqL,KAAAhM,IAAAA,SAAA,SAAAgL,GACA,MAAAhL,KAAAuL,IAAAO,MAAA/N,EAAAiN,KAGAoB,QAAApM,IAAAU,IAAA,WACA,OAAA,IACA,GAEA8L,QAAAxM,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAuH,EAAAzB,GACAoF,EAAA3D,EAAAzB,EAAA1G,KAAA,eAGAiG,EAAA0G,EAGA,MAAA1G,KAYA9H,OAAAmC,IAAAA,SAAA,SAAAZ,EAAArB,GAGA,IAAAA,GAAA,gBAAAqB,GACA,MAAAM,MAAAsM,KAAA5M,EAIA,IAAA,gBAAAA,IAAA,gBAAAA,GACA,KAAA,IAAAO,OAAA,oDAEA,IAAA,IAAAP,EAAAiE,OAAApE,OACA,KAAA,IAAAU,OAAA,yCAEA,IAAAiC,SAAA7D,GAAA,OAAAA,GAAA,IAAAA,EAAAsF,OAAApE,OACA,KAAA,IAAAU,OAAA,qDAIA,IAAA8M,GAAA/M,KAAAgN,SAAAtN,GACA0D,EAAApD,IACA9B,QAAAuB,eAAAa,IAAAuL,IAAAkB,EAAAzM,IAAAA,WAAAjC,IAEAH,OAAAuB,eAAAa,IAAAuL,IAAAnM,GACApB,YAAA,EACA0C,IAAA,WACA,MAAAoC,GAAAkJ,KAAAjO,IAEA6C,IAAA,SAAA+L,GACA,GAAA/K,SAAA+K,GAAA,OAAAA,GAAA,IAAAA,EAAAtJ,OAAApE,OACA,KAAA,IAAAU,OAAA,qDAEAK,KAAAuL,IAAAkB,GAAAE,KAIAjN,KAAAiF,KAAAvF,GAAArB,EACA2B,KAAAiF,KAAAjF,KAAAgN,SAAAtN,IAAArB,IAOAgK,OAAA/H,IAAAA,SAAA,SAAAZ,GACAM,KAAAN,WACAM,MAAAN,SACAM,MAAAiF,KAAAvF,GAEA,IAAAwN,GAAAlN,KAAAgN,SAAAtN,EACAM,MAAAkN,WACAlN,MAAAkN,SACAlN,MAAAiF,KAAAiI,MAWAF,SAAA1M,IAAAM,QAAA,GAAA,GAAA,EAAA,SAAAlB,GACA,MAAAA,GAAAsD,QAAA,6BAAA,IAAAtD,EAAAH,SASA4N,MACA7O,YAAA,EACA0C,IAAA,WACA,GAAAoC,GAAApD,KACAf,IAOA,OALAf,QAAA+G,KAAAjF,MAAA0B,QAAA,SAAAmB,GACAO,EAAAwE,eAAA/E,KAAA,OAAA,OAAA,UAAAF,QAAAE,EAAAc,OAAAV,eAAA,GAAA,kBAAAG,GAAAP,KACA5D,EAAA4D,GAAAO,EAAA6B,KAAApC,MAGA5D,MCjOA,IAAAmO,QAAA,GAAAC,WACAC,GAAAhN,IAAA6B,SAAAE,QAAA,MAAA,KAEAkL,QT+0Dc,WS90Dd,QAAAA,KAAA5O,gBAAAqB,KAAAuN,GACArP,OAAAiB,iBAAAa,MAQAwN,IAAAlN,IAAAS,aAAA,SAAAoE,GACA,GAAAsI,GAAAA,MAeA,OAbApN,QAAAqN,iBAEAD,EAAA,GAAAC,iBAGAD,EAAAE,mBAAA,WACA,IAAAF,EAAAG,YACAzI,GACAA,EAAAsI,IAKAA,IAcAI,IAAAvN,IAAAS,aAAA,SAAA+M,EAAAC,EAAA5I,GACA,GAAAsI,GAAAnN,IAAA0N,IAAAR,IAAArI,EACAsI,GAAAQ,KAAAH,EAAAC,GAAA,GACAN,EAAAS,SAwCAC,qBAAA7N,IAAAS,aAAA,SAAAyM,EAAA7I,GACA,IAAA6I,IAAA7I,EACA,KAAA,IAAA1E,OAAA,0CAIA,IAAA0E,EAAAyJ,OAAA,CACA,GAAAC,GAAAnQ,OAAA+G,KAAAN,EAAAyJ,QAAA9K,IAAA,SAAAgL,GACA,MAAAA,GAAA,IAAAC,mBAAA5J,EAAAyJ,OAAAE,KAEA3J,GAAAoJ,KAAA,IAAAM,EAAArE,KAAA,KAGAwD,EAAAS,KAAAtJ,EAAAmJ,QAAA,OAAAnJ,EAAAoJ,KAAA,GAGApJ,EAAA6J,OAAA7J,EAAA6J,QAAA7J,EAAA8J,YACAvQ,OAAA+G,KAAAN,EAAA6J,QAAA9M,QAAA,SAAA8M,GACAhB,EAAAkB,iBAAAF,EAAA7J,EAAA6J,OAAAA,KAIA,IAAAjK,GAAA,IAgCA,OA/BAI,GAAAwI,QACAxI,EAAA6J,QAAA7J,EAAA6J,SAAA7J,EAAA6J,OAAA,kBACAhB,EAAAkB,iBAAA,eAAA,oBAEAnK,EAAAoK,KAAAC,UAAAjK,EAAAwI,MAAAxJ,QACAgB,EAAAJ,QACAI,EAAA6J,QAAA7J,EAAA6J,SAAA7J,EAAA6J,OAAA,kBACAhB,EAAAkB,iBAAA,eAAA,oBAEAnK,EAAAI,EAAAJ,MACAI,EAAAkK,OACAtK,EAAA,GAAAuK,UACA5Q,OAAA+G,KAAAN,EAAAkK,MAAAnN,QAAA,SAAAmB,GACA0B,EAAAwK,OAAAlM,EAAA8B,EAAAkK,KAAAhM,OAKA8B,EAAAqK,kBACAxB,EAAAwB,gBAAArK,EAAAqK,iBAIArK,EAAAsK,UAAAtK,EAAAuK,SAEA1B,EAAAkB,iBAAA,gBAAA,SAAAS,KAAAxK,EAAAsK,SAAA,IAAAtK,EAAAuK,WACAvK,EAAAyK,aAEA5B,EAAAkB,iBAAA,gBAAA,UAAA/J,EAAAyK,aAGA7K,IAWAa,QAAA9E,IAAAS,aAAA,SAAA0E,EAAA5C,GAGA,MAFA4C,GAAAnF,IAAAwB,MAAA2D,GACAA,EAAAqC,QAAAjF,GACA4C,IAaA4J,QAAA/O,IAAAS,aAAA,SAAAgN,GACA,GAAA,OAAAT,GAAA,CACA,GAAAgC,IACAC,OAAAjC,GAAAkC,WAAAzB,EAAA/K,QAAA,UAAA,KAAA,IAAA,IAGA,OADAsM,GAAAG,aAAA,MAAAH,EAAAC,OAAAjC,GAAAoC,aAAA3B,EAAA/K,QAAA,UAAA,KAAAF,WAAA,2BACAwM,EAEA,KAAA,IAAArP,OAAA8N,EAAA,4CASA4B,aAAArP,IAAAS,aAAA,SAAAgN,GACA,GAAA6B,KAUA,OARA7B,GAAAhL,MAAA,KAAArB,QAAA,SAAAmB,GACA,OAAAA,EACA+M,EAAAhJ,MACA,MAAA/D,GACA+M,EAAAlK,KAAA7C,KAIA+M,EAAA5F,KAAA,KAAAhH,QAAA,eAAA,SAmBA6M,cAAAvP,IAAAS,aAAA,SAAAgN,EAAA3O,EAAA+F,EAAA2K,GACAA,EAAA5N,SAAA4N,GAAAA,EACA9P,KAAAA,UAAA+N,EAAA,SAAAtL,GACA,GAAA,gBAAAA,GACAA,EAAA4B,SAAA0L,eAAAtN,OACA,IAAAA,EAAAlD,OAAA,CAAA,GAAAyQ,GAAA,WACA,GAAAC,KAUA,OATA3P,KAAAwB,MAAAW,GAAAf,QAAA,SAAAmB,GACAiN,GACAG,EAAAvK,KAAAtG,EAAA8L,WAAAgF,aAAArN,EAAAzD,IACAA,EAAAyD,GAEAoN,EAAAvK,KAAAtG,EAAA+Q,YAAAtN,MAGAsC,GAAAA,EAAA8K,IACAvP,EAAA,UAXA,IAAA,YAAA,mBAAAsP,GAAA,YAAAlR,QAAAkR,IAAA,MAAAA,GAAAtP,EAaAoP,EACA1Q,EAAA8L,WAAAgF,aAAAzN,EAAArD,GAEAA,EAAA+Q,YAAA1N,GAEA0C,GAAAA,EAAA1C,OAWA2N,WAAA9P,IAAAS,aAAA,SAAAgN,GACA,GAAAsC,GAAAtC,EAAAuC,OAAA,sBAAAvC,EAAAwC,MAAA,uCAAA,IAAAxC,EAAAwC,MAAA,2BAAA,GACA,OAAA,QAAAF,GAAAA,EAAA,GAAA9Q,OAAA,EAAAc,OAAAkD,SAAAiN,KAAAH,EAAA,KAWAI,cAAAnQ,IAAAS,aAAA,SAAAgN,GACA,MAAA/N,MAAAoQ,WAAArC,KAAA1N,OAAAkD,SAAAiN,OAiBAE,QAAApQ,IAAAS,aAAA,SAAAgN,EAAA4C,EAAAC,GACA,IAAAvM,SAAAwM,KAEA,WADArJ,SAAAC,KAAA,sFAIA,IAAAqJ,GAAAzM,SAAA0M,cAAA,OACAD,GAAAH,IAAAA,EACAG,EAAAE,KAAA,SAAAjD,EAAApK,OAAAV,cAAAY,OAAA,EAAA,GAAA7D,KAAA2P,aAAAtP,OAAAkD,SAAAC,OAAAnD,OAAAkD,SAAA0N,SAAAlD,GAAAA,EAEAzN,IAAA0B,SAAA4O,EAAA5Q,KAAAyQ,cAAA1C,KAAA+C,EAAAI,aAAA,cAAA,QACA7M,SAAAwM,KAAAV,YAAAW,GACAxQ,IAAA0L,IAAA3G,KAAA,WAAAsL,KAGAQ,YAAA7Q,IAAAA,eAEAyQ,cAAAzQ,IAAAS,aAAA,SAAAiK,GACA,MAAAoC,QAAAgE,gBAAApG,EAAA,aAAAS,cAAA,QAAAG,WAGAyF,UAAA/Q,IAAAS,aAAA,SAAAuQ,EAAAC,EAAApM,GACA,GAAAjD,SAAAoP,EAGA,MAFA9J,SAAAC,KAAA,wBACAtC,GAAAA,IAKAjH,QAAA+G,KAAAsM,GAAA7P,QAAA,SAAAhC,GACA,GAAA8R,GAAA,GAAAxK,QAAA,KAAAtH,EAAA,KAAA,KACA4R,GAAAA,EAAAtO,QAAAwO,EAAAD,EAAA7R,MAIA4R,EAAAA,EAAAtO,QAAA,iBAAA,GAEA,IAAAH,GAAA7C,KAAA+Q,cAAAO,EACAnM,IAAAA,EAAAtC,EAAA,QTs2EE,MA9fA3D,cAAaqO,IACX7N,IAAK,OACLrB,MAAO,SS31DXsG,EAAAQ,GACAR,EAAAA,KACA,IAAA8I,GAAAzN,KAAAwN,IAAArI,GACAZ,EAAAvE,KAAAmO,qBAAAV,EAAA9I,EACA8I,GAAAS,KAAA3J,MTy2DI7E,IAAK,MACLrB,MAAO,WS71DX,GAAA,WAAAS,QAAAsB,UAAA,IAAA,CACA,GAAAuE,GAAAvE,UAAA,EAGA,OAFAuE,GAAAmJ,OAAA,MACAnJ,EAAAoJ,IAAA,gBAAA3N,WAAA,GAAAA,UAAA,GAAAuE,EAAAoJ,IACApJ,EAAAoJ,IAAAlK,OAAA,EAAA,IAAAvD,IAAA6B,SACA/B,UAAAA,UAAAb,OAAA,GAAAS,KAAAqP,QAAA1K,EAAAoJ,MAEA/N,KAAAkO,KAAAvJ,EAAAvE,UAAAA,UAAAb,OAAA,IAEA,MAAA,SAAAa,UAAA,GAAAyD,OAAA,EAAA,IAAAvD,IAAA6B,SACA/B,UAAAA,UAAAb,OAAA,GAAAS,KAAAqP,QAAAjP,UAAA,SAEAJ,MAAA6N,IAAArI,MAAAxF,KAAA6N,IAAA7N,KAAAoF,QAAAhF,UAAA,WT42DIV,IAAK,OACLrB,MAAO,SSj2DXuR,EAAAzK,GACA,GAAA,WAAArG,QAAAsB,UAAA,IAAA,CACA,GAAAuE,GAAAvE,UAAA,EAGA,OAFAuE,GAAAmJ,OAAA,OACAnJ,EAAAoJ,IAAA,gBAAA3N,WAAA,GAAAA,UAAA,GAAAuE,EAAAoJ,IACA/N,KAAAkO,KAAAvJ,EAAAvE,UAAAA,UAAAb,OAAA,IAEAS,KAAA6N,IAAArI,MAAAxF,KAAA6N,IAAA7N,KAAAoF,QAAAhF,UAAA,YT+2DIV,IAAK,MACLrB,MAAO,SSp2DXsG,EAAAQ,GACAR,EAAAA,MACAA,EAAAmJ,OAAA,MACAnJ,EAAAoJ,IAAApJ,EAAAoJ,KAAA1N,OAAAkD,SACAvD,KAAAkO,KAAAvJ,EAAAQ,MTk3DIzF,IAAK,OACLrB,MAAO,SSv2DXsG,EAAAQ,GACAR,EAAAA,MACAA,EAAAmJ,OAAA,OACAnJ,EAAAoJ,IAAApJ,EAAAoJ,KAAA1N,OAAAkD,SACAvD,KAAAkO,KAAAvJ,EAAAQ,MTq3DIzF,IAAK,SACLrB,MAAO,WSz2DX2B,KAAA6N,IAAArI,MAAAxF,KAAA6N,IAAA7N,KAAAoF,QAAAhF,UAAA,cTw3DIV,IAAK,OACLrB,MAAO,SS72DXsG,EAAAoJ,EAAA5I,GACA,gBAAAR,KACAQ,EAAA4I,EACAA,EAAApJ,EACAA,EAAA,MAEA,OAAAA,EACA3E,KAAA6N,IAAA,MAAAE,EAAA,SAAAN,GACA,GAAA,MAAAA,EAAA8B,OACA,KAAAtP,OAAA,qCAAA8N,EAAA,kBAAAN,EAAA8B,OAAA,KAEA,KACA9B,EAAAN,KAAAwB,KAAA8C,MAAAhE,EAAAgC,cACA,MAAAlP,GACAkN,EAAAN,KAAA,KAEAhI,GAAAA,EAAAsI,EAAAN,SAGAxI,EAAAoJ,IAAAA,EACA/N,KAAAgB,IAAA2D,EAAA,SAAA8I,GACA,GAAA,MAAAA,EAAA8B,OACA,KAAAtP,OAAA,qCAAA8N,EAAA,kBAAAN,EAAA8B,OAAA,KAEA,KACA9B,EAAAN,KAAAwB,KAAA8C,MAAAhE,EAAAgC,cACA,MAAAlP,GACAkN,EAAAN,KAAA,KAEAhI,GAAAA,EAAAsI,EAAAN,YT45DIzN,IAAK,SACLrB,MAAO,SSh3DX0P,EAAA5I,EAAAuM,GAAA,GAAAC,GAAA3R,IAEA,IAAAH,MAAA6M,QAAAqB,GAAA,CAAA,GAAA6D,GAAA,WACA,GAAAlU,GAAAA,EACAuS,EAAA,GAAApQ,OAAAkO,EAAAxO,QACAD,EAAA,CAeA,OAdAyO,GAAArM,QAAA,SAAAkO,EAAAiC,GACAnU,EAAAA,UAAAkS,EAAA,SAAA/M,GACAoN,EAAA4B,GAAAhP,EACAvD,KACAoS,KAEAvM,IAAA,WACA,GAAA2M,GAAAC,YAAA,WACAzS,IAAAyO,EAAAxO,SACAyS,cAAAF,GACA3M,EAAA8K,KAEA,OAEAvP,EAAA,UAlBA,IAAA,YAAA,mBAAAkR,GAAA,YAAA9S,QAAA8S,IAAA,MAAAA,GAAAlR,EAsBA,GAAAuR,GAAA,IACA,MAAA,WACAA,EAAAlE,EAAAhL,MAAA,KAAA6D,MAAA7D,MAAA,KAAA,GAAAA,MAAA,KAAA6D,MAAA3D,aACA,IAAAiP,GAAAA,MACA,QAAAD,GACAC,EAAA7N,SAAA0M,cAAA,UACAmB,EAAAhB,aAAA,OAAA,mBACAgB,EAAAhB,aAAA,MAAAnD,IACA,QAAAkE,IACAC,EAAA7N,SAAA0M,cAAA,QACAmB,EAAAhB,aAAA,MAAA,cACAgB,EAAAhB,aAAA,OAAA,YACAgB,EAAAhB,aAAA,OAAAnD,IAEAmE,EAAAC,OAAA,kBAAAhN,GAAA,WAAAA,EAAA+M,IAAA,aACA7N,SAAA+N,qBAAA,QAAA,GAAAjC,YAAA+B,MACA,MAAA3R,IAEA,MAAA,KAAA,OAAAoC,SAAAsP,GAAA,IAAAtO,OAAAV,gBAAA,GAAA,CAOA,GAHAyO,EAAA,iBAAAA,IAAAA,EAGA,SAAA3D,EAAAlK,OAAA,EAAA,GAAA,CACA,GAAAD,GAAAvD,OAAAkD,SAAAyN,KAAAjO,MAAA,IACAa,GAAAgD,MACAmH,EAAAnK,EAAAoG,KAAA,KAAA,IAAA+D,EAIA,IAAA2D,GAAA1R,KAAAmR,YAAAvJ,eAAAmG,GAAA,CACA,GAAAsE,GAAArS,KAAA+Q,cAAA/Q,KAAAmR,YAAApD,GAMA,OALA5I,IAAAA,EAAA,IAAAkN,EAAA9S,OAAA8S,EAAA,GAAAA,QACAhS,OAAAC,IAAA0L,KACA3L,OAAAC,IAAA0L,IAAA3G,KAAA,cAAA,IAAAgN,EAAA9S,OAAA8S,EAAA,GAAAA,IAOA,GAAAjP,GAAApD,IACAA,MAAAgB,IAAA+M,EAAA,SAAAN,GACA,GAAA,MAAAA,EAAA8B,OACA,MAAA/H,SAAAC,KAAA,iEAAAsG,EAAA,wBAAAN,EAAA8B,OAAA,IAGA,IAAA8C,GAAAjP,EAAA2N,cAAAtD,EAAAgC,aAGA,IAFArM,EAAA+N,YAAApD,GAAAN,EAAAgC,aAEA,IAAA4C,EAAA9S,OACAiI,QAAAC,KAAArE,EAAAuM,aAAA5B,GAAA,6BACA5I,GAAAA,EAAAsI,EAAAgC,cACApP,OAAAC,IAAA0L,KACA3L,OAAAC,IAAA0L,IAAA3G,KAAA,cAAAoI,EAAAgC,kBAEA,CACA,GAAA5M,GAAA,IAAAwP,EAAA9S,OAAA8S,EAAA,GAAAA,CACAlN,IAAAA,EAAAtC,GACAxC,OAAAC,IAAA0L,KACA3L,OAAAC,IAAA0L,IAAA3G,KAAA,cAAAxC,UTq5DInD,IAAK,WACLrB,MAAO,SSj4DX0P,EAAA3O,EAAA+F,GACAnF,KAAA6P,cAAA9B,EAAA3O,EAAA+F,MTq5DIzF,IAAK,eACLrB,MAAO,SSp4DX0P,EAAA3O,EAAA+F,GACAnF,KAAA6P,cAAA9B,EAAA3O,EAAA+F,GAAA,MTs5DIzF,IAAK,SACLrB,MAAO,SSv4DXiU,EAAA1B,GACA5Q,KAAA0Q,QAAArQ,OAAAkD,SAAAgP,SAAA,KAAAD,EAAA,eAAA1B,MT45DIlR,IAAK,aACLrB,MAAO,SS14DX0P,EAAA6C,GACA5Q,KAAA0Q,QAAA3C,EAAA,aAAA6C,MT25DIlR,IAAK,WACLrB,MAAO,SS74DX0P,EAAA6C,GACA5Q,KAAA0Q,QAAA3C,EAAA,WAAA6C,MTg6DIlR,IAAK,cACLrB,MAAO,SSh5DX0P,EAAA6C,GACA5Q,KAAA0Q,QAAA3C,EAAA,cAAA6C,MTs6DIlR,IAAK,YACLrB,MAAO,SSn5DX0P,EAAA6C,GACA5Q,KAAA0Q,QAAA3C,EAAA,YAAA6C,MTq6DIlR,IAAK,WACLrB,MAAO,SSt5DX0P,EAAAwD,EAAApM,GACA4I,EAAA/N,KAAA2P,aAAA5B,GAEA,kBAAAwD,KACApM,EAAAoM,EACAA,MAGAA,EAAAA,KAEA,IAAAnO,GAAApD,KACAsR,EAAAA,MAGA,OAAAtR,MAAAmR,YAAAvJ,eAAAmG,IACAuD,EAAAtR,KAAAmR,YAAApD,GACA/N,KAAAqR,UAAAC,EAAAC,EAAApM,QAGAnF,MAAAgB,IAAA+M,EAAA,SAAAN,GACA,GAAAwE,GAAA,IACA,KACAA,EAAAlE,EAAAhL,MAAA,KAAA6D,MAAA7D,MAAA,KAAA,GAAAA,MAAA,KAAA6D,MAAA3D,cACA,MAAA1C,IACA,OAAA,KAAA,OAAAoC,SAAAsP,GAAA,IAAAtO,OAAAV,gBAAA,MACAuE,SAAAC,KAAA,iBAAAwK,EAAA,4DAIA7O,EAAA+N,YAAApD,GAAAN,EAAAgC,iBACArM,GAAAiO,UAAA5D,EAAAgC,aAAA8B,EAAApM,UT25DSoI,ISt5DTjN,KAAA0N,IAAA,GAAAT,QC/vBA,IAAAiF,MAAA,WACA,GAAAC,GAAApO,SAAA0M,cAAA,SACA/F,EAAA3G,SAAA0L,eAAA,gFACA0C,GAAAtC,YAAAnF,GACA3G,SAAAwM,KAAAV,YAAAsC,GAEAD,QAGAlS,IAAAuK,IAAAvK,IAAAuK,QACAvK,IAAAuK,IAAA6H,OAEAxU,OAAAiB,iBAAAmB,IAAAuK,IAAA6H,KAKAC,OAAArS,IAAAA,eAWAsS,KAAAtS,IAAAS,aAAA,SAAA8R,EAAA1N,GAEA,IAAA,GADA/B,GAAApD,KACAV,EAAA,EAAAA,EAAAuT,EAAAtT,OAAAD,IAAA,CACA,GAAAqC,GAAAkR,EAAAvT,GAAAwT,WACAC,EAAA3P,EAAAuP,OAAAE,EAAAvT,GAAA0T,aAAA,QACAC,IAEA,KACAA,EAAA,gCAAAC,KAAAH,GAAA,GAAApP,MACA,IAAAwP,GAAA,YAAAD,KAAAD,EACAE,GAAA,OAAAA,EAAAA,EAAA,GAAA,KACAF,EAAAA,EAAAjQ,QAAA,GAAAgE,QAAAmM,EAAA,MAAAA,EAAAnQ,QAAA,OAAA,MAAAD,MAAA,KACA,MAAAxC,GACAiH,QAAAyE,MAAA1L,GAGA0S,EAAApT,MAAA6M,QAAAuG,GAAAA,GAAAA,EAMA,KAAA,GAJA3P,GAAA2P,EAAA3P,IAAA,SAAAmJ,GACA,MAAAA,GAAA1J,MAAA,KAAA,GAAAY,OAAAV,gBAGAmQ,EAAA,EAAAA,EAAAzR,EAAApC,OAAA6T,IAAA,CACA,GAAAC,GAAA/P,EAAAX,QAAAhB,EAAAyR,GAAAlQ,KAAAD,cACAoQ,GAAA,EACAJ,EAAAvN,KAAA/D,EAAAyR,GAAAlQ,KAAA,KAAAvB,EAAAyR,GAAA/U,MAAA,KAEA4U,EAAAI,GAAA1R,EAAAyR,GAAAlQ,KAAA,KAAAvB,EAAAyR,GAAA/U,MAAA,IAIA4U,EAAAA,EAAAzQ,OAAA,SAAA8Q,GACA,MAAA,QAAAA,EAAAvQ,MAAA,KAAA,GAAAE,eAGA,IAAAyP,GAAA,QAAAO,EAAAjJ,KAAA,KAAA,GAEA6I,GAAAvT,GAAAiU,UAAAR,EAAA/P,QAAA,YAAA0P,GAGAvN,GAAAA,MAUAqO,GAAAlT,IAAAS,aAAA,SAAAgN,GACA,MAAAA,GAAA/K,QAAA,8BAAA,MAWAyQ,UAAAnT,IAAAS,aAAA,SAAA2S,GACA,IACA,MAAAA,GAAA5Q,WAAAa,OAAAX,QAAA,iBAAA,IAAAA,QAAA,OAAA,KAAAuN,MAAA,sBAAA,IAAA,GACA,MAAAhQ,GACA,MAAA,MAYAoT,QAAArT,IAAAS,aAAA,SAAA2S,GACA,MAAA,+BAAAR,KAAAQ,EAAA5Q,WAAAa,QAAA,IAAA,gBAGAiQ,MAAAtT,IAAAA,WAAA,SAAAyN,EAAA2E,GACA1S,KAAA2S,OAAA5E,GAAA2E,IAGAmB,UAAAvT,IAAAA,WAAA,SAAAyN,EAAA5I,GAAA,GAAA2O,GAAA9T,IACA,IAAAmF,EAIA,GAAA7E,IAAA6B,UAAA,IAAA4L,EAAApL,QAAA,QAKA,CACA,GAAAoR,GAAA,EAEA,KACAA,EAAA1R,QAAA,MAAAqN,aAAArN,QAAA,QAAA2R,QAAAjG,GAAA/K,QAAA,UAAA,KAAAF,WACA,MAAAvC,GACA,IACAwT,EAAA1R,QAAA,MAAAqN,aAAArN,QAAA,QAAA2R,QAAAC,UAAAlG,GAAA/K,QAAA,UAAA,KAAAF,WACA,MAAAoR,KAGA/O,EAAA4O,QAhBA,WACA,GAAA3Q,GAAAA,CACA9C,KAAA0N,IAAAhN,IAAA+M,EAAA,SAAAN,GACAtI,GAAAA,EAAA,MAAAsI,EAAA8B,OAAA,GAAAtP,OAAAwN,EAAAgC,cAAArM,EAAAqQ,UAAAhG,EAAAgC,sBAyBA0E,OAAA7T,IAAAA,SAAA,SAAA8T,EAAAjP,GAQA,GAPA,kBAAAiP,IACAjP,EAAAiP,EACAA,EAAA/P,SAAAE,MAEA6P,EAAAA,GAAA/P,SAAAE,KAGA,UAAA6P,EAAA1I,SAAA,CAIA,GAAAtI,GAAApD,IACAoU,GAAAA,EAAAxM,eAAA,aAAA,EACAtH,IAAA+T,QAAAD,IACAA,GAEAA,EAAA1S,QAAA,SAAA4S,GAIA,IAAA,GAHAC,GAAAD,EAAArJ,iBAAA,YAGA3L,EAAA,EAAAA,EAAAiV,EAAAhV,OAAAD,IACA8D,EAAAuP,OAAA4B,EAAAjV,GAAA0T,aAAA,QAAA5P,EAAAuP,OAAA4B,EAAAjV,GAAA0T,aAAA,SAAA,IAIA,IAAAwB,GAAAtW,OAAA+G,KAAA7B,EAAAuP,QAAAnQ,OAAA,SAAAuL,GACA,MAAA,QAAA3K,EAAAuP,OAAA5E,KAGA0G,EAAAD,EAAAjV,MACAiV,GAAA9S,QAAA,SAAAqM,GACA3K,EAAAyQ,UAAA9F,EAAA,SAAAgG,GACAA,YAAA9T,QACAmD,EAAAwQ,MAAA7F,EAAAgG,GAEAU,OAKA,IAAAC,GAAA3C,YAAA,WACA,IAAA0C,IACAzC,cAAA0C,GACAtR,EAAAwP,KAAA2B,EAAApP,KAEA,UCpNA7E,IAAAqU,KAAArU,IAAAqU,SACArU,IAAAqU,KAAAC,QAEA1W,OAAAiB,iBAAAmB,IAAAqU,KAAAC,MAEAC,SAAAvU,IAAAA,WAAA,MASAwU,aAAAxU,IAAAS,aAAA,WAGA,IAAA,GAFAN,GAAAA,OACAoU,KACAE,EAAA,EAAAA,EAAA,IAAAA,IAAA,CACAtU,EAAAsU,CACA,KAAA,GAAAC,GAAA,EAAAA,EAAA,EAAAA,IACAvU,EAAA,EAAAA,EAAA,WAAAA,IAAA,EAAAA,IAAA,CAEAoU,GAAAE,GAAAtU,EAEA,MAAAoU,KAWAI,SAAA3U,IAAAA,SAAA,SAAA0K,GAIA,IAAA,GAHA6J,GAAA7U,KAAA6U,WAAA7U,KAAA6U,SAAA7U,KAAA8U,gBACAI,KAEA5V,EAAA,EAAAA,EAAA0L,EAAAzL,OAAAD,IACA4V,EAAAA,IAAA,EAAAL,EAAA,KAAAK,EAAAlK,EAAAmK,WAAA7V,IAGA,QAAA4V,QAAA,IAeAE,KAAA9U,IAAAA,SAAA,WAEA,IAAA,GADA+U,MACA/V,EAAA,EAAAA,EAAA,IAAAA,IACA+V,EAAA/V,IAAAA,EAAA,GAAA,IAAA,IAAAA,EAAAwD,SAAA,GAGA,IAAAwS,GAAA,WAAAC,KAAAC,SAAA,EACAC,EAAA,WAAAF,KAAAC,SAAA,EACAE,EAAA,WAAAH,KAAAC,SAAA,EACAG,EAAA,WAAAJ,KAAAC,SAAA,CAEA,OAAAH,GAAA,IAAAC,GAAAD,EAAAC,GAAA,EAAA,KAAAD,EAAAC,GAAA,GAAA,KAAAD,EAAAC,GAAA,GAAA,KACA,IAAAD,EAAA,IAAAI,GAAAJ,EAAAI,GAAA,EAAA,KAAA,IAAAJ,EAAAI,GAAA,GAAA,GAAA,IACAJ,EAAAI,GAAA,GAAA,KAAA,IAAAJ,EAAA,GAAAK,EAAA,KAAAL,EAAAK,GAAA,EAAA,KAAA,IACAL,EAAAK,GAAA,GAAA,KAAAL,EAAAK,GAAA,GAAA,KAAAL,EAAA,IAAAM,GAAAN,EAAAM,GAAA,EAAA,KACAN,EAAAM,GAAA,GAAA,KAAAN,EAAAM,GAAA,GAAA,QX65FA,IYx9FAC,OZw9FY,SAAUC,mBYv9FtB,QAAAD,OAAA/M,GAAAlK,gBAAAqB,KAAA4V,OACA/M,EAAAA,KADA,IAAAiN,GAAArY,2BAAAuC,MAAA4V,MAAAlX,WAAAR,OAAA6K,eAAA6M,QAAAjY,KAAAqC,OAKAoD,EAAAA,CAEAlF,QAAAiB,iBAAA2W,GAOAC,YAAAzV,IAAAS,aAAA8H,EAAAkN,aAAA,MAqBAC,OAAA1V,IAAAA,WAAAuI,EAAAmN,SAEAxC,IACAyC,UAAA,EACAnQ,KAAAoQ,OACAC,UAAAtN,EAAA2K,IAAA,QAoCA4C,MAAA9V,IAAAA,WAAAuI,EAAAwN,mBA0BAC,SAAAhW,IAAAA,WAAAuI,EAAAyN,cAOAC,WAAAjW,IAAAA,eAMAkW,WAAAlW,IAAAA,UAAAA,IAAA0B,SAAA6G,EAAA2N,YAAA,IAQAC,MAAAnW,IAAAA,YAAA,GAQAoW,kBAAApW,IAAAA,YAAA,GAQAqW,IAAArW,IAAAA,WAAAuI,EAAAiN,EAAAC,cAAA,MAYAa,OAAAtW,IAAAA,UAAAA,IAAA0B,SAAA6G,EAAA+N,QAAA,IAEAC,UAAAvW,IAAAA,WAAA,MAeAwW,WAAAxW,IAAAA,WAAA,MAGAyW,kBAAAzW,IAAAA,WAAA,MAGA0W,WAAA1W,IAAAA,YAAA,GAGA2W,UAAA3W,IAAAA,YAAA,GAQA4W,WAAA5W,IAAAS,aAAAoW,KAAAC,OAWAC,cAAA/W,IAAAS,aAAA,WACAf,KAAA6W,UAAA7W,KAAAiV,SACAjV,KAAAsX,eAQAC,iBAAAjX,IAAAA,WAAAA,IAAA0B,SAAA6G,EAAA0O,kBAAA,IAMAC,sBAAAlX,IAAAA,WAAAA,IAAA0B,SAAA6G,EAAA2O,uBAAA,IAEAC,sBAAAnX,IAAAA,eAEAoX,sBAAApX,IAAAA,eASAgX,UAAAhX,IAAAA,eAEAqX,kBAAArX,IAAAS,cACA6W,IAAA,SAAAC,EAAAxZ,GACA,MAAA,UAAAiC,IAAAA,UAAAjC,GACAA,EAAAkB,QAAAsY,EAGA,WAAAvX,IAAAA,UAAAjC,GACAA,GAAAwZ,EAGA,WAAAvX,IAAAA,UAAAjC,GACAA,EAAAsF,OAAApE,QAAAsY,EAGA,SAAAvX,IAAAA,UAAAjC,IACAA,EAAAoT,SAAAoG,EAAApG,SAMAqG,IAAA,SAAAC,EAAA1Z,GACA,MAAA,UAAAiC,IAAAA,UAAAjC,GACAA,EAAAkB,QAAAwY,EAGA,WAAAzX,IAAAA,UAAAjC,GACAA,GAAA0Z,EAGA,WAAAzX,IAAAA,UAAAjC,GACAA,EAAAsF,OAAApE,QAAAwY,EAGA,SAAAzX,IAAAA,UAAAjC,IACAA,EAAAoT,SAAAsG,EAAAtG,SAMAuG,OAAA,SAAAC,EAAA5Z,GACA,MAAA4Z,GAAAtV,QAAAtE,IAAA,GAGA4X,SAAA,SAAAiC,EAAA7Z,GACA,MAAA+E,GAAAwE,eAAAsQ,IAAA,OAAA9U,EAAA/E,MAuBA8Z,SAAA7X,IAAAA,WAAAuI,EAAAuP,SAAA,MACAC,gBAAA/X,IAAAA,UAAA,MAOAgY,IAAAhY,IAAAA,eAOAiY,SAAAjY,IAAAA,eAEAkY,OAAAlY,IAAAA,WAAA,OAIA,IAAAmY,GAAA3C,EAAA4C,WAAAxT,OAAA4Q,EAAA6C,mBAAAzT,OAAA4Q,EAAAO,eAAA7T,OAAA,SAAA9C,EAAAJ,EAAAgU,GACA,MAAAA,GAAA3Q,QAAAjD,KAAAJ,GAGA,IAAAmZ,EAAAlZ,OAAA,EACA,KAAA,IAAAU,OAAA,gCAAAwY,EAAAzO,KAAA,MAAA,uFAIA8L,GAAAE,OAAApO,eAAA,QACAiB,EAAAmN,OAAAxC,IACAyC,UAAA,EACAnQ,KAAAoQ,OACAC,UAAAtN,EAAA2K,IAAA,OAKAtV,OAAA+G,KAAA6Q,EAAAE,QAAAtU,QAAA,SAAAwW,GACA,WAAApZ,QAAAsE,EAAA4S,OAAAkC,KAAA,OAAA9U,EAAA4S,OAAAkC,KACA9U,EAAA4S,OAAAkC,IACAjC,UAAA,EACAnQ,KAAA1C,EAAA4S,OAAAkC,GACA/B,UAAA,KACAjT,KAAAgV,IAGA9U,EAAAwV,SAAAV,GAAA,KAIAha,OAAA+G,KAAA6Q,EAAAQ,UAAA5U,QAAA,SAAAhB,GACAxC,OAAAuB,eAAA2D,EAAA1C,EAAAJ,IAAAU,IAAA,WACA,MAAAoC,GAAAkT,SAAA5V,GAAA8E,MAAApC,QAKAlF,OAAA+G,KAAA6Q,EAAAM,OAAA1U,QAAA,SAAAwW,GACA9U,EAAAyV,qBAAAX,EAAA9U,EAAAgT,MAAA8B,IAAA,IAGA,IAAA1R,IACA,eACA,eACA,eACA,gBACA,gBACA,mBACA,sBACA,sBACA,UACA,UAjXA,OAoXAlG,KAAA0L,KACAxF,EAAA9E,QAAA,SAAAsD,GACA5B,EAAAmC,GAAAP,EAAA,WACA,GAAAS,GAAAnF,IAAAwB,MAAA1B,UACAqF,GAAAC,KAAAtC,GACAqC,EAAAqC,QAAA9C,GACA1E,IAAA0L,IAAA3G,KAAAG,MAAAlF,IAAA0L,IAAAvG,OAMAoD,EAAAjB,eAAA,aACAkO,EAAAgD,QAAAjQ,EAAAiQ,SAjYAhD,EZijJE,MAzlDAjY,WAAU+X,MAAOC,mBA6XjB3W,aAAa0W,QACXlW,IAAK,SAWLrB,MAAO,SYhtFX0a,GACA,IAAA/Y,KAAAgZ,QAIA,MAAAD,QACA/Y,KAAA8Y,QAAAC,QAIA/Y,KAAAiX,YAKAjX,KAAAgX,YAAA,EAEAiC,aAAAjZ,KAAA+W,mBAEA/W,KAAAqF,KAAA,UAAArF,WZytFIN,IAAK,oBACLrB,MAAO,WYltFX2B,KAAA8Y,cZ0uFIpZ,IAAK,eACLrB,MAAO,SYttFX6a,EAAAC,GACA,IAAAnZ,KAAA4H,eAAAsR,GAEA,WADA1R,SAAAC,KAAA,sCAAAyR,EAAA,mCAAAlZ,KAAA8F,KAAA,MAAAxF,IAAA6D,IAAA,GAAA7D,IAAA6D,IAAA,GAIA,QAAA,mBAAAgV,GAAA,YAAAra,QAAAqa,IACA,IAAA,WACAnZ,KAAAuW,WAAA2C,GAAAlZ,KAAAuW,WAAA2C,OACAlZ,KAAAuW,WAAA2C,GAAAxT,KAAAyT,GACAnZ,KAAAqF,KAAA,gBAAA6T,EACA,MACA,KAAA,SACArZ,MAAA6M,QAAAyM,IACAnZ,KAAAuW,WAAA2C,GAAAlZ,KAAAuW,WAAA2C,OACAlZ,KAAAuW,WAAA2C,GAAAxT,KAAA,SAAArH,GACA,MAAA8a,GAAAxW,QAAAtE,IAAA,IAEA2B,KAAAqF,KAAA,gBAAA6T,IACAC,EAAAlS,MACAjH,KAAAuW,WAAA2C,GAAAlZ,KAAAuW,WAAA2C,OACAlZ,KAAAuW,WAAA2C,GAAAxT,KAAA,SAAArH,GACA,MAAA8a,GAAAlS,KAAA5I,KAEA2B,KAAAqF,KAAA,gBAAA6T,IAEA1R,QAAAC,KAAA,uCAAAyR,EAAA,2CAAA5Y,IAAA6D,IAAA,GAEA,MACA,KAAA,SACA,IAAA,SACA,IAAA,OACAnE,KAAAuW,WAAA2C,GAAAlZ,KAAAuW,WAAA2C,OACAlZ,KAAAuW,WAAA2C,GAAAxT,KAAA,SAAArH,GACA,MAAAA,KAAA8a,IAEAnZ,KAAAqF,KAAA,gBAAA6T,EACA,MACA,SACA1R,QAAAC,KAAA,sCAAAyR,EAAA,2CAAA5Y,IAAA6D,IAAA,QZouFIzE,IAAK,kBACLrB,MAAO,SY1tFX+C,GACApB,KAAAuW,WAAA3O,eAAAxG,WACApB,MAAAuW,WAAAnV,GACApB,KAAAqF,KAAA,mBAAAjE,OZyuFI1B,IAAK,WACLrB,MAAO,SY7tFX+C,GAEA,IAAApB,KAAAwW,WACA,OAAA,CAEA,IAAApT,GAAApD,IAGA,IAAAoB,EAAA,CACA,GAAApB,KAAAuW,WAAA3O,eAAAxG,GAAA,CACA,IAAA,GAAA9B,GAAA,EAAAA,EAAAU,KAAAuW,WAAAnV,GAAA7B,OAAAD,IAAA,CACA,IAAA8D,EAAAmT,WAAAnV,GAAA9B,GAAAkG,MAAApC,GAAAA,EAAAhC,KAEA,MADAgC,GAAAqU,sBAAA9U,QAAAvB,GAAA,GAAAgC,EAAAqU,sBAAA/R,KAAAtE,IACA,CAEAgC,GAAAqU,sBAAArU,EAAAqU,sBAAAjV,OAAA,SAAAb,GACA,MAAAP,KAAAO,IAKA,IAAA3B,KAAAoZ,iBAAAhY,GAEA,MADApB,MAAAyX,sBAAA/R,KAAAtE,IACA,EAIA,OAAA,EAIApB,KAAA0Y,WAAAhX,QAAA,SAAAwW,GACA9U,EAAAiW,SAAAnB,QZ2uFIxY,IAAK,mBACLrB,MAAO,SYhuFX6Z,GACA,GAAAoB,GAAAhZ,IAAAA,UAAAN,KAAAkY,IACAqB,EAAAjZ,IAAAA,UAAAN,KAAAgW,OAAAkC,GAAApS,KAEA,OAAA,SAAAwT,EACAA,IAAAC,EAGA,OAAAvZ,KAAAkY,KAAAlY,KAAAgW,OAAAkC,GAAAjC,aACAjW,KAAA4W,QAAAsB,IAAAlY,KAAA+V,gBZmvFIrW,IAAK,uBACLrB,MAAO,SYnuFXmb,GACA,MAAAxZ,MAAAoW,MAAAoD,MZ+uFI9Z,IAAK,kBACLrB,MAAO,SYtuFXmb,GACA,MAAAxZ,MAAAoW,MAAAxO,eAAA4R,MZkvFI9Z,IAAK,eACLrB,MAAO,SYzuFXmb,GACA,MAAAxZ,MAAAgW,OAAAwD,MZqvFI9Z,IAAK,eACLrB,MAAO,SY5uFXmb,GACA,MAAAxZ,MAAAgW,OAAApO,eAAA4R,MZ+vFI9Z,IAAK,YACLrB,MAAO,SY/uFXY,GACA,GAAAwa,GAAAxa,GAAAe,KAAAsY,IACAoB,IAEA,KAAA,GAAAha,KAAA+Z,GAEA,GADAA,EAAAE,wBAAAF,EAAAE,yBAAA,GACA3Z,KAAAgW,OAAApO,eAAAlI,KACAA,EAAA,OAAAA,EAAAM,KAAA+V,YAAArW;AACA+Z,EAAA7R,eAAAlI,IAAA+Z,EAAAE,wBAAAhX,QAAAjD,GAAA,GAAA,cAAAuH,KAAAvH,EAAAmE,OAAA,EAAA,KAAA3B,SAAAuX,EAAA/Z,IAAA+Z,EAAAG,qBAAAjX,QAAAjD,IAAA,GAAA,CACA,GAAAma,GAAA3b,OAAA2D,yBAAA4X,EAAA/Z,EACA,KAAAma,EAAA3Y,IAEA,OAAApC,QAAA+a,EAAAxb,QACA,IAAA,WAEA,SAAAwb,EAAAxb,MAAA6E,KACAwW,EAAAha,GAAA+Z,EAAA/Z,GAAAoa,KAAAC,SACA,WAAAF,EAAAxb,MAAA6E,OACAwW,EAAAha,GAAAma,EAAAxb,QAEA,MACA,KAAA,SAEAob,EAAA/Z,YAAAG,SAAAA,MAAA6M,QAAA+M,EAAA/Z,MACA+Z,EAAA/Z,GAAA+Z,EAAA/Z,GAAAoC,MAAA,IAGA4X,EAAAha,GAAA+Z,EAAA/Z,EACA,MACA,SACAga,EAAAha,GAAA+Z,EAAA/Z,IAQA,GAAA0D,GAAApD,IAKA,OAJAA,MAAAqW,cAAA3U,QAAA,SAAA2O,GACAqJ,EAAArJ,GAAAjN,EAAAmV,SAAAlI,GAAAkB,OAGAmI,KZ8vFIha,IAAK,WACLrB,MAAO,QAASua,UYlvFpBV,MAAA8B,SAAAC,gBACA,iBAAAD,YACAC,eAAAD,SACAA,SAAA,MAEAC,eAAA/X,SAAA+X,gBAAAA,cACA,IAAA7W,IAAApD,KACA2E,IAAA,IAEA,IAAA,OAAAuT,MAAAjV,cAAA,CACA,GAAA,YAAA,mBAAAiV,OAAA,YAAApZ,QAAAoZ,QAAA,CACA,IAAAA,MAAAhV,KACA,KAAA,IAAAjD,OAAA,kGAGA0E,KAAAuT,MACAA,MAAAvT,IAAAzB,WACAyB,KAAAzB,KAGA,GAAAhB,SAAAkB,GAAA8U,OAAA,CACA,IACA,GAAA3W,QAAAjB,IAAA6C,MAAAyD,KACAY,SAAAC,KAAA,KAAAyQ,MAAA,8CAAA3W,OAAAqC,KAAA,6CAAAtD,IAAA6D,IAAA,GAAA7D,IAAA6D,IAAA,IACA,MAAA5D,GACAiH,QAAAC,KAAA,KAAAyQ,MAAA,+EAAA5X,IAAA6D,IAAA,GAAA7D,IAAA6D,IAAA,UAGAf,IAAA8U,OAOA,GAHA9U,GAAA4S,OAAAkC,OAAAvT,KAAAvB,GAAA4S,OAAAkC,WACA9U,GAAA4S,OAAAkC,OAAAjC,SAAA3V,IAAA0B,SAAAoB,GAAA4S,OAAAkC,OAAAjC,UAAA,IAEA7S,GAAA4S,OAAAkC,OAAAtQ,eAAA,SACAxE,GAAA4S,OAAAkC,OAAAtQ,eAAA,WAAA,CACA,GAAA9B,MAAAxF,IAAAA,UAAA8C,GAAA4S,OAAAkC,OAAA9U,WACA0C,MAAAA,KAAAoU,OAAA,GAAAC,cAAArU,KAAAhE,MAAA,GACAsB,GAAA4S,OAAAkC,OAAApS,KAAA0E,KAAA1E,MA0DA,GAvDA1C,GAAA4S,OAAAkC,OAAApS,KAAAxF,IAAA0B,SAAAoB,GAAA4S,OAAAkC,OAAApS,KAAAoQ,QACAgC,QAAA9U,GAAA2S,aAAA3S,GAAAwT,UAAA,GACAxT,GAAA4S,OAAAkC,OAAApS,KAAAoQ,OACA9S,GAAA4S,OAAAkC,OAAA,WAAA5X,IAAAqU,KAAAC,KAAAQ,QAEAhS,GAAA4S,OAAAkC,OAAA,WAAA9U,GAAA4S,OAAAkC,OAAA,YAAA,KAEA9U,GAAAkV,IAAAJ,OAAA9U,GAAA4S,OAAAkC,OAAA,WACA9U,GAAA8U,OAAA9U,GAAAkV,IAAAJ,OAEAha,OAAAuB,eAAA2D,GAAA8U,OACAlX,IAAA,WACA,MAAAoC,IAAAkV,IAAAJ,QAEAhX,IAAA,SAAA7C,GACA,GAAA+b,GAAAhX,GAAAkV,IAAAJ,OACAmC,GAAAjX,GAAAiW,SAAAnB,MAWA9U,IAAAkV,IAAAJ,OAAA7Z,CAEA,IAAAoC,IACA6Z,OAAA,SACApC,MAAAA,MACAkC,IAAAA,EACAG,MAAAnX,GAAAkV,IAAAJ,OAGAlY,MAAAsX,UAAA5R,KAAAjF,GACAT,KAAAqF,KAAA,eAAA5E,GACAT,KAAAqF,KAAA,gBAAA6S,MAAAzX,GAGA2C,GAAAiW,SAAAnB,OAIAmC,GAGAjX,GAAAiC,KAAA,eACA6S,MAAAA,QAPA9U,GAAAiC,KAAA,iBACA6S,MAAAA,YAYA+B,eAAA,CACA,GAAAxZ,IACA6Z,OAAA,SACApC,MAAAA,MAEAlY,MAAAsX,UAAA5R,KAAAjF,GACAT,KAAAqF,KAAA,eAAA5E,GAIA,GAAA2C,GAAA4S,OAAApO,eAAAsQ,SACA9U,GAAA4S,OAAAkC,OAAAtQ,eAAA,YACAxE,GAAAoX,aAAAtC,MAAA9U,GAAA4S,OAAAkC,OAAAuC,UAEA,MAAA,MAAA,QAAA/Y,QAAA,SAAAhB,GACA0C,GAAA4S,OAAAkC,OAAAtQ,eAAAlH,IACA0C,GAAAoX,aAAAtC,MAAA,SAAAjL,GACA,MAAA7J,IAAAuU,kBAAAjX,GAAA0C,GAAA4S,OAAAkC,OAAAxX,GAAAuM,OAIA7J,GAAA4S,OAAAkC,OAAAtQ,eAAA,aACAxE,GAAA4S,OAAAkC,OAAAjC,UACA7S,GAAAoX,aAAAtC,MAAA,SAAAjL,GACA,MAAA7J,IAAAuU,kBAAA1B,SAAAiC,MAAAjL,KAIA7J,GAAA4S,OAAAkC,OAAAtQ,eAAA,aACA,GAAA,kBAAAxE,IAAA4S,OAAAkC,OAAAmB,SACAjW,GAAAoX,aAAAtC,MAAA,SAAAjL,GACA,MAAA7J,IAAA4S,OAAAkC,OAAAmB,SAAA7T,MAAApC,IAAA6J,UAEA,CACA,GAAA1L,SAAAjB,IAAA6C,MAAAyD,KACAY,SAAAC,KAAA,4CAAAlG,QAAAqC,KAAA,sEAAAtD,IAAA6D,IAAA,SAIA,QAAAf,GAAAoQ,IAAApQ,GAAAwT,SACAxT,GAAAoQ,GAAAlT,IAAAqU,KAAAC,KAAAQ,WZiwFI1V,IAAK,aACLrB,MAAO,SYrvFX6E,EAAAjC,GACA,GAAAmC,GAAApD,IACA9B,QAAAuB,eAAAO,KAAAkD,GACAlC,IAAA,WACA,MAAAC,GAAAuE,MAAApC,SZuwFI1D,IAAK,uBACLrB,MAAO,SYxvFX6E,EAAAyB,EAAAsV,GAGA,GAFAA,EAAA/X,SAAA+X,GAAAA,EAEAja,KAAAuY,SAAA3Q,eAAA1E,IAAAlD,KAAAgW,OAAApO,eAAA1E,IAAAlD,KAAA4H,eAAA1E,GACA,KAAA,IAAAjD,OAAAiD,EAAA,0DASA,KANA,kBAAAyB,IAAA,YAAA,mBAAAA,GAAA,YAAA7F,QAAA6F,MAAAA,EAAAiD,eAAA,WACAjD,GACAmB,KAAAnB,KAIAA,EAAAmB,KACA,KAAA,IAAA7F,OAAA,6FAGA0E,GAAAsR,SAAA3V,IAAA0B,SAAA2C,EAAAsR,UAAA,GACAtR,EAAAA,WAAAA,EAAAA,YAAA,IAEA,IAAAvB,GAAApD,KACA0a,EAAA,OAEA,IAAA/V,EAAAmB,eAAAxF,KAAAqU,KAAAgG,MACAD,EAAA,YACA,IAAA,UAAApa,IAAAA,UAAAqE,EAAAmB,MAAA,CACA,GAAA,IAAAnB,EAAAmB,KAAAvG,OACA,KAAA,IAAAU,OAAAiD,EAAA,uDAGAwX,GAAA,iBACA,WAAA5b,QAAA6F,EAAAmB,OACAnB,EAAAmB,KAAA8U,QACAF,EAAA,QAIA,IAAA,UAAAA,EAAA,CACA,GAAAG,KACA,IAAAlW,EAAAmB,eAAAxF,KAAAqU,KAAAgG,MACA3a,KAAAuY,SAAArV,GAAAyB,EAAAmB,KACA+U,EAAA,SACA,CAAA,IAAAlW,EAAAmB,KAAA8U,MAGA,KAAA,IAAA3a,OAAA,+DAFA4a,GAAAlW,EAAAmB,KAKA,OAAA+U,IACA7a,KAAAuY,SAAArV,GAAA,GAAA5C,KAAAqU,KAAAgG,MAAAE,IAEA7a,KAAA8a,kBAAA5X,OACA,IAAA,eAAAwX,EACA1a,KAAAuY,SAAArV,GAAA,GAAA5C,KAAAqU,KAAAgG,OACAC,MAAAjW,EAAAmB,KAAA,KAEA9F,KAAA8a,kBAAA5X,OACA,IAAAyB,EAAAmB,KAAAyL,KAGA,CAAA,IAAA5M,EAAAmB,KAAAyL,KAIA,KAAA,IAAAtR,OAAA,+DAHAD,MAAAuY,SAAArV,GAAAyB,EAAAmB,KACA9F,KAAA8a,kBAAA5X,OAJAlD,MAAAuY,SAAArV,GAAA,OAAAyB,EAAAA,WAAA,GAAAA,GAAAmB,KAAAnB,EAAAA,YAAA,GAAAA,GAAAmB,KACA9F,KAAA+a,kBAAA7X,EAeA,IAPAhF,OAAAuB,eAAAO,KAAAkD,GACA5E,YAAA,EACA0C,IAAA,WACA,MAAAoC,GAAAmV,SAAArV,OAIA+W,EAAA,CACA,GAAAxZ,IACA6Z,OAAA,SACApC,MAAAhV,EAEAlD,MAAAsX,UAAA5R,KAAAjF,GACAT,KAAAqF,KAAA,sBAAA5E,OZqwFIf,IAAK,oBACLrB,MAAO,SY3vFX6E,GACA,GAAA0X,GAAA5a,KAAAuY,SAAArV,GACAE,EAAApD,IAEA4a,GAAArV,GAAA,eAAA,SAAAyV,GACA,GAAA/S,IACAqS,OAAA,SACApC,MAAAhV,EAAA,IAAA8X,EAAA9C,MACAkC,IAAAY,EAAAZ,IACAG,MAAAS,EAAAA,OACAhR,MAAA,EACAiR,eACAvU,MAAA,eACAwU,OAAAN,GAIAxX,GAAAiC,KAAA,eAAA4C,GACA7E,EAAAiC,KAAA,gBAAAnC,EAAA,IAAA8X,EAAA9C,MAAAjQ,KAGA2S,EAAArV,GAAA,eAAA,SAAAyV,GACA,GAAA/S,IACAqS,OAAA,SACApC,MAAAhV,EAAA,IAAA8X,EAAA9C,MACAkC,IAAA,KACAG,MAAA,KACAvQ,MAAA,EACAiR,eACAvU,MAAA,eACAwU,OAAAN,GAIAxX,GAAAiC,KAAA,eAAA4C,GACA7E,EAAAiC,KAAA,gBAAAnC,EAAA,IAAA8X,EAAA9C,MAAAjQ,KAGA2S,EAAArV,GAAA,eAAA,SAAAyV,GACA,GAAA/S,IACAqS,OAAA,SACApC,MAAAhV,EAAA,IAAA8X,EAAA9C,MACAkC,IAAAY,EAAA3c,MACAkc,MAAA,KACAvQ,MAAA,EACAiR,eACAvU,MAAA,eACAwU,OAAAN,GAIAxX,GAAAiC,KAAA,eAAA4C,GACA7E,EAAAiC,KAAA,gBAAAnC,EAAA,IAAA8X,EAAA9C,MAAAjQ,KAGA2S,EAAArV,GAAA,gBAAA,SAAAgM,GACAnO,EAAAiC,KAAA,iBACAjC,EAAAiC,KAAA,iBAAAnC,EAAA,IAAAqO,EAAA2G,SAGA0C,EAAArV,GAAA,cAAA,SAAAgM,GACAnO,EAAAiC,KAAA,eACAjC,EAAAiC,KAAA,eAAAnC,EAAA,IAAAqO,EAAA2G,YZwwFIxY,IAAK,oBACLrB,MAAO,SY9vFX6E,GAAA,GAAAiY,GAAAnb,IACAA,MAAAuY,SAAA3Q,eAAA1E,IAIAlD,KAAAuY,SAAArV,GAAA0E,eAAA,WAAA,WACA,GAAAxE,GAAAA,CAEA+X,GAAA5C,SAAArV,GAAAqC,GAAA,gBAAA,SAAA2V,GACA,GAAAd,GAAAhX,EAAAF,GAAAqO,IACA6I,GAAAxT,KAEA,IAAAnG,IACA6Z,OAAA,SACApC,MAAAhV,EACA8G,MAAA,EACAoQ,IAAAA,EACAG,MAAAnX,EAAAF,GAAAqO,KACA0J,eACAvU,MAAA,gBACAwU,OAAAA,GAIA9X,GAAAiC,KAAA,eAAA5E,GACA2C,EAAAiC,KAAA,gBAAAnC,EAAAzC,KAGA0a,EAAA5C,SAAArV,GAAAqC,GAAA,gBAAA,SAAA2V,EAAAF,GACA,GAAAA,EAAA,CAIA,GAAAva,IACA6Z,OAAA,SACApC,MAAAhV,EAAA,IAAA8X,EAAA9C,MACAlO,MAAA,EACAoQ,IAAAY,EAAAZ,IACAG,MAAAS,EAAAA,OACAC,eACAvU,MAAA,gBACAwU,OAAAA,GAIA9X,GAAAiC,KAAA,eAAA5E,GACA2C,EAAAiC,KAAA,gBAAAnC,EAAA,IAAA8X,EAAA9C,MAAAzX,MAGA0a,EAAA5C,SAAArV,GAAAqC,GAAA,gBAAA,SAAA2V,GACA,GAAAd,GAAAhX,EAAAF,GAAAqO,IACA6I,GAAA1U,KAAAwV,EAAA3J,KAEA,IAAA9Q,IACA6Z,OAAA,SACApC,MAAAhV,EACA8G,MAAA,EACAoQ,IAAAA,EACAG,MAAAnX,EAAAF,GAAAqO,KACA0J,eACAvU,MAAA,gBACAwU,OAAAA,GAIA9X,GAAAiC,KAAA,eAAA5E,GACA2C,EAAAiC,KAAA,gBAAAnC,EAAAzC,KAGA0a,EAAA5C,SAAArV,GAAAqC,GAAA,iBAAA,SAAAgM,GACAnO,EAAAiC,KAAA,gBAAAkM,EAAA2G,OACA9U,EAAAiC,KAAA,iBAAAnC,EAAAqO,EAAA2G,SAGAiD,EAAA5C,SAAArV,GAAAqC,GAAA,eAAA,SAAAgM,GACAnO,EAAAiC,KAAA,cAAAkM,EAAA2G,OACA9U,EAAAiC,KAAA,eAAAnC,EAAAqO,EAAA2G,eZ+wFIxY,IAAK,cACLrB,MAAO,SYrwFX6E,GACA,GAAAlD,KAAAsY,IAAA1Q,eAAA1E,GAAA,CACA,GAAA+J,GAAAjN,KAAAsY,IAAApV,SACAlD,MAAAkD,SACAlD,MAAAgW,OAAA9S,SACAlD,MAAAsY,IAAApV,GACAlD,KAAAyX,sBAAA9U,QAAAO,IAAA,GACAlD,KAAAyX,sBAAA1V,OAAA/B,KAAAyX,sBAAA9U,QAAAO,GAAA,EAEA,IAAAzC,IACA6Z,OAAA,SACApC,MAAAhV,EACA7E,MAAA4O,EAEAjN,MAAAqF,KAAA,eAAA5E,GACAT,KAAAsX,UAAA5R,KAAAjF,OZixFIf,IAAK,gBACLrB,MAAO,SYxwFX6E,SACAlD,MAAAkD,MZqxFIxD,IAAK,0BACLrB,MAAO,SY3wFX6E,EAAA+W,GAEA,GADAA,EAAA/X,SAAA+X,GAAAA,EACAja,KAAAoW,MAAAxO,eAAA1E,GAAA,CACA,GAAA+J,GAAAjN,KAAAuY,SAAArV,EAIA,UAHAlD,MAAAuY,SAAArV,SACAlD,MAAAkD,SACAlD,MAAAoW,MAAAlT,IACA+W,EAAA,CACA,GAAAxZ,IACA6Z,OAAA,SACApC,MAAAhV,EACAkX,IAAAnN,EACAjD,MAAA,EAEAhK,MAAAsX,UAAA5R,KAAAjF,GACAT,KAAAqF,KAAA,sBAAA5E,QZ4xFIf,IAAK,OACLrB,MAAO,SY9wFX+c,GACAA,EAAAA,GAAA,CACA,IAAAhB,GAAApa,KAAAsX,UAAAvV,OAAA/B,KAAAsX,UAAA/X,OAAA6b,EAAAA,GACAhY,EAAApD,IAEAoa,GAAAlW,UAAAxC,QAAA,SAAA2Z,GACA,GAAA,iBAAAA,GAAArR,MAAAqR,EAAArR,KAcA,OAAAqR,EAAAf,QACA,IAAA,SACAlX,EAAAkY,wBAAAD,EAAAnD,MACA,MACA,KAAA,SACA9U,EAAAyV,qBAAAwC,EAAAnD,OACA9U,EAAAiY,EAAAnD,OAAAmD,EAAAjB,QAnBA,QAAAiB,EAAAf,QACA,IAAA,SACAlX,EAAAiY,EAAAnD,OAAAmD,EAAAjB,GACA,MACA,KAAA,SACAhX,EAAAmY,YAAAF,EAAAnD,MACA,MACA,KAAA,SACA9U,EAAAwV,SAAAyC,EAAAnD,OACA9U,EAAAiY,EAAAnD,OAAA9U,EAAAgX,UZwyFI1a,IAAK,OACLrB,MAAO,SYjxFXkT,GACAA,EAAAA,KAGA,IAAAnO,GAAApD,IACA,QAAAA,KAAAmY,UACAja,OAAA+G,KAAAjF,KAAAwb,YAAA9Z,QAAA,SAAAhC,GACA6R,EAAA3J,eAAAlI,KACA6R,EAAAnO,EAAAoY,WAAA9b,IAAA6R,EAAA7R,SACA6R,GAAA7R,MAMAxB,OAAA+G,KAAAsM,GAAA7P,QAAA,SAAAhC,GACA,GAAA0D,EAAA4S,OAAApO,eAAAlI,GACA0D,EAAAkV,IAAA1Q,eAAAlI,GACA0D,EAAAkV,IAAA5Y,GAAA6R,EAAA7R,GACAA,IAAA0D,EAAA2S,cACA3S,EAAAoQ,GAAAjC,EAAA7R,QAEA,IAAA0D,EAAAgT,MAAAxO,eAAAlI,GAIA0D,EAAAmV,SAAA7Y,GAAA+b,KAAAlK,EAAA7R,QAEA,KACA,GAAA6B,GAAAjB,IAAA6C,MAAAyD,KACAY,SAAAC,KAAA,KAAA/H,EAAA,qBAAA6B,EAAAqC,KAAA,sDAAAtD,IAAA6D,IAAA,GAAA7D,IAAA6D,IAAA,IACA,MAAA5D,GACAiH,QAAAC,KAAA,KAAA/H,EAAA,gEAAAY,IAAA6D,IAAA,OAKAnE,KAAAqX,mBZoxFI3X,IAAK,UACLsB,IAAK,WYx3HT,MAAAhB,MAAA0W,qBZ43HIhX,IAAK,cACLwB,IAAK,SY13HT7C,GACA,GAAA,iBAAAA,GAEA,KADAmJ,SAAAC,KAAAnH,IAAA6C,OACA,GAAAlD,OAAA,+DAAA,mBAAA5B,GAAA,YAAAS,QAAAT,IAGA2B,MAAA0W,kBAAArY,EAEAA,GACA2B,KAAAqF,KAAA,cZ83HI3F,IAAK,UACLsB,IAAK,WY13HT,MAAAhB,MAAA8W,YZ63HI5V,IAAK,SY13HT7C,GAAA,GAAAqd,GAAA1b,IAEA,IAAA,SAAAM,IAAAA,UAAAjC,IAAA,WAAAiC,IAAAA,UAAAjC,GAAA,CAeA,GAHA4a,aAAAjZ,KAAA+W,mBAGA,WAAAzW,IAAAA,UAAAjC,GAAA,CACA,GAAAA,EAAA,EAEA,YADA2B,KAAAiX,WAAA,EAIA,IAAA0E,GAAA,GAAAxE,KAEA9Y,GAAA,GAAA8Y,MACAwE,EAAAC,cACAD,EAAAE,WACAF,EAAAG,UACAH,EAAAI,WACAJ,EAAAK,aACAL,EAAAM,aACAN,EAAAO,kBAAA7d,GAYA,GANA2B,KAAAiX,WAAA,EAGAjX,KAAA8W,WAAAzY,EAGA8Y,KAAAC,OAAApX,KAAA8W,WAAAqF,UAEA,WADAnc,MAAAoc,QAIApc,MAAAgX,YAAA,CAGA,IAAAqF,GAAArc,KAAA8W,WAAAqF,UAAAhF,KAAAC,KACApX,MAAA+W,kBAAArO,WAAA,WACAgT,EAAAU,UACAC,OApDA,KACA,GAAA9a,GAAAjB,IAAA6C,MAAAyD,KACAY,SAAAC,KAAA,oCAAAlG,EAAAqC,KAAA,oDAAAtD,IAAA6D,IAAA,IACA,MAAA5D,GACAiH,QAAAC,KAAA,kFZ66HI/H,IAAK,UACLsB,IAAK,WYt3HT,OAAAhB,KAAAiX,WAIAjX,KAAAgX,cZi4HItX,IAAK,WACLsB,IAAK,WYz3HT,MAAAhB,MAAAiV,WAAAjV,KAAA6W,aZo4HInX,IAAK,KACLsB,IAAK,WY53HT,MAAAhB,MAAA2W,KZ+3HIzV,IAAK,SY53HT7C,GACA2B,KAAA2W,IAAAtY,KZs4HIqB,IAAK,WACLsB,IAAK,WY93HT,MAAAV,KAAAqU,KAAAC,KAAAK,SAAAtG,KAAAC,UAAA5O,KAAAuR,UZy4HI7R,IAAK,UACLsB,IAAK,WYj4HT,MAAAhB,MAAAmY,UZo4HIjX,IAAK,SYj4HT7C,GACA2B,KAAAmY,SAAA9Z,EACA2B,KAAAqY,gBAAA,QZ44HI3Y,IAAK,YACLsB,IAAK,WYn4HT,MAAAhB,MAAAwY,UZ64HI9Y,IAAK,QACLsB,IAAK,WYr4HT,MADAhB,MAAAqZ,WACA,IAAArZ,KAAAyX,sBAAAlY,UZi5HIG,IAAK,aACLsB,IAAK,WYz4HT,MAAA9C,QAAA+G,KAAAjF,KAAAgW,WZo5HItW,IAAK,gBACLsB,IAAK,WY54HT,MAAA9C,QAAA+G,KAAAjF,KAAAoW,UZu5HI1W,IAAK,oBACLsB,IAAK,WY/4HT,MAAA9C,QAAA+G,KAAAjF,KAAAsW,aZ06HI5W,IAAK,aACLsB,IAAK,WYn5HT,GAAAsb,GAAAtc,IACA,IAAA,OAAAA,KAAAoY,QAAA,CAAA,GAAAmE,GAAA,WACA,GAAA,OAAAD,EAAAjE,gBACA,OAAA3X,EAAA4b,EAAAjE,gBAEA,IAAAmE,MACApZ,EAAAA,CAKA,OAJAlF,QAAA+G,KAAAqX,EAAAnE,UAAAzW,QAAA,SAAAC,GACA6a,EAAApZ,EAAA+U,SAAAxW,IAAAA,IAEA2a,EAAAjE,gBAAAmE,GACA9b,EAAA8b,KAVA,IAAA,YAAA,mBAAAD,GAAA,YAAAzd,QAAAyd,IAAA,MAAAA,GAAA7b,EAYA,MAAA,SZw6HIhB,IAAK,OACLsB,IAAK,WYh6HT,GAAAyb,GAAAzc,KACA0c,EAAA1c,KAAA2c,WAmBA,QAlBAD,EAAA9U,eAAA5H,KAAA+V,cAAA/V,KAAA4W,SACA8F,EAAA1c,KAAA+V,aAAA/V,KAAAA,KAAA+V,cAEA/V,KAAAoY,UAAA,WACA,GAAAhV,GAAAA,CAEAlF,QAAA+G,KAAAwX,EAAArE,SAAA1W,QAAA,SAAAhC,GAEAgd,EAAA9U,eAAAlI,KACAgd,EAAAhd,YAAAY,KAAAqU,KAAAiB,MACA8G,EAAAtZ,EAAAgV,QAAA1Y,IAAAgd,EAAAhd,GAAA6R,KAEAmL,EAAAtZ,EAAAgV,QAAA1Y,IAAAgd,EAAAhd,SAEAgd,GAAAhd,SAIAgd,KZi7HIhd,IAAK,UACLsB,IAAK,WYt6HT,MAAAhB,MAAAsX,UAAApT,cZ26HS0R,OYljJTtV,IAAAoE,aA8+CApE,KAAAqU,KAAArU,IAAAqU,SAKAzW,OAAAiB,iBAAAmB,IAAAqU,MACAiB,MAAAtV,IAAAA,UAAA,SAAAqE,GACA,GAAAiY,GAAA,SAAArL,GACA,GAAAqJ,GAAA,GAAAhF,OAAAjR,EAIA,OAHA4M,IACAqJ,EAAAa,KAAAlK,GAEAqJ,EAGA,OAAAgC,KAGAC,OAAAvc,IAAAA,WAAAsV,SAGAtV,IAAA6B,WACAwI,OAAAC,QAAAtK,IAAAqU,KZulGA,Ia9lJAgG,Ob8lJY,SAAUmC,Ga7lJtB,QAAAnC,GAAAhW,GAAAhG,gBAAAqB,KAAA2a,GACAhW,EAAAA,KADA,IAAAoY,GAAAtf,2BAAAuC,MAAA2a,EAAAjc,WAAAR,OAAA6K,eAAA4R,IAAAhd,KAAAqC,KAEA2E,GAEAzG,QAAAiB,iBAAA4d,GAKAnC,MAAAta,IAAAA,SAAAqE,EAAAiW,OAAA,MAGAoC,MAAA1c,IAAAA,eAGA2c,SAAA3c,IAAAA,eAGA4c,OAAA5c,IAAAA,WAAAqE,EAAAjC,WAKAya,SAAA7c,IAAAA,eACA8c,SAAA9c,IAAAA,eACA+c,SAAA/c,IAAAA,YAAA,GACAgd,aAAAhd,IAAAA,eAOAid,MAAAjd,IAAAA,WAAA,MAQAkd,gBAAAld,IAAAA,UAAAA,IAAA0B,SAAA2C,EAAA6Y,iBAAA,IAQAC,iBAAAnd,IAAAA,SAAAA,IAAA0B,SAAA2C,EAAA8Y,iBAAA9Y,EAAA6Y,iBAAA,IAMAE,yBAAApd,IAAAS,aAAAT,IAAA0B,SAAA2C,EAAA+Y,0BAAA,IA+CAC,WAAArd,IAAAS,aAAAT,IAAA0B,SAAA2C,EAAAgZ,YAAA,IAOAC,cAAAtd,IAAAA,WAAAA,IAAA0B,SAAA2C,EAAAiZ,oBAGA,IAAA3e,KACA8d,GAAAG,OAAAxb,QAAA,SAAApC,GACAL,EAAAK,QAGAyd,EAAAG,OAAAje,CAEA,IAAAuH,IACA,mBACA,gBACA,gBACA,gBACA,kBACA,gBACA,cACA,iBACA,eACA,QACA,gBACA,gBACA,eACA,eArIA,OAwIAlG,KAAA0L,KACAxF,EAAA9E,QAAA,SAAAsD,GACA+X,EAAAxX,GAAAP,EAAA,WACA,GAAAS,GAAAnF,IAAAwB,MAAA1B,UACAqF,GAAAc,QACAd,EAAAC,KAAA1F,MACAM,IAAA0L,IAAA3G,KAAAL,EAAAS,OA9IAsX,EbknME,MAphDAlf,WAAU8c,EAAOmC,GAmJjB5d,aAAayb,IACXjb,IAAK,MAiBLrB,MAAO,Sa5hJXkT,EAAAsM,GACA,GAAA3C,GAAAA,MAEA,IAAA3J,YAAAjR,KAAAqU,KAAAkI,OAWA3B,EAAA3J,MAXA,CACA,IAAAA,EAAA5C,KAAA8C,MAAAF,GAAA,MAAAhR,IACA,GAAA,YAAA,mBAAAgR,GAAA,YAAAzS,QAAAyS,IACA,KAAA,IAAAtR,OAAA,kCAGAib,GADAlb,KAAA4a,MACA,GAAA5a,MAAA4a,MAAArJ,GAEAA,EAMA2J,EAAAtT,eAAA,YACAsT,EAAA1C,OAAAxY,KAGA,IAAA8d,GAAA9d,KAAA+d,YAAA7C,EACA,KAAA4C,IACA9d,KAAAqF,KAAA,mBAAA6V,GACAlb,KAAAwd,iBAkBA,MAVAxd,MAAAge,OAAA9C,GACAlb,KAAAie,aAAA/C,EAAAlb,KAAAgd,MAAAzd,QACAS,KAAAgd,MAAAtX,KAAAwV,IACAlb,KAAAqd,UAAArd,KAAAmd,SAAAxa,QAAAuY,GAAA,GAAAlb,KAAAmd,SAAAzX,KAAAwV,GACA5a,IAAA0B,SAAA6b,GAAA,IACA7d,KAAAqF,KAAA,gBAAA6V,GAEAA,EAAAjD,OACAjY,KAAAqF,KAAA,iBAAA6V,GAEAA,CAjBA,IAAAlb,KAAAyd,iBACA,KAAA,IAAAxd,OAAA,6DbmkJIP,IAAK,eACLrB,MAAO,SajiJXqE,EAAA6O,GAAA,GAAAsM,KAAAzd,UAAAb,QAAA,GAAA2C,SAAA9B,UAAA,KAAAA,UAAA,EACA,OAAAJ,MAAAke,OAAAxb,EAAA6O,EAAAsM,EAAA,abwjJIne,IAAK,cACLrB,MAAO,SatiJXqE,EAAA6O,GAAA,GAAAsM,KAAAzd,UAAAb,QAAA,GAAA2C,SAAA9B,UAAA,KAAAA,UAAA,EACA,OAAAJ,MAAAke,OAAAxb,EAAA,EAAA6O,EAAAsM,EAAA,Yb+jJIne,IAAK,SACLrB,MAAO,Sa3iJXqE,EAAA6O,GAAA,GAAAsM,KAAAzd,UAAAb,QAAA,GAAA2C,SAAA9B,UAAA,KAAAA,UAAA,GAAA+d,EAAA/d,UAAAb,QAAA,GAAA2C,SAAA9B,UAAA,GAAA,QAAAA,UAAA,GACA8a,EAAAlb,KAAAyE,IAAA8M,GAAA,EASA,OARA2J,KACAlb,KAAAoe,KAAApe,KAAAgd,MAAAzd,OAAA,EAAAmD,EAAAyb,GAAA,GAEAN,GACA7d,KAAAqF,KAAA,gBAAA6V,IAIAA,Kb6jJIxb,IAAK,cACLrB,MAAO,SajjJX6c,GACA,QAAAlb,KAAAgd,MAAAra,QAAAuY,IAAA,IAGAlb,KAAAgd,MAAAxa,OAAA,SAAA6b,GACA,MAAAA,GAAApJ,WAAAiG,EAAAjG,WACA1V,OAAA,KbgkJIG,IAAK,SACLrB,MAAO,SapjJX6c,GAAA,GAAAoD,GAAAte,IACAkb,GAAA3V,GAAA,eAAA,SAAAyV,GACAsD,EAAAC,aAAAvD,EAAA9C,MAAA8C,EAAAZ,IAAAY,EAAAA,OAAAsD,EAAAtB,MAAAra,QAAAuY,IACAoD,EAAAjZ,KAAA,gBAAA6V,EAAAF,KAGAE,EAAA3V,GAAA,eAAA,SAAAyV,GACAsD,EAAAC,aAAAvD,EAAA9C,MAAA8C,EAAAZ,IAAAlY,OAAAoc,EAAAtB,MAAAra,QAAAuY,IACAoD,EAAAjZ,KAAA,gBAAA6V,EAAAF,KAGAE,EAAA3V,GAAA,gBAAA,WACA+Y,EAAAjZ,KAAA,iBAAA6V,KAGAA,EAAA3V,GAAA,cAAA,WACA+Y,EAAAjZ,KAAA,eAAA6V,KAGAA,EAAA3V,GAAA,UAAA,WACA,GAAA2V,EAAAlC,UAIAsF,EAAAjZ,KAAA,iBAAA6V,GAEAoD,EAAAZ,0BAAA,CACA,GAAAhb,GAAA4b,EAAA3b,QAAAuY,EACAxY,IAAA,GACA4b,EAAAjW,OAAA6S,SbqkJIxb,IAAK,OACLrB,MAAO,SazjJXqI,EAAA6K,GAAA,GAAAiN,GAAAxe,IACAA,MAAAqd,UAAA,EAEA9L,EAAA7P,QAAA,SAAAwZ,GACAsD,EAAA/Z,IAAAyW,GAAA,KAGAlb,KAAAqd,UAAA,EACArd,KAAAod,YACApd,KAAAmd,YAIAzU,WAAA,WACA8V,EAAAnZ,KAAAqB,GAAA,SACA,Ob2kJIhH,IAAK,OACLrB,MAAO,Wa7jJX,GAAAkE,GAAA1C,MAAA6M,QAAAtM,UAAA,IAAAA,UAAA,GAAAE,IAAAwB,MAAA1B,UACAJ,MAAAye,KAAA,OAAAlc,MbwkJI7C,IAAK,SACLrB,MAAO,SajkJXkT,GACAvR,KAAAsG,OACA,IAAA/D,GAAA1C,MAAA6M,QAAAtM,UAAA,IAAAA,UAAA,GAAAE,IAAAwB,MAAA1B,UACAJ,MAAAye,KAAA,SAAAlc,Mb+kJI7C,IAAK,UACLrB,MAAO,SapkJX6c,GACA,MAAA,YAAA,mBAAAA,GAAA,YAAApc,QAAAoc,MAAAA,YAAA5a,KAAAqU,KAAAkI,QAAA3B,EAAAjG,UAIAjV,KAAAgd,MAAAld,UAAA,SAAA+C,GACA,MAAAA,GAAAoS,WAAAiG,EAAAjG,iBbklJIvV,IAAK,WACLrB,MAAO,SavkJX6c,GACA,MAAAlb,MAAA2C,QAAAuY,IAAA,Kb+lJIxb,IAAK,SACLrB,MAAO,Sa1kJXkT,EAAA0I,GAAA,GAAAyE,GAAA1e,KACA2e,KACAC,EAAAA,MAcA,IAZA,gBAAArN,GACAqN,EAAArN,EACAA,GAAAA,EAAA0D,UAAA,OAAA1D,EAAA0D,UAAA1D,YAAAjR,KAAAqU,KAAAiB,MACAgJ,EAAA5e,KAAA2C,QAAA4O,IACA,WACA,GAAAsN,GAAA,GAAAH,GAAA9D,MAAArJ,IAAA,GACAqN,GAAAF,EAAA1B,MAAAld,UAAA,SAAA+C,GACA,MAAAA,GAAAoS,WAAA4J,EAAA5J,cAKA2J,EAAA,EACA,KAAA,IAAA3e,OAAA,qDAAA2e,GAAA,IAAA9b,WAAA,KASA,IANA9C,KAAAgd,MAAA4B,GAAAE,aAAA,EAEAH,EAAA3e,KAAAgd,MAAAjb,OAAA6c,EAAA,GAEAD,EAAAG,aAAA,EAEAH,EAAApf,OAAA,EAAA,CAiBA,GAhBAof,EAAAA,EAAA,GACA3e,KAAA+e,eAAAH,GAEA5e,KAAA2d,aACA3d,KAAA4d,eAAA,IAAA,WACA,GAAA3I,GAAA0J,EAAA1J,QACA0J,GAAAhZ,KAAA,UAAA,WACA+Y,EAAAM,mBAAA/J,KAGA0J,EAAA7F,QAAA4F,EAAAd,iBAGA5d,KAAAsd,aAAA5X,KAAAiZ,KAGA3e,KAAAqd,SAAA,CACA,GAAA/d,GAAAU,KAAAmd,SAAAxa,QAAAgc,EACArf,IAAA,EACAA,GAAA,GAAAU,KAAAmd,SAAApb,OAAAzC,EAAA,GACAU,KAAAod,SAAAza,QAAAgc,GAAA,GACA3e,KAAAod,SAAA1X,KAAAiZ,GAQA,MAJAre,KAAA0B,SAAAiY,GAAA,IACAja,KAAAqF,KAAA,gBAAAsZ,EAAAC,GAGAD,EAGA,MAAA,SbomJIjf,IAAK,qBACLrB,MAAO,SanlJX4W,GACA,GAAAvS,GAAAA,OACAwY,EAAAlb,KAAAsd,aAAA9a,OAAA,SAAA0Y,EAAA5b,GACA,GAAA4b,EAAAjG,WAAAA,EAEA,MADAvS,GAAApD,GACA,GAIA,IAAA,IAAA4b,EAAA3b,OAAA,CACA,GAAAgC,GAAAA,MACA,KACAA,EAAAjB,IAAA6C,MAAAyD,MAAAhD,KACA,MAAArD,GACAgB,EAAA,UAIA,MADAiG,SAAAC,KAAA,0BAAAyT,EAAA3b,OAAA,+BAAAgC,EAAAjB,IAAA6D,IAAA,GAAA7D,IAAA6D,KACA,KAGA,OACAzB,MAAAA,EACAwY,OAAAA,EAAA,ObumJIxb,IAAK,qBACLrB,MAAO,SatlJX4W,GACA,GAAAgK,GAAAjf,KAAAkf,mBAAAjK,EAGA,OAAA,QAAAgK,EACA,MAGAjf,KAAAsd,aAAAvb,OAAAkd,EAAAvc,MAAA,GAEA1C,KAAAqF,KAAA,gBAAA4Z,EAAA/D,QAEA+D,EAAA/D,WbsmJIxb,IAAK,UACLrB,MAAO,SazlJX4W,GACA,GAAAgK,GAAAjf,KAAAkf,mBAAAjK,EAGA,OAAA,QAAAgK,EACA,MAGAA,EAAA/D,OAAAiE,mBAAA,WACAF,EAAA/D,OAAApC,QAAA9Y,KAAA4d,cAEA5d,KAAAyE,IAAAwa,EAAA/D,QAAA,GAEAlb,KAAAsd,aAAA2B,EAAAvc,OAAAyc,mBAAA,WACAnf,KAAAsd,aAAAvb,OAAAkd,EAAAvc,MAAA,GAEAuc,EAAA/D,OAAA4D,aAAA,EAEA9e,KAAAqF,KAAA,kBAAA4Z,EAAA/D,QAEA+D,EAAA/D,WbsmJIxb,IAAK,QACLrB,MAAO,Wa5lJX,GAAA+gB,GAAApf,KAAAqf,EAAAjf,UAAAb,QAAA,GAAA2C,SAAA9B,UAAA,IAAAA,UAAA,EACAif,GAGArf,KAAAsd,gBAFAtd,KAAAsd,aAAAtd,KAAAgd,MAKAhd,KAAAgd,SAEA9e,OAAA+G,KAAAjF,KAAAkd,QAAAxb,QAAA,SAAAgB,GACA0c,EAAAlC,OAAAxa,QAGA1C,KAAAqF,KAAA,YbwpJI3F,IAAK,OACLrB,MAAO,SanmJXihB,EAAAC,GAAA,GAAAC,GAAAxf,IACA,IAAA,IAAAA,KAAAgd,MAAAzd,OACA,QAGA,IAAAkgB,MALAC,EAAA,WAOA,OAAA,mBAAAJ,GAAA,YAAAxgB,QAAAwgB,IACA,IAAA,WACAG,EAAAD,EAAAxC,MAAAxa,OAAA8c,EACA,MACA,KAAA,SACAG,EAAAH,EAAA,GAAAA,GAAAE,EAAAxC,MAAAzd,OAAA,KAAAigB,EAAAxC,MAAAsC,EACA,MACA,KAAA,SACA,GAAAK,GAAAH,EAAAI,WAAAJ,EAAAxC,MAAA,GAAAjH,YAAAuJ,EAAA3b,OACA,IAAA,OAAAgc,GAAAA,EAAApgB,OAAA,EAIA,MAHAogB,GAAAje,QAAA,SAAAgB,GACA+c,EAAA/Z,KAAA8Z,EAAAxC,MAAAta,OAEAhC,EAAA+e,EAGA,IAAAI,GAAAL,EAAAxC,MAAAxa,OAAA,SAAA0Y,GACA,OAAAA,EAAAA,EAAAnF,cAAA,IAAAjT,WAAAa,SAAA2b,EAAA3b,QAGA8b,GAAA,IAAAI,EAAAtgB,OAAA,KAAAsgB,EAAA,EAEA,MACA,KAAA,SACA,GAAAP,YAAAhf,KAAAqU,KAAAiB,MACA,MAAA4J,GAAAM,SAAAR,IACA5e,EAAA4e,IAGA5e,EAAA,KAGA,IAAA6P,MACAwP,KACAC,EAAA9hB,OAAA+G,KAAAqa,EAEAU,GAAAte,QAAA,SAAAwW,GACA,GAAAxV,GAAA8c,EAAAI,WAAA1H,EAAAoH,EAAApH,GAEAxV,GACA6N,EAAAA,EAAArL,OAAAxC,OAEA,OAAAwV,GAAA6H,EAAAra,KAAAwS,KAKA3H,EAAA/N,OAAA,SAAAE,EAAApD,GACA,MAAAiR,GAAA5N,QAAAD,KAAApD,IAIAygB,EAAAxgB,OAAA,IACAkgB,EAAAD,EAAAxC,MAAAxa,OAAA,SAAA0Y,EAAA5b,GACA,GAAAiR,EAAA5N,QAAArD,IAAA,EACA,OAAA,CAGA,KAAA,GAAA8T,GAAA,EAAAA,EAAA2M,EAAAxgB,OAAA6T,IACA,GAAA8H,EAAA6E,EAAA3M,MAAAkM,EAAAS,EAAA3M,IACA,OAAA,CAIA,QAAA,KAKAqM,EAAAA,EAAAva,OAAAqL,EAAAjN,IAAA,SAAAZ,GACA,MAAA8c,GAAAxC,MAAAta,MACAF,OAAA,SAAA0Y,GACA,IAAA,GAAA+E,GAAA,EAAAA,EAAAD,EAAAzgB,OAAA0gB,IACA,GAAAX,EAAAU,EAAAC,MAAA/E,EAAA8E,EAAAC,IACA,OAAA,CAIA,QAAA,GAEA,MACA,SACAR,EAAAD,EAAAxC,SAzFA,OAAA,YAAA,mBAAA0C,GAAA,YAAA5gB,QAAA4gB,IAAAA,EAAAhf,EA4FA,OAAA+e,EACA,MAGAnf,IAAA0B,SAAAud,GAAA,IACAvf,KAAAkgB,aAAAT,YAAA5f,OAAA4f,GAAAA,IAGAA,Mb0nJI/f,IAAK,eACLrB,MAAO,SajnJXkT,GACA,MAAA,KAAAvR,KAAAid,SAAA1d,OACAgS,GAGAvR,KAAAid,SAAAvb,QAAA,SAAAc,GACA+O,EAAAA,EAAA/O,OAAAA,KAGA+O,MbkoJI7R,IAAK,YACLrB,MAAO,SapnJX4C,GACAjB,KAAAid,SAAAvX,KAAAzE,GACAjB,KAAAqF,KAAA,gBAAApE,MbooJIvB,IAAK,eACLrB,MAAO,SavnJX4C,EAAAgZ,GACAA,EAAA3Z,IAAA0B,SAAAiY,GAAA,EAEA,IAAAkG,KAGAA,GADA,gBAAAlf,GACAjB,KAAAid,SAAAlb,OAAAd,EAAA,GAEAjB,KAAAid,SAAAlb,OAAA/B,KAAAid,SAAAta,QAAA1B,GAAA,GAGAkf,EAAA5gB,OAAA,IAAA0a,GACAja,KAAAqF,KAAA,gBAAA8a,EAAA,ObmoJIzgB,IAAK,eACLrB,MAAO,Sa1nJX4b,GAGA,GAFAA,EAAA3Z,IAAA0B,SAAAiY,GAAA,GAIA,YADAja,KAAAid,YAIA,MAAAjd,KAAAid,SAAA1d,OAAA,GACAS,KAAAqF,KAAA,gBAAArF,KAAAid,SAAArW,UbwoJIlH,IAAK,cACLrB,MAAO,Sa7nJX4b,GAAA,GAAAmG,GAAApgB,IACAia,GAAA3Z,IAAA0B,SAAAiY,GAAA,EAEA,IAAAoG,GAAArgB,KAAAuR,KAAAjO,IAAA,SAAA+a,GACA,MAAA1P,MAAAC,UAAAyP,KAGAiC,IAEAD,GAAA3e,QAAA,SAAAwZ,EAAA5b,GACA+gB,EAAA1d,QAAAuY,GAAA5b,GACAghB,EAAA5a,KAAA0a,EAAA9T,KAAAhN,MAIAghB,EAAA5e,QAAA,SAAA6e,GACAH,EAAA/X,OAAAkY,Qb0tJI7gB,IAAK,OACLrB,MAAO,SaloJX4C,GAAA,GAAAuf,GAAAxgB,IACA,mBAAAiB,GACAjB,KAAAqgB,QAAAI,KAAAxf,GACA,YAAA,mBAAAA,GAAA,YAAAnC,QAAAmC,MAAA,WACA,GAAAyf,GAAAxiB,OAAA+G,KAAAhE,EAEAuf,GAAAxD,MAAAyD,KAAA,SAAAnN,EAAAqN,GACA,IAAA,GAAArhB,GAAA,EAAAA,EAAAohB,EAAAnhB,OAAAD,IAAA,CAEA,GAAAgU,EAAA1L,eAAA8Y,EAAAphB,MAAAqhB,EAAA/Y,eAAA8Y,EAAAphB,IACA,MAAA,EAGA,KAAAgU,EAAA1L,eAAA8Y,EAAAphB,KAAAqhB,EAAA/Y,eAAA8Y,EAAAphB,IACA,QAIA,IAAAgU,EAAAoN,EAAAphB,MAAAqhB,EAAAD,EAAAphB,IACA,OAAA2B,EAAAyf,EAAAphB,IAAAwD,WAAAa,OAAAV,eACA,IAAA,MACA,MAAAnE,SAAAwU,EAAA0C,OAAA0K,EAAAphB,KACAgU,EAAAoN,EAAAphB,IAAAshB,cAAAD,EAAAD,EAAAphB,KAEAgU,EAAAoN,EAAAphB,IAAAqhB,EAAAD,EAAAphB,IAAA,IAEA,KAAA,OACA,MAAAgU,GAAAoN,EAAAphB,IAAAqhB,EAAAD,EAAAphB,IAAA,IAEA,SACA,MAAA,kBAAA2B,GAAAyf,EAAAphB,IACA2B,EAAAyf,EAAAphB,IAAAgU,EAAAqN,GAEA,GAMA,MAAA,QAGA3gB,KAAA6gB,abspJInhB,IAAK,cACLrB,MAAO,SazoJX6Z,EAAA+B,GACAja,KAAA4a,MAAAhT,eAAAsQ,IACA1Q,QAAAC,KAAA,4DAAAyQ,EAAA,MAAA5X,IAAA6D,IAAA,GAGA,IAAA2c,GAAA9gB,KAAAkd,OAAAtV,eAAAsQ,EAEAlY,MAAAkd,OAAAhF,GAAAlY,KAAAkd,OAAAhF,OACA5X,IAAA0B,SAAAiY,GAAA,IAAA6G,GACA9gB,KAAAqF,KAAA,iBACA6S,MAAAA,EACA6I,MAAA/gB,Ub2pJIN,IAAK,cACLrB,MAAO,Sa5oJX6Z,EAAA+B,GACAja,KAAAkd,OAAAtV,eAAAsQ,WACAlY,MAAAkd,OAAAhF,GAEA5X,IAAA0B,SAAAiY,GAAA,IACAja,KAAAqF,KAAA,iBACA6S,MAAAA,EACA6I,MAAA/gB,WbwpJIN,IAAK,eACLrB,MAAO,Wa/oJX,GAAA2iB,GAAAhhB,IACA9B,QAAA+G,KAAAjF,KAAAkd,QAAAxb,QAAA,SAAAhC,GACAshB,EAAA9D,OAAAxd,Wb6pJIA,IAAK,gBACLrB,MAAO,SappJX4b,GAAA,GAAAgH,GAAAjhB,IACAia,GAAA3Z,IAAA0B,SAAAiY,GAAA,GAEA/b,OAAA+G,KAAAjF,KAAAkd,QAAAxb,QAAA,SAAAhC,GACAuhB,EAAAC,YAAAxhB,EAAAua,QbqqJIva,IAAK,eACLrB,MAAO,SazpJX6c,EAAAiG,GAAA,GAAAC,GAAAphB,KACAqhB,EAAAnjB,OAAA+G,KAAAjF,KAAAkd,OAEA,KAAAmE,EAAA9hB,QAIA8hB,EAAA3f,QAAA,SAAAwW,GACA,GAAAgD,EAAAtT,eAAAsQ,GAAA,CAIA,IAAA,GAHAoJ,GAAAF,EAAAlE,OAAAhF,GAGA5Y,EAAA,EAAAA,EAAAgiB,EAAA/hB,OAAAD,IACA,GAAAgiB,EAAAhiB,GAAA,KAAA4b,EAAAhD,GAEA,WADAkJ,GAAAlE,OAAAhF,GAAA5Y,GAAAoG,KAAAyb,EAMAC,GAAAlE,OAAAhF,GAAAxS,MAAAwV,EAAAhD,GAAAiJ,Ub0qJIzhB,IAAK,iBACLrB,MAAO,Sa9pJXwT,GAAA,GAAA0P,GAAAvhB,IACA9B,QAAA+G,KAAAjF,KAAAkd,QAAAxb,QAAA,SAAAwW,GACA,GAAA5Y,GAAAiiB,EAAArE,OAAAhF,GAAAvV,QAAAkP,EACAvS,IAAA,GACAiiB,EAAArE,OAAAhF,GAAAnW,OAAAzC,EAAA,QborJII,IAAK,eACLrB,MAAO,SanqJX6Z,EAAAsJ,EAAAC,EAAA5P,GACA,GAAA7R,KAAAkd,OAAAtV,eAAAsQ,IAAAsJ,IAAAC,EAMA,IAAA,GAFAC,GAAA,EAEApiB,EAAA,EAAAA,EAAAU,KAAAkd,OAAAhF,GAAA3Y,OAAAD,IAAA,CACA,GAAAjB,GAAA2B,KAAAkd,OAAAhF,GAAA5Y,GAAA,EAiBA,IAfAjB,IAAAmjB,GACAxhB,KAAAkd,OAAAhF,GAAA5Y,GAAAyC,OAAA/B,KAAAkd,OAAAhF,GAAA5Y,GAAAqD,QAAAkP,GAAA,GACA6P,KACAxf,SAAAuf,EAGAC,IACArjB,IAAAojB,IACAzhB,KAAAkd,OAAAhF,GAAA5Y,GAAAoG,KAAAmM,GACA7R,KAAAkd,OAAAhF,GAAA5Y,GAAAiH,QACAvG,KAAAkd,OAAAhF,GAAA5Y,GAAAmhB,OACAzgB,KAAAkd,OAAAhF,GAAA5Y,GAAAwI,QAAAzJ,GACAqjB,KAGA,IAAAA,EACA,WbqrJIhiB,IAAK,aACLrB,MAAO,SatqJX6Z,EAAA7Z,GACA,IAAA2B,KAAAkd,OAAAtV,eAAAsQ,GACA,MAAA,KAGA,IAAAmJ,GAAArhB,KAAAkd,OAAAhF,GAAA1V,OAAA,SAAAmf,GACA,MAAAA,GAAApiB,OAAA,GAAAoiB,EAAA,KAAAtjB,GAGA,OAAA,KAAAgjB,EAAA9hB,QACA8hB,EAAA,GAAA9a,QACA8a,EAAA,Ub4rJI3hB,IAAK,OACLrB,MAAO,SazqJXkD,EAAAnC,GAAA,GAAAye,KAAAzd,UAAAb,QAAA,GAAA2C,SAAA9B,UAAA,KAAAA,UAAA,EACA,OAAA8B,UAAAX,MACAiG,SAAAC,KAAA,4CAIAvF,SAAA9C,MACAoI,SAAAC,KAAA,6CAIAlG,EAAAvB,KAAA4hB,eAAArgB,GACAnC,EAAAY,KAAA4hB,eAAAxiB,QAGAmC,IAAAnC,IAIAY,KAAAgd,MAAAjb,OAAA3C,EAAA,EAAAY,KAAAgd,MAAAjb,OAAAR,EAAA,GAAA,IAEAsc,GACA7d,KAAAqF,KAAA,eACAwc,SAAAtgB,EACAugB,SAAA1iB,EACA8b,OAAAlb,KAAAgd,MAAA5d,KAIAY,KAAA6gB,gBbyrJInhB,IAAK,iBACLrB,MAAO,Sa9qJXA,GACA,GAAA6D,SAAA7D,EAEA,MADAmJ,SAAAC,KAAA,2CACA,IAGA,IAAA,gBAAApJ,GACA,MAAAA,GAAA,GAAAA,GAAA2B,KAAAgd,MAAAzd,QACAiI,QAAAC,KAAA,KAAApJ,EAAA,oBAAAiC,IAAA6D,IAAA,IACA,MAGA9F,CACA,IAAA,gBAAAA,GAAA,CACA,GAAAmV,GAAAnV,CAIA,IAFAA,EAAA2B,KAAAsM,KAAAkH,IAEAnV,EAEA,MADAmJ,SAAAC,KAAA,KAAA+L,EAAA,qDAAAlT,IAAA6D,IAAA,IACA,KAIA,MAAAnE,MAAA2C,QAAAtE,MbyrJIqB,IAAK,UACLrB,MAAO,WajrJX,GAAA0jB,GAAA/hB,IACAA,MAAAgiB,eACAhiB,KAAAgd,MAAAtb,QAAA,SAAAwZ,EAAAxY,GACAqf,EAAA9D,aAAA/C,EAAAxY,QburJIhD,IAAK,OACLsB,IAAK,Wax4LT,MAAAhB,MAAAgd,MAAA1Z,IAAA,SAAAoZ,GACA,MAAAA,GAAAnL,Ubq5LI7R,IAAK,UACLsB,IAAK,Wa34LT,MAAAhB,MAAAkgB,aAAAlgB,KAAAgd,Ubs5LItd,IAAK,cACLsB,IAAK,Wa94LT,MAAAhB,MAAAkgB,aAAAlgB,KAAAgd,OAAAzd,Uby5LIG,IAAK,WACLsB,IAAK,Waj5LT,GAAAqf,GAAArgB,KAAAqgB,OACA,OAAArgB,MAAAgd,MAAAxa,OAAA,SAAA0Y,GACA,MAEA,KAFAmF,EAAA7d,OAAA,SAAA6b,GACA,MAAAA,GAAApJ,WAAAiG,EAAAjG,WACA1V,Yb65LIG,IAAK,QACLsB,IAAK,Wap5LT,MAAA,KAAAhB,KAAAqgB,QAAA9gB,OACA,KAEAS,KAAAqgB,QAAA,Mb+5LI3gB,IAAK,OACLsB,IAAK,Wav5LT,MAAA,KAAAhB,KAAAqgB,QAAA9gB,OACA,KAEAS,KAAAqgB,QAAArgB,KAAAqgB,QAAA9gB,OAAA,Ob45LSob,GannMTra,IAAAoE,aAo4CApE,KAAAqU,KAAAgG,MAAAA,KbixJA,IczpMAsH,OdypMY,SAAUC,GcxpMtB,QAAAD,GAAApZ,GAGA,GAHAlK,gBAAAqB,KAAAiiB,GACApZ,EAAAA,OAEAA,EAAAkY,MACA,KAAA,IAAA9gB,OAAA,4CAJA,IAAAkiB,GAAA1kB,2BAAAuC,MAAAiiB,EAAAvjB,WAAAR,OAAA6K,eAAAkZ,IAAAtkB,KAAAqC,MAAA,OASA6I,GAAAkY,MAAAxD,MAAA4E,EAEAjkB,OAAAiB,iBAAAgjB,GAKApB,MAAAzgB,IAAAA,SAAAuI,EAAAkY,OAMAhT,IAAAzN,IAAAA,UAAAuI,EAAAkF,KAAA,oBAMAkB,SAAA3O,IAAAA,UAAAuI,EAAAoG,UAAA,MAMAC,SAAA5O,IAAAA,UAAAuI,EAAAqG,UAAA,MASAkT,MAAA9hB,IAAAA,UAAAuI,EAAAuZ,OAAA,QA3CAD,EdqwME,MA5GAtkB,WAAUokB,EAAOC,GA+EjBhjB,aAAa+iB,IACXviB,IAAK,OACLrB,MAAO,WcjpMXmJ,QAAAC,KAAA,iEdqpMI/H,IAAK,QACLrB,MAAO,WclpMXmJ,QAAAC,KAAA,kEdspMI/H,IAAK,UACLsB,IAAK,Wc3qMT,GAAAoC,GAAApD,IACA,QACA7B,OAAA6B,KAAA+gB,MAAA5D,SACAhJ,OAAAnU,KAAA+gB,MAAAV,QAAA7d,OAAA,SAAA0Y,GACA,QAAA9X,EAAA2d,MAAA5D,SAAAxa,QAAAuY,GAAA,GAAA9X,EAAA2d,MAAA3D,SAAAza,QAAAuY,GAAA,IAGAA,EAAAmH,WACA/e,IAAA,SAAA4X,GACA,MAAAA,KAEAoH,SAAAtiB,KAAA+gB,MAAA3D,cdirMS6E,GctwMT3hB,IAAAoE,aAkGAxG,QAAAuB,eAAAa,IAAAqU,KAAA,QAAArU,IAAAA,SAAA2hB","file":"chassis.legacy.min.js","sourcesContent":["'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// Polyfill for IE11 & Safari\n// This is required to make the remove method work properly.\nif (!Array.prototype.findIndex) {\n  Array.prototype.findIndex = function (predicate) {\n    // eslint-disable-line no-extend-native\n    if (this === null) {\n      throw new Error('Array.prototype.findIndex called on null or undefined');\n    }\n    // if (typeof predicate !== 'function') {\n    //   throw new Error('Predicate must be a function (received ' + (typeof predicate) + ')')\n    // }\n    var list = Object(this);\n    var length = list.length >>> 0;\n    var thisArg = arguments[1];\n    var value;\n\n    for (var i = 0; i < length; i++) {\n      value = list[i];\n      if (predicate.call(thisArg, value, i, list)) {\n        return i;\n      }\n    }\n    return -1;\n  };\n}\n\n'use strict';\n\nwindow.NGN = {};\n\n'use strict';\n\n/**\n * @class NGN\n * @singleton\n */\n/**\n  * @method define\n  * Create an object definition for a property.\n  * For example:\n  *\n  * ```\n  * Object.defineProperty('attr', NGN.define(true, false, true, 'value'))\n  *\n  * // The snippet above is the same as:\n  * Object.defineProperty(this, 'attr', {\n  *  enumberable: true,\n  *  writable: false,\n  *  configurable: true,\n  *  value: 'value'\n  * })\n  * ```\n  * @param  {boolean} enumerable\n  * Determines if the attribute is considered an accessible part of the object.\n  * Making an attribute enumerable will make it show up as a key in an object,\n  * which can be iterated over (ex: `Object.keys()`). A non-enumerable asset is\n  * treated as a private attribute.\n  * @param  {boolean} writable\n  * Determines whether the value can be changed.\n  * @param  {boolean} configurable\n  * Determines whether the attribute can be removed from the object.\n  * @param  {any} value\n  * The actual value of the attribute.\n  * @private\n  */\nObject.defineProperty(NGN, 'define', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: function value(e, w, c, v) {\n    return {\n      enumerable: e,\n      writable: w,\n      configurable: c,\n      value: v\n    };\n  }\n});\n\nObject.defineProperties(NGN, {\n  /**\n   * @method public\n   * Create a `public` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.public('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  public: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, typeof value !== 'function', false, value);\n  }),\n\n  /**\n   * @method private\n   * Create a `private` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.private('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  private: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, typeof value !== 'function', false, value);\n  }),\n\n  /**\n   * @method const\n   * Create a `public` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.const('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  const: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, false, false, value);\n  }),\n\n  /**\n   * @method privateconst\n   * Create a `private` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.privateconst('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  privateconst: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, false, false, value);\n  }),\n\n  /**\n   * @method get\n   * Create a private `getter` property definition for an object.\n   * Public getters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  get: function () {\n   *    return 'somevalue'\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid async JavaScript function with a `return` value.\n   * @private\n   */\n  get: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      get: fn\n    };\n  }),\n\n  /**\n   * @method get\n   * Create a private `setter` property definition for an object.\n   * Public setters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  set: function (value) {\n   *    somethingElse = value\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid async JavaScript function with a `return` value.\n   * @private\n   */\n  set: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      set: fn\n    };\n  })\n});\n\nObject.defineProperties(NGN, {\n  /**\n   * @method extend\n   * Extend the NGN core object. Extending NGN is the equivalent of:\n   *\n   * Example:\n   * ```\n   * NGN.extend('greet', NGN.public(function (recipient) {\n   *  return 'Hello, ' + recipient + '!'\n   * }))\n   *\n   * // Equivalent of:\n   *\n   * Object.defineProperty(NGN, 'greet', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: function (recipient) {\n   *    return 'Hello, ' + recipient + '!'\n   *  }\n   * })\n   * ```\n   * The example above produces a public function available from NGN:\n   *\n   * ```\n   * console.log(NGN.greet('world')) // outputs Hello, world!\n   * @param  {string} attribute\n   * Name of the attribute to add to the object.\n   * @param  {Object} specification\n   * The object specification, i.e.\n   * ```\n   * {\n   *  enumerable: true/false,\n   *  writable: true/false,\n   *  configurable: true/false,\n   *  value: {any}\n   * }\n   *\n   * // OR\n   *\n   * {\n   *  enumerable: true/false,\n   *  get: function () { return ... },\n   *  set: function (value) { some = value ... }\n   * }\n   * ```\n   * @private\n   */\n  extend: NGN.privateconst(function (attribute, specification) {\n    Object.defineProperty(this, attribute, specification);\n  }),\n\n  /**\n   * @method inherit\n   * Inherit the properties of another object/class.\n   * @param  {object|function} source\n   * The source object (i.e. what gets copied)\n   * @param  {object|function} destination\n   * The object properties get copied to.\n   */\n  inherit: NGN.const(function (source, dest) {\n    if (!source || !dest) {\n      return;\n    }\n    source = typeof source === 'function' ? source.prototype : source;\n    dest = typeof dest === 'function' ? dest.prototype : dest;\n    Object.getOwnPropertyNames(source).forEach(function (attr) {\n      var definition = Object.getOwnPropertyDescriptor(source, attr);\n      Object.defineProperty(dest, attr, definition);\n    });\n  }),\n\n  /**\n   * @method slice\n   * Converts an array-like object to an array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.slice(arguments)\n   * }\n   * @param  {Object} obj\n   * The object to slice into an array.\n   * @return {array}\n   * @private\n   */\n  slice: NGN.private(function (obj) {\n    return Array.prototype.slice.call(obj);\n  }),\n\n  /**\n   * @method splice\n   * Converts an array-like object to a spliced array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.splice(arguments)\n   * }\n   * @param  {Object} obj\n   * The object to splice into an array.\n   * @return {array}\n   * @private\n   */\n  splice: NGN.private(function (obj) {\n    return Array.prototype.splice.call(obj);\n  }),\n\n  /**\n   * @method coalesce\n   * Finds the first non-null/defined value in a list of arguments.\n   * This can be used with {@link Boolean Boolean} values, since `true`/`false` is a\n   * non-null/defined value.\n   * @param {Mixed} args\n   * Any number of arguments can be passed to this method.\n   */\n  coalesce: NGN.public(function () {\n    for (var arg in arguments) {\n      if (arguments[arg] !== undefined && arguments[arg] !== null) {\n        return arguments[arg];\n      }\n    }\n    return null;\n  }),\n\n  /**\n   * @property {boolean} nodelike\n   * Indicates NGN is running in a node-like environment supporting\n   * the `require` statement. This will detect node, io.js, Electron,\n   * NW.js, and other environments presumably supporting Node.js.\n   * @private\n   */\n  nodelike: NGN.get(function () {\n    var node = false;\n    try {\n      node = require !== undefined;\n    } catch (e) {}\n    return node;\n  }),\n\n  /**\n   * @method dedupe\n   * Deduplicate a simple array.\n   * @param {array} array\n   * The array to deduplicate.\n   * @return {array}\n   * The array with unique records.\n   * @private\n   */\n  dedupe: NGN.private(function (array) {\n    return array.filter(function (element, index) {\n      return array.indexOf(element) === index;\n    });\n  }),\n\n  /**\n   * @method typeof\n   * A more specific typeof method.\n   * @param  {any} element\n   * The element to determine the type of.\n   * @return {string}\n   * Returns the type (all lower case).\n   */\n  typeof: NGN.define(false, false, false, function (el) {\n    var value = Object.prototype.toString.call(el).split(' ')[1].replace(/\\]|\\[/gi, '').toLowerCase();\n    if (value === 'function') {\n      if (!el.name) {\n        return el.toString().replace(/\\n/gi, '').replace(/^function\\s|\\(.*$/mgi, '').toLowerCase();\n      } else {\n        value = el.name || 'function';\n      }\n    }\n    return value.toLowerCase();\n  }),\n\n  /**\n   * @method stack\n   * Retrieve the stack trace from a specific code location without throwing\n   * an exception. Files are always listed from the root. This is the default\n   * order in browsers, but the reverse of the normal stack order in node-like\n   * environments.\n   *\n   * For example, the following stack on node shows `_test.js` as the last item\n   * in the array. In node-like environments, the `_test.js` would normally be\n   * the first item in the stacktrace.\n   *\n   * ```js\n   * [\n   *   { path: 'node.js:348:7', file: 'node.js', line: 348, column: 7 },\n   *   { path: 'module.js:575:10',\n   *     file: 'module.js',\n   *     line: 575,\n   *     column: 10 },\n   *   { path: 'module.js:550:10',\n   *     file: 'module.js',\n   *     line: 550,\n   *     column: 10 },\n   *   { path: 'module.js:541:32',\n   *     file: 'module.js',\n   *     line: 541,\n   *     column: 32 },\n   *   { path: '/_test.js:8:14', file: '/_test.js', line: 8, column: 14 }\n   * ]\n   * ```\n   *\n   * By standardizing the order of the stack trace, it is easier to programmatically\n   * identify sources of problems. This method does not prevent developers from\n   * accessing a normal stacktrace.\n   * @private\n   * @returns {array}\n   * Returns an array of objects. Each object contains the file, line, column,\n   * and path within the stack. For example:\n   *\n   * ```\n   * {\n   * \t path: 'path/to/file.js:127:14'\n   *   file: 'path/to/file.js',\n   *   line: 127,\n   *   column: 14\n   * }\n   * ```\n   *\n   * If a stacktrace is unavailable for any reason, the array will contain a\n   * single element like:\n   *\n   * ```js\n   * {\n   *   path: 'unknown',\n   *   file: 'unknown',\n   *   line: 0,\n   *   column: 0\n   * }\n   * ```\n   */\n  stack: NGN.get(function () {\n    var me = this;\n    var originalStack = new Error().stack.split('\\n');\n    var stack = new Error().stack.split('\\n') || [];\n\n    stack = stack.filter(function (item) {\n      return item.split(':').length > 1;\n    }).map(function (item) {\n      item = item.replace(/^.*\\s\\(/i, '').replace(/\\)/gi, '').replace(/^.*\\@/i, '').replace(window !== undefined ? window.location.origin : process !== undefined ? process.cwd() : '', '').replace(/^.*\\:\\/\\//, '').replace(/\\s{1,100}at\\s{1,100}/gi, '').replace(/anonymous\\>/, 'console').trim().split(':');\n\n      return {\n        path: item[0].substr(me.nodelike ? 0 : 1, item[0].length - (me.nodelike ? 0 : 1)) + ':' + item[1] + ':' + item[2],\n        file: item[0].substr(me.nodelike ? 0 : 1, item[0].length - (me.nodelike ? 0 : 1)),\n        line: parseInt(item[1], 10),\n        column: parseInt(item[2], 10)\n      };\n    });\n\n    if (stack.length === 0) {\n      return [{\n        path: 'unknown',\n        file: 'unknown',\n        line: 0,\n        column: 0\n      }];\n    } else if (me.nodelike) {\n      stack.reverse();\n    }\n\n    return stack;\n  }),\n\n  /**\n   * @property css\n   * A CSS string used for highlighting console output in Chrome and Firefox.\n   *\n   * **Example:**\n   *\n   * ```js\n   * console.log('%cHighlight %c some text and leave the rest normal.', NGN.css, '')\n   * ```\n   * @private\n   */\n  css: NGN.privateconst('font-weight: bold;')\n});\n\n'use strict';\n\nObject.defineProperty(NGN, 'global', NGN.privateconst(NGN.nodelike ? global : window));\n\n// Force scope\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.body.classList.add('ngn');\n});\n\n'use strict';\n\nif (!window.NGN) {\n  throw new Error('The EventEmitter class is dependent on the presence of NGN.');\n}\n\n/**\n * @class EventEmitter\n * This is an extendable generic class used to apply event management\n * to non-DOM objects, such as data models, logging, and other common\n * elements of JavaScript programming.\n * @protected\n */\n\nvar EventEmitter = function () {\n  /**\n   * @constructor\n   * ```\n   * let EE = new EventEmitter()\n   * ```\n   * This is a protected class. It is most commonly instantiated through\n   * the NGN namespace (i.e. `new NGN.EventEmitter()`). However; it is\n   * designed for use within the NGN library, not directly as an event emitter.\n   * Use with caution.\n   */\n  function EventEmitter(cfg) {\n    _classCallCheck(this, EventEmitter);\n\n    cfg = cfg || {};\n    Object.defineProperties(this, {\n      handlers: NGN.private({}),\n      adhoc: NGN.private({}),\n      maxlisteners: NGN.private(cfg.defaultMaxListeners || 10)\n    });\n  }\n\n  /**\n   * @property {object} subscribers\n   * An array of all subscribers which currently have a registered event handler.\n   * @warning This is a UI-only method.\n   */\n\n\n  _createClass(EventEmitter, [{\n    key: 'listenerCount',\n\n\n    /**\n     * @method {number} listenerCount\n     * The number of listeners for a specific event.\n     * @param {string} eventName\n     * The name of the event to count listeners for.\n     */\n    value: function listenerCount(eventName) {\n      return (this.handlers[eventName] || []).length + (this.adhoc[eventName] || []).length;\n    }\n\n    /**\n     * @method getMaxListeners\n     * A node-like reference to the #defaultMaxListeners value.\n     * @return {number}\n     */\n\n  }, {\n    key: 'getMaxListeners',\n    value: function getMaxListeners() {\n      return this.defaultMaxListeners;\n    }\n\n    /**\n     * @method setMaxListeners\n     * A node-like reference to the #defaultMaxListeners value (setter).\n     */\n\n  }, {\n    key: 'setMaxListeners',\n    value: function setMaxListeners(value) {\n      this.defaultMaxListeners = value;\n    }\n\n    /**\n     * @method eventNames\n     * A node-like reference providing an array of recognized event names.\n     * @return {array}\n     */\n\n  }, {\n    key: 'eventNames',\n    value: function eventNames() {\n      var handlers = Object.keys(this.handlers);\n      var adhoc = Object.keys(this.adhoc);\n      return NGN.dedupe(handlers.concat(adhoc));\n    }\n\n    /**\n     * @method listeners\n     * Returns the raw listener methods for the event.\n     * @param {string} eventName\n     * Name of the event to retrieve listeners for.\n     * @return {array}\n     */\n\n  }, {\n    key: 'listeners',\n    value: function listeners(eventName) {\n      var handlers = this.handlers[eventName] || [];\n      var adhoc = this.adhoc[eventName] || [];\n      return handlers.concat(adhoc);\n    }\n\n    /**\n     * @method on\n     * Create a new event handler for the specified event.\n     * @param  {string} eventName\n     * Name of the event to listen for.\n     * @param  {Function} handler\n     * The method responsible for responding to the event.\n     * @param {boolean} [prepend=false]\n     * When set to `true`, the event is added to the beginning of\n     * the processing list instead of the end.\n     */\n\n  }, {\n    key: 'on',\n    value: function on(eventName, callback, prepend) {\n      this.handlers[eventName] = this.handlers[eventName] || [];\n      this.handlers[eventName][NGN.coalesce(prepend, false) ? 'unshift' : 'push'](callback);\n      this.emit('newListener', eventName, callback);\n      if (this.listenerCount(eventName) > this.maxlisteners) {\n        throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.');\n      }\n    }\n\n    /**\n     * @method addListener\n     * A node-like reference to the #on method.\n     */\n\n  }, {\n    key: 'addListener',\n    value: function addListener() {\n      this.on.apply(this, arguments);\n    }\n\n    /**\n     * @method prependListener\n     * A node-like reference to the #on method, adding events to the\n     * beginning of the event list (processed before others) instead of the end.\n     * @param  {string} eventName\n     * Name of the event to listen for.\n     * @param  {Function} handler\n     * The method responsible for responding to the event.\n     */\n\n  }, {\n    key: 'prependListener',\n    value: function prependListener() {\n      var args = NGN.slice(arguments).push(true);\n      this.on.apply(this, args);\n    }\n\n    /**\n     * @method on\n     * Create a new event handler for the specified event. The\n     * handler will be removed immediately after it is executed. This\n     * effectively listens for an event to happen once and only once\n     * before the handler is destroyed.\n     * @param  {string} eventName\n     * Name of the event to listen for.\n     * @param  {Function} handler\n     * The method responsible for responding to the event.\n     * @param {boolean} [prepend=false]\n     * When set to `true`, the event is added to the beginning of\n     * the processing list instead of the end.\n     */\n\n  }, {\n    key: 'once',\n    value: function once(eventName, callback, prepend) {\n      this.adhoc[eventName] = this.adhoc[eventName] || [];\n      this.adhoc[eventName][NGN.coalesce(prepend, false) ? 'unshift' : 'push'](callback);\n      this.emit('newListener', eventName, callback);\n      if (this.listenerCount(eventName) > this.maxlisteners) {\n        throw new Error('Maximum event listeners exceeded. Use setMaxListeners() to adjust the level.');\n      }\n    }\n\n    /**\n     * @method prependOnceListener\n     * A node-like reference to the #once method, adding events to the\n     * beginning of the event list (processed before others) instead of the end.\n     * @param  {string} eventName\n     * Name of the event to listen for.\n     * @param  {Function} handler\n     * The method responsible for responding to the event.\n     */\n\n  }, {\n    key: 'prependOnceListener',\n    value: function prependOnceListener() {\n      var args = NGN.slice(arguments).push(true);\n      this.once.apply(this, args);\n    }\n\n    /**\n     * @method off\n     * Remove an event handler. If no handler is specified, all handlers for\n     * the specified event will be removed.\n     * @param {string} eventName\n     * Name of the event to remove.\n     * @param {function} [handlerFn]\n     * The handler function to remove from the event handlers.\n     */\n\n  }, {\n    key: 'off',\n    value: function off(eventName, handlerFn) {\n      this.deleteEventHandler('handlers', eventName, handlerFn);\n    }\n\n    /**\n     * @method onceoff\n     * Remove an event handler that was originally created using #once. If no\n     * handler is specified, all handlers for the spcified event will be removed.\n     * @param {string} eventName\n     * Name of the event to remove.\n     * @param {function} handlerFn\n     * The handler function to remove from the event handlers.\n     */\n\n  }, {\n    key: 'onceoff',\n    value: function onceoff(eventName, handlerFn) {\n      this.deleteEventHandler('adhoc', eventName, handlerFn);\n    }\n\n    /**\n     * @method deleteEventHandler\n     * Remove a specific event handler.\n     * @param {string} type\n     * Either `handler` (multi-use events) or `adhoc` (one-time events)\n     * @param {string} eventName\n     * Name of the event to remove.\n     * @param {function} handlerFn\n     * The handler function to remove from the event handlers.\n     * @private\n     */\n\n  }, {\n    key: 'deleteEventHandler',\n    value: function deleteEventHandler(type, eventName, handlerFn) {\n      var scope = this[type];\n\n      if (scope[eventName]) {\n        var _ret = function () {\n          if (!handlerFn) {\n            delete scope[eventName];\n            return {\n              v: void 0\n            };\n          }\n\n          var result = [];\n          scope[eventName].forEach(function (handler) {\n            if (handler.toString() !== handlerFn.toString()) {\n              result.push(handler);\n            }\n          });\n\n          if (result.length === 0) {\n            delete scope[eventName];\n            return {\n              v: void 0\n            };\n          }\n\n          scope[eventName] = result;\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    }\n\n    /**\n     * @alias removeListener\n     * A node-like alias of the #off and #onceoff method (combined).\n     */\n\n  }, {\n    key: 'removeListener',\n    value: function removeListener() {\n      this.off.apply(this, arguments);\n      this.onceoff.apply(this, arguments);\n    }\n\n    /**\n     * @method clear\n     * Remove all event handlers from the EventEmitter (both regular and adhoc).\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var _this = this;\n\n      if (arguments.length > 0) {\n        NGN.slice(arguments).forEach(function (eventName) {\n          delete _this.handlers[eventName];\n          delete _this.adhoc[eventName];\n        });\n      } else {\n        this.handlers = {};\n        this.adhoc = {};\n      }\n    }\n\n    /**\n     * @alias removeAllListeners\n     * A node-like alias of the #clear method.\n     */\n\n  }, {\n    key: 'removeAllListeners',\n    value: function removeAllListeners() {\n      this.clear.apply(this, arguments);\n    }\n\n    /**\n     * @method emit\n     * Fires an event. This method accepts one or more arguments. The\n     * first argument is always the event name, followed by any number\n     * of payload arguments.\n     *\n     * Example:\n     * ```\n     * const EE = new NGN.EventEmitter()\n     *\n     * EE.emit('someevent', {payload: 1}, {payload: 2})\n     * ```\n     * The example above triggers an event called `someevent` and applies\n     * the remaining two arguments to any event handlers.\n     * @param {string} eventName\n     * The name of the event to trigger.\n     */\n\n  }, {\n    key: 'emit',\n    value: function emit() {\n      var args = NGN.slice(arguments);\n      var eventName = args.shift();\n      var events = this.getAllEvents(eventName);\n\n      var scope = {\n        event: eventName\n      };\n\n      for (var name in events) {\n        var adhocEvent = this.adhoc[events[name]];\n        // Adhoc event handling\n        if (adhocEvent) {\n          delete this.adhoc[events[name]];\n\n          while (adhocEvent.length > 0) {\n            var fn = adhocEvent.pop();\n            scope.handler = fn;\n            fn.apply(scope, args);\n          }\n        }\n\n        // Regular event handling\n        var handler = this.handlers[events[name]];\n        if (handler) {\n          for (var _fn in handler) {\n            scope.handler = handler[_fn];\n            handler[_fn].apply(scope, args);\n          }\n        }\n      }\n    }\n\n    /**\n     * @method getAllEvents\n     * Returns all of the events that match an event name. The event name\n     * may contain wildcards (i.e. `*`) or it can be a regular expression.\n     * @param  {string|regexp} eventName\n     * A string or regular expression defining which event names to identify.\n     * A string value containing an asterisk (*) will be converted to a regular\n     * expression for simplistic wildcard event handling purposes.\n     * @return {array}\n     * An array of unique event names with handlers or adhoc handlers.\n     * @private\n     */\n\n  }, {\n    key: 'getAllEvents',\n    value: function getAllEvents(eventName) {\n      var regularEvents = Object.keys(this.handlers);\n      var adhocEvents = Object.keys(this.adhoc);\n      var allEvents = NGN.dedupe(regularEvents.concat(adhocEvents));\n\n      allEvents = allEvents.filter(function (event) {\n        // If the event is an exact match, don't filter it out.\n        if (event === eventName) {\n          return true;\n        }\n\n        // If the event is a regexp/wildcard, further processing is necessary.\n        if (NGN.typeof(event) === 'regexp' || event.indexOf('*') >= 0) {\n          // Convert wildcard events to a regular expression.\n          if (NGN.typeof(event) !== 'regexp') {\n            event = new RegExp(event.replace('*', '.*', 'gi'));\n          }\n          // If the event name matches the event, keep it.\n          return event.test(eventName);\n        }\n\n        // None of the criteria were met. Ignore the event.\n        return false;\n      });\n\n      return allEvents;\n    }\n  }, {\n    key: 'subscribers',\n    get: function get() {\n      var subscriberList = {};\n\n      for (var eventName in this.handlers) {\n        subscriberList[eventName] = {\n          handler: this.handlers[eventName].length,\n          adhoc: 0\n        };\n      }\n\n      for (var _eventName in this.adhoc) {\n        subscriberList[_eventName] = subscriberList[_eventName] || {\n          handler: 0\n        };\n\n        subscriberList[_eventName].adhoc = this.adhoc[_eventName].length;\n      }\n\n      return subscriberList;\n    }\n\n    /**\n     * @property defaultMaxListeners\n     * The maximum number of listeners for a single event.\n     */\n\n  }, {\n    key: 'defaultMaxListeners',\n    get: function get() {\n      return this.maxlisteners;\n    },\n    set: function set(value) {\n      this.maxlisteners = value;\n    }\n  }]);\n\n  return EventEmitter;\n}();\n\nNGN.extend('EventEmitter', NGN.private(EventEmitter));\n\n'use strict';\n\n/**\n * @class NGN.EventEmitter\n * @inheritdoc\n */\nNGN.inherit(Object.defineProperties({}, {\n  queued: NGN.private({}),\n\n  /**\n   * @method pool\n   * A helper command to create multiple related subscribers\n   * all at once. This is a convenience function.\n   * @property {string} [prefix]\n   * Supply a prefix to be added to every event. For example,\n   * `myScope.` would turn `someEvent` into `myScope.someEvent`.\n   * @property {Object} subscriberObject\n   * A key:value object where the key is the name of the\n   * unprefixed event and the key is the handler function.\n   * @property {Function} [callback]\n   * A callback to run after the entire pool is registered. Receives\n   * a single {Object} argument containing all of the subscribers for\n   * each event registered within the pool.\n   */\n  pool: NGN.const(function (prefix, group, callback) {\n    if (typeof prefix !== 'string') {\n      group = prefix;\n      prefix = '';\n    }\n\n    var pool = {};\n\n    for (var eventName in group) {\n      var topic = (prefix.trim() || '') + eventName;\n      if (typeof group[eventName] === 'function') {\n        pool[eventName] = this.on(topic, group[eventName]);\n      } else {\n        console.warn('%c' + topic + '%c could not be pooled in the event emitter because it\\'s value is not a function.', NGN.css, '');\n      }\n    }\n    if (callback) {\n      callback(pool);\n    }\n  }),\n\n  /**\n   * @method attach\n   * Attach a function to a topic. This can be used\n   * to forward events in response to asynchronous functions.\n   *\n   * For example:\n   *\n   * ```js\n   * myAsyncDataFetch(NGN.BUS.attach('topicName'))\n   * ```\n   *\n   * This is the same as:\n   *\n   * ```js\n   * myAsyncCall(function(data){\n   *  NGN.BUS.emit('topicName', data)\n   * })\n   * ```\n   * @param {string} eventName\n   * The name of the event to attach a handler method to.\n   * @param {boolean} [preventDefaultAction=false]\n   * Setting this to `true` will execute a `event.preventDefault()` before\n   * attaching the handler.\n   * @returns {function}\n   * Returns a function that will automatically be associated with an event.\n   */\n  attach: NGN.const(function (eventName, preventDefaultAction) {\n    var me = this;\n    preventDefaultAction = NGN.coalesce(preventDefaultAction, false);\n\n    return function (e) {\n      if (preventDefaultAction && e.hasOwnProperty('preventDefault')) {\n        e.preventDefault();\n      }\n      var args = NGN.slice(arguments); //NGN.slice(arguments)\n      args.unshift(eventName);\n      me.emit.apply(me, args);\n    };\n  }),\n\n  /**\n   * @method bind\n   * A special subscriber that fires one or more event in response to\n   * to an event. This is used to bubble events up/down an event chain.\n   *\n   * For example:\n   *\n   * ```js\n   * BUS.bind('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\n   * ```\n   * When `sourceEvent` is published, the bind method triggers `someEvent` and\n   * `anotherEvent`, passing the payload object to `someEvent` and\n   * `anotherEvent` subscribers simultaneously.\n   *\n   * @param {String} sourceEvent\n   * The event to subscribe to.\n   * @param {String|Array} triggeredEvent\n   * An event or array of events to fire in response to the sourceEvent.\n   * @param {any} data\n   * Optional data to pass to each bound event handler.\n   * @returns {Object}\n   * Returns an object with a single `remove()` method.\n   */\n  bind: NGN.const(function (eventName, triggers, payload) {\n    triggers = typeof triggers === 'string' ? [triggers] : triggers;\n\n    var me = this;\n    var listener = function listener() {\n      var args = NGN.slice(arguments);\n\n      if (payload) {\n        args.push(payload);\n      }\n\n      for (var trigger in triggers) {\n        var argList = args.slice();\n        argList.unshift(triggers[trigger]);\n        me.emit.apply(me, argList);\n      }\n    };\n\n    this.on(eventName, listener);\n\n    // Provide handle back for removal of topic\n    return {\n      remove: function remove() {\n        me.off(eventName, listener);\n      }\n    };\n  }),\n\n  /**\n   * @method queue\n   * This method waits for the specified duration, then publishes an\n   * event once. This will publish the event only once at the end of the\n   * wait period, even if the event is triggered multiple times. This can\n   * be useful when working with many events triggered in rapid succession.\n   *\n   * For example, an NGN.DATA.Model representing a person may be used to\n   * track a user profile. The NGN.DATA.Model fires an event called `field.update`\n   * every time a data field is modified. In many cases, a user may update\n   * multiple fields of their profile using a form with a \"Save\" button.\n   * Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\n   * operation for each field, the publishOnce event can wait until all\n   * changes are made before running the save operation.\n   *\n   * ```js\n   * // Create a data model representing a person.\n   * var Person = new NGN.DATA.Model({....})\n   *\n   * // Create a new person record for a user.\n   * var user = new Person()\n   *\n   * // When the user is modified, save the data.\n   * user.on('field.update', function () {\n   * \t // Wait 300 milliseconds to trigger the save event\n   *   NGN.BUS.queue('user.save', 300)\n   * })\n   *\n   * // Save the user using an API\n   * NGN.BUS.on('user.save', function () {\n   * \t NGN.HTTP.put({\n   * \t   url: 'https://my.api.com/user',\n   * \t   json: user.data\n   * \t })\n   * })\n   *\n   * // Modify the record attributes (which are blank by default)\n   * user.firstname = 'John'\n   * user.lastname = 'Doe'\n   * user.age = 42\n   *\n   * // Make another update 1 second later\n   * setTimeout(function () {\n   *   user.age = 32\n   * }, 1000)\n   * ```\n   *\n   * The code above sets up a model and record. Then it listens to the record\n   * for field updates. Each time it recognizes an update, it queues the \"save\"\n   * event. When the queue matures, it fires the `user.save` event.\n   *\n   * The first `field.update` is triggered when `user.firstname = 'John'` runs.\n   * This initiates a queue for `user.save`, set to mature in 300 millisenconds.\n   * Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\n   * This time, since the queue for `user.save` is already initiated, notthing\n   * new happens. Finally, a `field.update` is triggered when `user.age = 42`\n   * runs. Just like the last one, nothing happens since the `user.save` queue\n   * is already active.\n   *\n   * The `user.save` queue \"matures\" after 300 milliseconds. This means after\n   * 300 milliseconds have elapsed, the `user.save` event is triggered. In this\n   * example, it means the `NGN.HTTP.put()` code will be executed. As a result,\n   * all 3 change (firstname, lastname, and age) will be complete before the\n   * API request is executed. The queue is cleared immediately.\n   *\n   * The final update occurs 1 second later (700 milliseconds after the queue\n   * matures). This triggers a `field.update`, but since the queue is no\n   * longer active, it is re-initiated. 300 milliseconds later, the `user.save`\n   * event is fired again, thus executing the API request again (1.3 seconds\n   * in total).\n   * @param {string} eventName\n   * The event/topic to publish/emit.\n   * @param {Number} [delay=300]\n   * The number of milliseconds to wait before firing the event.\n   * @param {Any} [payload]\n   * An optional payload, such as data to be passed to an event handler.\n   */\n  queue: NGN.const(function (eventName, delay) {\n    var _this2 = this,\n        _arguments = arguments;\n\n    if (!this.queued.hasOwnProperty(eventName)) {\n      (function () {\n        var me = _this2;\n        var args = NGN.slice(_arguments);\n        args.splice(1, 1);\n\n        _this2.queued[eventName] = setTimeout(function () {\n          delete me.queued[eventName];\n          me.emit.apply(me, args);\n        }, delay);\n      })();\n    }\n  })\n}), NGN.EventEmitter);\n\n'use strict';\n\nvar CustomException = function (_Error) {\n  _inherits(CustomException, _Error);\n\n  // eslint-disable-line\n  function CustomException(config) {\n    _classCallCheck(this, CustomException);\n\n    var _this3 = _possibleConstructorReturn(this, (CustomException.__proto__ || Object.getPrototypeOf(CustomException)).call(this));\n\n    config = config || {};\n    config = typeof config === 'string' ? { message: config } : config;\n    config.custom = config.custom || {};\n\n    var me = _this3;\n\n    _this3.name = config.name || 'NgnError';\n    _this3.type = config.type || 'TypeError';\n    _this3.severity = config.severity || 'minor';\n    _this3.message = config.message || 'Unknown Error';\n    _this3.category = config.category || 'operational'; // Alternative is \"programmer\"\n\n    // Cleanup name\n    _this3.name = _this3.name.replace(/[^a-zA-Z0-9_]/gi, '');\n\n    // Add any custom properties\n    for (var attr in config.custom) {\n      if (config.custom.hasOwnProperty(attr)) {\n        _this3[attr] = config.custom[attr];\n      }\n    }\n    _this3.hasOwnProperty('custom') && delete _this3.custom;\n\n    if (NGN.nodelike || Error.prepareStackTrace) {\n      //   console.log('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++')\n      // Capture the stack trace on a new error so the detail can be saved as a structured trace.\n      Error.prepareStackTrace = function (_, stack) {\n        return stack;\n      };\n\n      var _err = new Error();\n      Error.captureStackTrace(_err, _this3);\n\n      _this3.rawstack = _err.stack;\n\n      Error.prepareStackTrace = function (err, stack) {\n        // eslint-disable-line handle-callback-err\n        me.cause && console.warn(me.cause);\n        me.help && console.info(me.help);\n\n        return me.name + ': ' + me.message + '\\n' + stack.filter(function (frame) {\n          return frame.getFileName() !== __filename && frame.getFileName();\n        }).map(function (el) {\n          return '    at ' + el;\n        }).join('\\n');\n      };\n\n      // Enable stack trace\n      Error.captureStackTrace(_this3);\n    }\n    return _this3;\n  }\n\n  /*\n   * @property {Array} trace\n   * The structured data of the stacktrace. Each array element is a JSON object corresponding to\n   * the full stack trace:\n   *\n   * ```js\n   * {\n   *   filename: String,\n   *   line: Number,\n   *   column: Number,\n   *   functionname: String,\n   *   native: Boolean,\n   *   eval: Boolean,\n   *   type: String\n   * }\n   * ```\n   * @readonly\n   */\n\n\n  _createClass(CustomException, [{\n    key: 'trace',\n    get: function get() {\n      return this.rawstack.filter(function (frame) {\n        return frame.getFileName() !== __filename && frame.getFileName();\n      }).map(function (frame) {\n        return {\n          filename: frame.getFileName(),\n          line: frame.getLineNumber(),\n          column: frame.getColumnNumber(),\n          functionname: frame.getFunctionName(),\n          native: frame.isNative(),\n          eval: frame.isEval(),\n          type: frame.getTypeName()\n        };\n      });\n    }\n  }]);\n\n  return CustomException;\n}(Error);\n\nif (NGN.nodelike) {\n  module.exports = CustomException;\n}\n\n'use strict';\n\n/**\n * @class NGN\n * @inheritdoc\n */\n/**\n * @method createException\n * Create a custom global exception.\n * For more information, see the [Custom Exceptions Guide](#!/guide/customerrors).\n * @param {Object} config\n * The configuration of the new error.\n * @param {String} [config.name=NgnError]\n * The pretty name of the exception. Alphanumeric characters only (underscore is acceptable).\n * @param {String} [config.type=TypeError]\n * The type of error. This is commonly `TypeError` or `ReferenceError`, but\n * it can be any custom value.\n * @param {String} [config.severity=minor]\n * A descriptive \"level\" indicating how critical the error is.\n * @param {String} [config.message=Unknown Error]\n * The default message to output when none is specified.\n * @param {Object} [config.custom]\n * Provide a key/value object of custom attributes for the error.\n * There are two \"special\" custom attributes: `help` and `cause`.\n * When provided, these will be written to stdout whenever the error's\n * stack is viewed.\n *\n * For example:\n *\n * ```js\n * require('ngn')\n *\n * NGN.createException({\n *   name: 'Test Problem',\n *   message: 'An example error.',\n *   custom: {\n *     help: 'Remove the throw statement.',\n *     cause: 'Testing the error output.'\n *   }\n * });\n *\n * throw TestProblem()\n * ```\n * The code above generates the following console output:\n *\n * ```sh\n * Testing the error output.\n * Remove the throw statement.\n * /path/to/test.js:12\n *    throw TestProblem();\n *    ^\n *\n * TestProblem: An example error.\n *    at null._onTimeout (/path/to/test.js:12:11)\n *    at Timer.listOnTimeout (timers.js:92:15)\n * ```\n */\nNGN.extend('createException', NGN.public(function (config) {\n  config = config || {};\n  config = typeof config === 'string' ? { message: config } : config;\n  config.name = config.name || 'NgnError';\n  config.name = config.name.replace(/[^a-zA-Z0-9_]/gi, '');\n\n  // Create the error as a function\n  NGN.global[config.name] = function () {\n    if (arguments.length > 0) {\n      config.message = arguments[0];\n    }\n    return new CustomException(config);\n  };\n}));\n\n/**\n * @class DOM\n * A utility class to simplify some DOM management tasks.\n */\nNGN.DOM = {};\n\nObject.defineProperties(NGN.DOM, {\n  /**\n   * @method ready\n   * Executes code after the DOM is loaded.\n   * @param {function} callback\n   * The function to call when the DOM is fully loaded.\n   */\n  ready: NGN.const(function (callback) {\n    document.addEventListener('DOMContentLoaded', callback);\n  }),\n\n  /**\n   * @method destroy\n   * Remove a DOM element.\n   * @param {HTMLElement|NodeList|String|Array} node\n   * Accepts a single `HTMLElement`, a `NodeList`, a CSS selector, or\n   * an array of `HTMLElements`/`NodeList`/CSS Selectors.\n   */\n  destroy: NGN.const(function (element) {\n    // Process a CSS selector\n    if (typeof element === 'string') {\n      var str = element;\n      element = document.querySelectorAll(element);\n\n      if (element.length === 0) {\n        console.warn('The \\\"' + str + '\\\" selector did not return any elements.');\n        return;\n      }\n      // Iterate through results and remove each element.\n      NGN.slice(element).forEach(this.destroy);\n    } else {\n      switch (NGN.typeof(element)) {\n        case 'array':\n          element.forEach(this.destroy);\n          return;\n        case 'nodelist':\n          NGN.slice(element).forEach(this.destroy);\n          return;\n        case 'htmlelement':\n          element.parentNode.removeChild(element);\n          return;\n        default:\n          if (/^html.*element$/.test(NGN.typeof(element))) {\n            element.parentNode.removeChild(element);\n            return;\n          }\n          console.warn('An unknown error occurred while trying to remove DOM elements.');\n          console.log('Unknown Element', element);\n      }\n    }\n  }),\n\n  /**\n   * @method findParent\n   * Find a distant parent of a DOM element. This can be thought\n   * of as a reverse CSS selector that traverses UP the DOM chain\n   * to find the parent element.\n   *\n   * For example:\n   *\n   * Assume the following HTML structure & JS code:\n   *\n   * ```html\n   * <section>\n   *   <header class=\"MyGroup\">\n   *     <div>\n   *       <div>\n   *         <button>Delete Entire Group</button>\n   *       </div>\n   *     </div>\n   *   </header>\n   * </section>\n   * ```\n   *\n   * ```js\n   * ref.find('button.remove').addEventListener('click', function (event) {\n   *   event.preventDefault()\n   *   let removeButton = event.currentTarget\n   *   let group = ref.findParent(removeButton,'header')\n   *   ref.destroy(group)\n   * })\n   * ```\n   *\n   * The code above listens for a click on the button. When the button\n   * is clicked, the `findPerent` method recognizes the \"Delete Entire Group\"\n   * button and traverses UP the DOM chain until it finds a `header` DOM\n   * element. The `header` DOM element is returned (as `group` letiable). The\n   * group is then removed using the `ref.destroy` method.\n   *\n   * Alternatively, the same effect could have been achieved if line 4\n   * of the JS code was:\n   * ```js\n   * let group = ref.findParent(removeButton, '.MyGroup')\n   * ```\n   * @param {HTMLElement|String} element\n   * The DOM element or a CSS selector string identifying the\n   * element whose parent should be found.\n   * @param {String} selector\n   * A minimal CSS selector used to identify the parent.\n   * @param {Number} maxDepth\n   * The maximum number of elements to traverse. This can be used to\n   * cap a selector and force it to fail before reaching a known limit.\n   * By default, there is no limit (i.e. maxDepth=null).\n   * @returns {HTMLElement}\n   * Responds with the DOM Element, or `null` if none was found.\n   */\n  findParent: NGN.const(function (node, selector, maxDepth) {\n    if (typeof node === 'string') {\n      node = document.querySelectorAll(node);\n      if (node.length === 0) {\n        console.warn('\\\"' + node + '\\\" is an invalid CSS selector (Does not identify any DOM elements).');\n        return null;\n      }\n      node = node[0];\n    }\n\n    var currentNode = node.parentNode;\n    var i = 0;\n    maxDepth = typeof maxDepth === 'number' ? maxDepth : -1;\n\n    while (currentNode.parentNode.querySelector(selector) === null && currentNode.nodeName !== 'BODY') {\n      i++;\n      if (maxDepth > 0 && i > maxDepth) {\n        return null;\n      }\n      currentNode = currentNode.parentNode;\n    }\n\n    return currentNode;\n  }),\n\n  /**\n   * @method indexOfParent\n   * Returns the zero-based index of the DOM element related\n   * to its parent element.\n   * For example:\n   *\n   * `html\n   * <div>\n   *   <p>...</p>\n   *   <p>...</p>\n   *   <button id=\"btn\"></button>\n   *   <p>...</p>\n   * </div>\n   * ```\n   *\n   * ```js\n   * let i = NGN.DOM.indexOfParent(document.getElementById('btn'))\n   * console.log(i) // 2\n   * ```\n   * @param {HTMLElement} el\n   * The reference element.\n   * @returns {number}\n   */\n  indexOfParent: NGN.const(function (element) {\n    return NGN.slice(element.parentNode.children).indexOf(element);\n  })\n});\n\n/**\n * @class BUS\n * The bus acts as a pub/sub messaging system (as opposed to a queue). It is primarily\n * designed for asynchronous communication between javascript objects, but can also be\n * bound to DOM events.\n *\n * The most common use looks like:\n * ```js\n *   var subscriber = NGN.BUS.subscribe('test', function () {\n *     console.log('test handled')\n *   })\n *\n *   NGN.BUS.subscribeOnce('test', function () {\n *     console.log('RESPOND ONCE!')\n *   })\n *\n *   NGN.BUS.publish('test') // Outputs \"test handled\" and \"RESPOND ONCE\".\n *\n *   NGN.BUS.publish('test') // Outputs \"test handled\" only.\n *\n *   subscriber.unsubscribe() // Removes the listener\n *\n *   NGN.BUS.publish('test') // Outputs nothing since the subscription was removed.\n * ```\n * There are a few aliases for ease of use, including `on() --> subscribe()`,\n * `once() --> subscribeOnce()`, and `emit() --> publish()`.\n *\n * It is also possible to use a wildcard in a subscription.\n *\n * ```js\n *   var subscriber = NGN.BUS.subscribe('test.*', function () {\n *     console.log('test handled')\n *   })\n *   var subscriber = NGN.BUS.subscribe('test.create', function () {\n *     console.log('test create handled')\n *   })\n *\n *   NGN.BUS.publish('test.create') // Outputs \"test handled\" and \"test create handled\"\n *\n *   NGN.BUS.publish('test.delete') // Outputs \"test handled\"\n * ```\n * @singleton\n */\nNGN.extend('BUS', NGN.const(new NGN.EventEmitter()));\n\n/**\n * @class NGN.ref\n * A global \"pointer\" to DOM elements. This is used to reference and manipulate\n * DOM elements in a simple and standard way, without restricting native functionality.\n */\n'use strict';\n\nNGN.ref = new function () {\n  var requireBUS = function requireBUS(trigger, event, scope, nm, preventDefault) {\n    if (NGN.BUS === undefined) {\n      return console.error('The event BUS is required for ' + nm + '().');\n    }\n    preventDefault = NGN.coalesce(preventDefault, false);\n    var fn = function fn(e) {\n      if (preventDefault && e.preventDefault) {\n        e.preventDefault();\n      }\n      NGN.BUS.emit(event, e);\n    };\n    scope.addEventListener(trigger, fn);\n  };\n\n  var qs = function qs(value, selector, all) {\n    if (typeof value === 'string') {\n      return document[all ? 'querySelector' : 'querySelectorAll']((value + ' > ' + selector).trim());\n    }\n    return value[all ? 'querySelector' : 'querySelectorAll'](selector.trim());\n  };\n\n  Object.defineProperties(this, {\n\n    keys: NGN.define(false, true, false, {}),\n\n    _find: NGN.define(false, false, false, function (value, selector) {\n      if (typeof value === 'string') {\n        var reference = NGN.ref.find((value + ' > ' + selector).trim());\n        if (reference.length === 0) {\n          var tmpref = NGN.ref.find(value.trim())[0].parentNode.querySelectorAll(selector);\n          if (tmpref.length > 0) {\n            if (tmpref.length === 1) {\n              return tmpref[0];\n            }\n            return tmpref;\n          }\n        }\n        return reference;\n      }\n      return NGN.ref.find(value.querySelectorAll(selector));\n    }),\n\n    /**\n     * @method find\n     * Retrieve the DOM element(s) for the given selector. This method provides\n     * an **unmanaged** reference object.\n     * @private\n     * @param {String} selector\n     * The selector (CSS-style).\n     * @returns {ref}\n     * Returns an instance of the reference.\n     */\n    find: NGN.define(false, false, false, function (value) {\n      var html = typeof value !== 'string';\n      var els = html === false ? document.querySelectorAll(value) : value;\n      var result = null;\n\n      if (els.length === 1) {\n        if (!els[0].hasOwnProperty('isArray')) {\n          Object.defineProperties(els[0], {\n            isArray: NGN.get(function () {\n              return false;\n            }, false)\n          });\n        }\n\n        if (!els[0].hasOwnProperty('find')) {\n          Object.defineProperty(els[0], 'find', NGN.const(function (selector) {\n            return NGN.ref._find(value, selector);\n          }));\n        }\n\n        if (!els[0].hasOwnProperty('forward')) {\n          Object.defineProperty(els[0], 'forward', NGN.const(function (trigger, event) {\n            requireBUS(trigger, event, this, 'forward');\n          }));\n        }\n\n        if (!els[0].hasOwnProperty('on')) {\n          Object.defineProperty(els[0], 'on', NGN.const(function () {\n            this.addEventListener.apply(this, arguments);\n          }));\n        }\n\n        result = els[0];\n      } else {\n        var base = NGN.slice(els);\n        if (NGN.typeof(els) === 'nodelist' && base.length === 1) {\n          base = base[0];\n        }\n\n        // Apply querySelector/All to the response for chaining.\n        Object.defineProperties(base, {\n          querySelector: NGN.define(false, false, false, function (selector) {\n            qs(value, selector);\n          }),\n\n          querySelectorAll: NGN.define(false, false, false, function (selector) {\n            qs(value, selector, true);\n          }),\n\n          addEventListener: NGN.define(false, false, false, function (evt, fn) {\n            for (var el = 0; el < this.length; el++) {\n              this[el].addEventListener(evt, fn);\n            }\n          }),\n\n          removeEventListener: NGN.define(false, false, false, function (evt, fn) {\n            for (var el = 0; el < this.length; el++) {\n              this[el].removeEventListener(evt, fn);\n            }\n          }),\n\n          find: NGN.const(function (selector) {\n            return NGN.ref._find(value, selector);\n          }),\n\n          isArray: NGN.get(function () {\n            return true;\n          }, false),\n\n          forward: NGN.define(false, false, false, function (trigger, event) {\n            requireBUS(trigger, event, this, 'forward');\n          })\n        });\n        result = base;\n      }\n\n      return result;\n    }),\n\n    /**\n     * @method create\n     * Add a reference.\n     * @param {String} [key]\n     * The key/name of the reference. For example, if this is `myElement`,\n     * then `ref.myElement` will return a pointer to this reference.\n     * @param {string} selector\n     * The CSS selector path.\n     */\n    create: NGN.const(function (key, value) {\n      // If the key is not provided but the value is a DOM element, make\n      // an ephemeral reference.\n      if (!value && typeof key !== 'string') {\n        return this.find(key);\n      }\n\n      // Basic error checking\n      if (typeof key !== 'string' && typeof key !== 'number') {\n        throw new Error('Cannot add a non-alphanumeric selector reference.');\n      }\n      if (key.trim().length === 0) {\n        throw new Error('Cannot add a blank selector reference.');\n      }\n      if (value === undefined || value === null || value.trim().length === 0) {\n        throw new Error('Cannot create a null/undefined selector reference.');\n      }\n\n      // Create a reference object\n      var cleankey = this.cleanKey(key);\n      var me = this;\n      Object.defineProperty(NGN.ref, cleankey, NGN.private(value));\n\n      Object.defineProperty(NGN.ref, key, {\n        enumerable: true,\n        get: function get() {\n          return me.find(value);\n        },\n        set: function set(val) {\n          if (val === undefined || val === null || val.trim().length === 0) {\n            throw new Error('Cannot create a null/undefined selector reference.');\n          }\n          NGN.ref[cleankey] = val;\n        }\n      });\n\n      this.keys[key] = value;\n      this.keys[this.cleanKey(key)] = value;\n    }),\n\n    /**\n     * @method remove\n     * Removes a key from the reference manager.\n     */\n    remove: NGN.const(function (key) {\n      if (this[key]) {\n        delete this[key];\n        delete this.keys[key];\n      }\n      var ck = this.cleanKey(key);\n      if (this[ck]) {\n        delete this[ck];\n        delete this.keys[ck];\n      }\n    }),\n\n    /**\n     * @method cleanKey\n     * Creates a clean version of the key used to uniquely identify the reference.\n     * @private\n     * @param {String} key\n     * The key to clean.\n     */\n    cleanKey: NGN.define(false, false, false, function (key) {\n      return key.replace(/[^A-Za-z0-9\\_\\#\\$\\@\\-\\+]/gi, '') + key.length;\n    }),\n\n    /**\n     * @property json\n     * A JSON representation of the managed keys and their associated selectors.\n     * @returns {Object}\n     * A key:selector object.\n     */\n    json: {\n      enumerable: true,\n      get: function get() {\n        var me = this;\n        var obj = {};\n\n        Object.keys(this).forEach(function (el) {\n          if (me.hasOwnProperty(el) && ['json', 'find', 'remove'].indexOf(el.trim().toLowerCase()) < 0 && typeof me[el] !== 'function') {\n            obj[el] = me.keys[el];\n          }\n        });\n        return obj;\n      }\n    }\n  });\n}();\n\n/**\n * @class NGN.NET\n * A library to issue network requests, typically viaHTTP/S requests.\n * This acts as an AJAX library among other things.\n * @author Corey Butler\n * @singleton\n */\nvar parser = new DOMParser();\nvar fs = NGN.nodelike ? require('fs') : null;\n\nvar Network = function () {\n  function Network() {\n    _classCallCheck(this, Network);\n\n    Object.defineProperties(this, {\n      /**\n       * @method xhr\n       * Issue an XHR request.\n       * @private\n       * @param  {Function} callback\n       * The callback to execute when the request finishes (or times out.)\n       */\n      xhr: NGN.privateconst(function (callback) {\n        var res = void 0;\n\n        if (window.XMLHttpRequest) {\n          // code for IE7+, Firefox, Chrome, Opera, Safari\n          res = new XMLHttpRequest();\n        }\n\n        res.onreadystatechange = function () {\n          if (res.readyState === 4) {\n            if (callback) {\n              callback(res);\n            }\n          }\n        };\n\n        return res;\n      }),\n\n      /**\n       * @method run\n       * A wrapper to execute a request.\n       * @private\n       * @param  {string} method required\n       * The method to issue, such as GET, POST, PUT, DELETE, OPTIONS, etc.\n       * @param  {string} url\n       * The URL where the request is issued to.\n       * @param  {Function} callback\n       * A function to call upon completion.\n       */\n      run: NGN.privateconst(function (method, url, callback) {\n        var res = NGN.NET.xhr(callback);\n        res.open(method, url, true);\n        res.send();\n      }),\n\n      /**\n       * @method applyRequestSettings\n       * Apply any configuration details to issue with the request,\n       * such as `username`, `password`, `headers`, etc.\n       * @private\n       * @param {object} xhr\n       * The XHR request object.\n       * @param {object} cfg\n       * The key/value configuration object to apply to the request.\n       * @param {object} cfg.params\n       * A key/value object containing URL paramaters to be passed with the request.\n       * These will automatically be URI-encoded.\n       * @param {object} cfg.headers\n       * A key/value object containing additional headers and associated values to\n       * be passed with the request.\n       * @param {object} cfg.body\n       * An arbitrary body to pass with the request. If no `Content-Type` header is\n       * provided, a `Content-Type: application/textcharset=UTF-8` header is automatically supplied.\n       * This cannot be used with @cfg.json.\n       * @param {object} cfg.json\n       * A JSON object to be sent with the request. It will automatically be\n       * parsed for submission. By default, a `Content-Type: application/json`\n       * header will be applied (this can be overwritten using @cfg.headers).\n       * @param {object} cfg.form\n       * This accepts a key/value object of form elements, or a reference to a <FORM>\n       * HTML element. This automatically adds the appropriate headers.\n       * @param {string} username\n       * A basicauth username to add to the request. This is sent in plain\n       * text, so using SSL to encrypt/protect it is recommended.\n       * @param {string} password\n       * A basicauth password to add to the request. This is sent in plain\n       * text, so using SSL to encrypt/protect it is recommended.\n       * @param {boolean} [withCredentials=false]\n       * indicates whether or not cross-site `Access-Control` requests should be\n       * made using credentials such as cookies or authorization headers.\n       * The default is `false`.\n       */\n      applyRequestSettings: NGN.privateconst(function (xhr, cfg) {\n        if (!xhr || !cfg) {\n          throw new Error('No XHR or configuration object defined.');\n        }\n\n        // Add URL Parameters\n        if (cfg.params) {\n          var parms = Object.keys(cfg.params).map(function (parm) {\n            return parm + '=' + encodeURIComponent(cfg.params[parm]);\n          });\n          cfg.url += '?' + parms.join('&');\n        }\n\n        xhr.open(cfg.method || 'POST', cfg.url, true);\n\n        // Set headers\n        cfg.header = cfg.header || cfg.headers || {};\n        Object.keys(cfg.header).forEach(function (header) {\n          xhr.setRequestHeader(header, cfg.header[header]);\n        });\n\n        // Handle body (Blank, plain text, or JSON)\n        var body = null;\n        if (cfg.json) {\n          if (!cfg.header || cfg.header && !cfg.header['Content-Type']) {\n            xhr.setRequestHeader('Content-Type', 'application/json');\n          }\n          body = JSON.stringify(cfg.json).trim();\n        } else if (cfg.body) {\n          if (!cfg.header || cfg.header && !cfg.header['Content-Type']) {\n            xhr.setRequestHeader('Content-Type', 'application/text');\n          }\n          body = cfg.body;\n        } else if (cfg.form) {\n          body = new FormData();\n          Object.keys(cfg.form).forEach(function (el) {\n            body.append(el, cfg.form[el]);\n          });\n        }\n\n        // Handle withCredentials\n        if (cfg.withCredentials) {\n          xhr.withCredentials = cfg.withCredentials;\n        }\n\n        // Handle credentials sent with request\n        if (cfg.username && cfg.password) {\n          // Basic Auth\n          xhr.setRequestHeader('Authorization', 'Basic ' + btoa(cfg.username + ':' + cfg.password));\n        } else if (cfg.accessToken) {\n          // Bearer Auth\n          xhr.setRequestHeader('Authorization', 'Bearer ' + cfg.accessToken);\n        }\n\n        return body;\n      }),\n\n      /**\n       * @method prepend\n       * A helper method to prepend arguments.\n       * @private\n       * @param  {[type]} args [description]\n       * @param  {[type]} el   [description]\n       * @return {[type]}      [description]\n       */\n      prepend: NGN.privateconst(function (args, el) {\n        args = NGN.slice(args);\n        args.unshift(el);\n        return args;\n      }),\n\n      /**\n       * @method getFile\n       * A \"get\" method specifically for node-like environments.\n       * @param {string} url\n       * The URL to issue the request to.\n       * @param {Function} callback\n       * A callback method to run when the request is complete.\n       * This receives the response object as the only argument.\n       * @private\n       */\n      getFile: NGN.privateconst(function (url) {\n        if (fs !== null) {\n          var rsp = {\n            status: fs.existsSync(url.replace('file://', '')) ? 200 : 400\n          };\n          rsp.responseText = rsp.status === 200 ? fs.readFileSync(url.replace('file://', '')).toString() : 'File could not be found.';\n          return rsp;\n        } else {\n          throw new Error(url + ' does not exist or could not be found.');\n        }\n      }),\n\n      /**\n       * @method normalizeUrl\n       * Cleanup a URL.\n       * @private\n       */\n      normalizeUrl: NGN.privateconst(function (url) {\n        var uri = [];\n\n        url.split('/').forEach(function (el) {\n          if (el === '..') {\n            uri.pop();\n          } else if (el !== '.') {\n            uri.push(el);\n          }\n        });\n\n        return uri.join('/').replace(/\\:\\/{3,50}/gi, '://');\n      }),\n\n      /**\n       * @method processImport\n       * A helper class to process imported content and place\n       * it in the DOM accordingly.\n       * @param {string} url\n       * The URL of remote HTML snippet.\n       * @param {HTMLElement} target\n       * The DOM element where the resulting code should be appended.\n       * @param {string} callback\n       * Returns the HTMLElement, which can be directly inserted into the DOM.\n       * @param {HTMLElement} callback.element\n       * The new DOM element/NodeList.\n       * @param {boolean} [before=false]\n       * If set to true, insert before the callback.element.\n       * @private\n       */\n      processImport: NGN.privateconst(function (url, target, callback, before) {\n        before = before !== undefined ? before : false;\n        this.import(url, function (element) {\n          if (typeof element === 'string') {\n            element = document.createTextNode(element);\n          } else if (element.length) {\n            var _ret3 = function () {\n              var out = [];\n              NGN.slice(element).forEach(function (el) {\n                if (before) {\n                  out.push(target.parentNode.insertBefore(el, target));\n                  target = el;\n                } else {\n                  out.push(target.appendChild(el));\n                }\n              });\n              callback && callback(out);\n              return {\n                v: void 0\n              };\n            }();\n\n            if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n          }\n          if (before) {\n            target.parentNode.insertBefore(element, target);\n          } else {\n            target.appendChild(element);\n          }\n          callback && callback(element);\n        });\n      }),\n\n      /**\n       * @method domainRoot\n       * Returns the root (no http/s) of the URL.\n       * @param {string} url\n       * The URL to get the root of.\n       * @private\n       */\n      domainRoot: NGN.privateconst(function (url) {\n        var r = url.search(/^https?\\:\\/\\//) !== -1 ? url.match(/^https?\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i, '') : url.match(/^([^\\/?#]+)(?:[\\/?#]|$)/i, '');\n        return r === null || r[1].length < 3 ? window.location.host : r[1];\n      }),\n\n      /**\n       * @method isCrossOrigin\n       * Determine if accessing a URL is considered a cross origin request.\n       * @param {string} url\n       * The URL to identify as a COR.\n       * @returns {boolean}\n       * @private\n       */\n      isCrossOrigin: NGN.privateconst(function (url) {\n        return this.domainRoot(url) !== window.location.host;\n      }),\n\n      /**\n       * @method prelink\n       * A helper method to construct pre-fetch style DOM elements.\n       * This also fires an event when the element is added to the DOM.\n       * @param {string} url\n       * The URL of the operation.\n       * @param {string} rel\n       * The type of operation. For example: `preconnect`.\n       * @param {boolean} [crossorigin]\n       * Set to `true` to identify the request as a cross origin request.\n       * By default, NGN will compare the URL to the current URL in an\n       * attempt to determine if the request is across origins.\n       * @private\n       */\n      prelink: NGN.privateconst(function (url, rel, cor) {\n        if (!document.head) {\n          console.warn('Cannot use a preconnect, predns, etc because there is no HEAD in the HTML document.');\n          return;\n        }\n\n        var p = document.createElement('link');\n        p.rel = rel;\n        p.href = url.trim().toLowerCase().substr(0, 4) !== 'http' ? this.normalizeUrl(window.location.origin + window.location.pathname + url) : url;\n\n        NGN.coalesce(cor, this.isCrossOrigin(url)) && p.setAttribute('crossorigin', 'true');\n        document.head.appendChild(p);\n        NGN.BUS.emit('network.' + rel);\n      }),\n\n      importCache: NGN.private({}),\n\n      createElement: NGN.privateconst(function (str) {\n        return parser.parseFromString(str, 'text/html').querySelector('body').children;\n      }),\n\n      applyData: NGN.privateconst(function (tpl, data, callback) {\n        if (tpl === undefined) {\n          console.warn('Empty template.');\n          callback && callback();\n          return;\n        }\n\n        // Apply data to the template.\n        Object.keys(data).forEach(function (key) {\n          var re = new RegExp('\\{\\{' + key + '\\}\\}', 'gm');\n          tpl = tpl.replace(re, data[key]);\n        });\n\n        // Clear any unused template code\n        tpl = tpl.replace(/(\\{\\{.*\\}\\})/gm, '');\n\n        var el = this.createElement(tpl);\n        callback && callback(el[0]);\n      })\n    });\n  }\n\n  /**\n   * @method send\n   * Send the request via HTTP/S.\n   * @param  {object} cfg\n   * The configuration to use when sending the request. See @applyRequestSettings#cfg\n   * for configuration details.\n   * @param  {Function} callback\n   * A callback to excute upon completion. This receives a standard response\n   * object.\n   */\n\n\n  _createClass(Network, [{\n    key: 'send',\n    value: function send(cfg, callback) {\n      cfg = cfg || {};\n      var res = this.xhr(callback);\n      var body = this.applyRequestSettings(res, cfg);\n      res.send(body);\n    }\n\n    /**\n     * @method get\n     * Issue a `GET` request.\n     * @param {string} url\n     * The URL to issue the request to.\n     * @param {Function} callback\n     * A callback method to run when the request is complete.\n     * This receives the response object as the only argument.\n     */\n\n  }, {\n    key: 'get',\n    value: function get() {\n      if (_typeof(arguments[0]) === 'object') {\n        var cfg = arguments[0];\n        cfg.method = 'GET';\n        cfg.url = typeof arguments[1] === 'string' ? arguments[1] : cfg.url;\n        if (cfg.url.substr(0, 4) && NGN.nodelike) {\n          return arguments[arguments.length - 1](this.getFile(cfg.url));\n        }\n        return this.send(cfg, arguments[arguments.length - 1]);\n      }\n      if (arguments[0].substr(0, 4) === 'file' && NGN.nodelike) {\n        return arguments[arguments.length - 1](this.getFile(arguments[0]));\n      }\n      this.run.apply(this.run, this.prepend(arguments, 'GET'));\n    }\n\n    /**\n     * @method head\n     * Issue a `HEAD` request.\n     * @param {string} url\n     * The URL to issue the request to.\n     * @param {Function} callback\n     * A callback method to run when the request is complete.\n     * This receives the response object as the only argument.\n     */\n\n  }, {\n    key: 'head',\n    value: function head(uri, callback) {\n      if (_typeof(arguments[0]) === 'object') {\n        var cfg = arguments[0];\n        cfg.method = 'HEAD';\n        cfg.url = typeof arguments[1] === 'string' ? arguments[1] : cfg.url;\n        return this.send(cfg, arguments[arguments.length - 1]);\n      }\n      this.run.apply(this.run, this.prepend(arguments, 'HEAD'));\n    }\n\n    /**\n     * @method put\n     * Issue a `PUT` request.\n     * @param  {object} cfg\n     * See the options for @send#cfg\n     * @param  {Function} callback\n     * A callback method to run when the request is complete.\n     * This receives the response object as the only argument.\n     */\n\n  }, {\n    key: 'put',\n    value: function put(cfg, callback) {\n      cfg = cfg || {};\n      cfg.method = 'PUT';\n      cfg.url = cfg.url || window.location;\n      this.send(cfg, callback);\n    }\n\n    /**\n     * @method post\n     * Issue a `POST` request.\n     * @param  {object} cfg\n     * See the options for @send#cfg\n     * @param  {Function} callback\n     * A callback method to run when the request is complete.\n     * This receives the response object as the only argument.\n     */\n\n  }, {\n    key: 'post',\n    value: function post(cfg, callback) {\n      cfg = cfg || {};\n      cfg.method = 'POST';\n      cfg.url = cfg.url || window.location;\n      this.send(cfg, callback);\n    }\n\n    /**\n     * @method delete\n     * Issue a `DELETE` request.\n     * @param {string} url\n     * The URL to issue the request to.\n     * @param {Function} callback\n     * A callback method to run when the request is complete.\n     * This receives the response object as the only argument.\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      this.run.apply(this.run, this.prepend(arguments, 'DELETE'));\n    }\n\n    /**\n     * @method json\n     * This is a shortcut method for creating a `GET` request and\n     * auto-processing the response body into a JSON object.\n     * @param  {string} url\n     * The URL to issue the request to.\n     * @param  {Function} callback\n     * This receives a JSON response object from the server as its only argument.\n     */\n\n  }, {\n    key: 'json',\n    value: function json(cfg, url, callback) {\n      if (typeof cfg === 'string') {\n        callback = url;\n        url = cfg;\n        cfg = null;\n      }\n      if (cfg === null) {\n        this.run('GET', url, function (res) {\n          if (res.status !== 200) {\n            throw Error('Could not retrieve JSON data from ' + url + ' (Status Code: ' + res.status + ').');\n          }\n          try {\n            res.json = JSON.parse(res.responseText);\n          } catch (e) {\n            res.json = null;\n          }\n          callback && callback(res.json);\n        });\n      } else {\n        cfg.url = url;\n        this.get(cfg, function (res) {\n          if (res.status !== 200) {\n            throw Error('Could not retrieve JSON data from ' + url + ' (Status Code: ' + res.status + ').');\n          }\n          try {\n            res.json = JSON.parse(res.responseText);\n          } catch (e) {\n            res.json = null;\n          }\n          callback && callback(res.json);\n        });\n      }\n    }\n\n    /**\n     * @method import\n     * Import a remote HTML fragment.\n     * @param {string|array} url\n     * The URL of remote HTML snippet. If the URL has a `.js` or `.css`\n     * extension, it will automatically be added to the `<head>`.\n     * It is also possible to provide an array of string values. Take\n     * note that the callback may return a different value based on\n     * this input.\n     * @param {string|array} callback\n     * If a **string** is provided as the URL, this returns the HTMLElement,\n     * which can be directly inserted into the DOM. If an **array** is\n     * provided as the URL, the callback will return an array of HTMLElements.\n     * For example:\n     *\n     * ```js\n     * NGN.NET.import([\n     *   '/path/a.html',\n     *   '/path/b.html',\n     *   '/path/a.js'],\n     *    function (elements){\n     *      console.dir(elements)\n     *    }\n     * })\n     *```\n     * The result `elements` array would look like:\n     *\n     * ```js\n     * [\n     *   HTMLElement, // DOM element created for a.html\n     *   HTMLElement, // DOM element created for b.html\n     *   HTMLElement  // DOM element created for a.js (this will be in the <head>)\n     * ]\n     * ```\n     * The last array element is `null`\n     * @param {boolean} [bypassCache=false]\n     * When set to `true`, bypass the cache.\n     * @fires html.import\n     * Returns the HTMLElement/NodeList as an argument to the event handler.\n     */\n\n  }, {\n    key: 'import',\n    value: function _import(url, callback, bypassCache) {\n      var _this4 = this;\n\n      // Support multiple simultaneous imports\n      if (Array.isArray(url)) {\n        var _ret4 = function () {\n          var self = _this4;\n          var out = new Array(url.length);\n          var i = 0;\n          url.forEach(function (uri, num) {\n            self.import(uri, function (el) {\n              out[num] = el;\n              i++;\n            }, bypassCache);\n          });\n          if (callback) {\n            (function () {\n              var int = setInterval(function () {\n                if (i === url.length) {\n                  clearInterval(int);\n                  callback(out);\n                }\n              }, 5);\n            })();\n          }\n          return {\n            v: void 0\n          };\n        }();\n\n        if ((typeof _ret4 === 'undefined' ? 'undefined' : _typeof(_ret4)) === \"object\") return _ret4.v;\n      }\n\n      // Support JS/CSS\n      var ext = null;\n      try {\n        (function () {\n          ext = url.split('/').pop().split('?')[0].split('.').pop().toLowerCase();\n          var s = void 0;\n          if (ext === 'js') {\n            s = document.createElement('script');\n            s.setAttribute('type', 'text/javascript');\n            s.setAttribute('src', url);\n          } else if (ext === 'css') {\n            s = document.createElement('link');\n            s.setAttribute('rel', 'stylesheet');\n            s.setAttribute('type', 'text/css');\n            s.setAttribute('href', url);\n          }\n          s.onload = typeof callback === 'function' ? function () {\n            callback(s);\n          } : function () {};\n          document.getElementsByTagName('head')[0].appendChild(s);\n        })();\n      } catch (e) {}\n\n      if (['js', 'css'].indexOf((ext || '').trim().toLowerCase()) >= 0) {\n        return;\n      }\n\n      bypassCache = typeof bypassCache === 'boolean' ? bypassCache : false;\n\n      // If a local reference is provided, complete the path.\n      if (url.substr(0, 4) !== 'http') {\n        var path = window.location.href.split('/');\n        path.pop();\n        url = path.join('/') + '/' + url;\n      }\n\n      // Use the cache if defined & not bypassed\n      if (!bypassCache && this.importCache.hasOwnProperty(url)) {\n        var doc = this.createElement(this.importCache[url]);\n        callback && callback(doc.length === 1 ? doc[0] : doc);\n        if (window.NGN.BUS) {\n          window.NGN.BUS.emit('html.import', doc.length === 1 ? doc[0] : doc);\n        }\n        // console.warn('Used cached version of '+url)\n        return;\n      }\n\n      // Retrieve the file content\n      var me = this;\n      this.get(url, function (res) {\n        if (res.status !== 200) {\n          return console.warn('Check the file path of the snippet that needs to be imported. ' + url + ' could not be found (' + res.status + ')');\n        }\n\n        var doc = me.createElement(res.responseText);\n        me.importCache[url] = res.responseText;\n\n        if (doc.length === 0) {\n          console.warn(me.normalizeUrl(url) + ' import has no HTML tags.');\n          callback && callback(res.responseText);\n          if (window.NGN.BUS) {\n            window.NGN.BUS.emit('html.import', res.responseText);\n          }\n        } else {\n          var el = doc.length === 1 ? doc[0] : doc;\n          callback && callback(el);\n          if (window.NGN.BUS) {\n            window.NGN.BUS.emit('html.import', el);\n          }\n        }\n      });\n    }\n\n    /**\n     * @method importTo\n     * This helper method uses the #import method to retrieve an HTML\n     * fragment and insert it into the specified DOM element. This is\n     * the equivalent of using results of the #import to retrieve a\n     * snippet, then doing a `target.appendChild(importedElement)`.\n     * @param {string} url\n     * The URL of remote HTML snippet.\n     * @param {HTMLElement} target\n     * The DOM element where the resulting code should be appended.\n     * @param {string} callback\n     * Returns the HTMLElement, which can be directly inserted into the DOM.\n     * @param {HTMLElement} callback.element\n     * The new DOM element/NodeList.\n     */\n\n  }, {\n    key: 'importTo',\n    value: function importTo(url, target, callback) {\n      this.processImport(url, target, callback);\n    }\n\n    /**\n     * @method importBefore\n     * This helper method uses the #import method to retrieve an HTML\n     * fragment and insert it into the DOM before the target element. This is\n     * the equivalent of using results of the #import to retrieve a snippet,\n     * then doing a `target.parentNode.insertBefore(importedElement, target)`.\n     * @param {string} url\n     * The URL of remote HTML snippet.\n     * @param {HTMLElement} target\n     * The DOM element where the resulting code should be appended.\n     * @param {string} callback\n     * Returns the HTMLElement/NodeList, which can be directly inserted into the DOM.\n     * @param {HTMLElement} callback.element\n     * The new DOM element/NodeList.\n     */\n\n  }, {\n    key: 'importBefore',\n    value: function importBefore(url, target, callback) {\n      this.processImport(url, target, callback, true);\n    }\n\n    /**\n     * @method predns\n     * This notifies the browser domains which will be accessed at a later\n     * time. This helps the browser resolve DNS inquiries quickly.\n     * @param {string} domain\n     * The domain to resolve.\n     * @param {boolean} [crossorigin]\n     * Set to `true` to identify the request as a cross origin request.\n     * By default, NGN will compare the URL to the current URL in an\n     * attempt to determine if the request is across origins.\n     * @fires network-dns-prefetch\n     * Fired when a pre-fetched DNS request is issued to the browser.\n     */\n\n  }, {\n    key: 'predns',\n    value: function predns(domain, cor) {\n      this.prelink(window.location.protocol + '//' + domain, 'dns-prefetch', cor);\n    }\n\n    /**\n     * @method preconnect\n     * Tell the browser which remote resources will or may be used in the\n     * future by issuing a `Preconnect`. This will resolve DNS (#predns), make the TCP\n     * handshake, and negotiate TLS (if necessary). This can be done directly\n     * in HTML without JS, but this method allows you to easily preconnect\n     * a resource in response to a user interaction or NGN.BUS activity.\n     * @param {string} url\n     * The URL to preconnect to.\n     * @param {boolean} [crossorigin]\n     * Set to `true` to identify the request as a cross origin request.\n     * By default, NGN will compare the URL to the current URL in an\n     * attempt to determine if the request is across origins.\n     * @fires network.preconnect\n     * Fired when a preconnect is issued to the browser.\n     */\n\n  }, {\n    key: 'preconnect',\n    value: function preconnect(url, cor) {\n      this.prelink(url, 'preconnect', cor);\n    }\n\n    /**\n     * @method prefetch\n     * Fetch a specific resource and cache it.\n     * @param {string} url\n     * URL of the resource to download and cache.\n     * @param {boolean} [crossorigin]\n     * Set to `true` to identify the request as a cross origin request.\n     * By default, NGN will compare the URL to the current URL in an\n     * attempt to determine if the request is across origins.\n     * @fires network.prefetch\n     * Fired when a prefetch is issued to the browser.\n     */\n\n  }, {\n    key: 'prefetch',\n    value: function prefetch(url, cor) {\n      this.prelink(url, 'prefetch', cor);\n    }\n\n    /**\n     * @method subresource\n     * A prioritized version of #prefetch. This should be used\n     * if the asset is required for the current page. Think of this\n     * as \"needed ASAP\". Otherwise, use #prefetch.\n     * @param {string} url\n     * URL of the resource to download and cache.\n     * @param {boolean} [crossorigin]\n     * Set to `true` to identify the request as a cross origin request.\n     * By default, NGN will compare the URL to the current URL in an\n     * attempt to determine if the request is across origins.\n     * @fires network.prefetch\n     * Fired when a prefetch is issued to the browser.\n     */\n\n  }, {\n    key: 'subresource',\n    value: function subresource(url, cor) {\n      this.prelink(url, 'subresource', cor);\n    }\n\n    /**\n     * @method prerender\n     * Prerender an entire page. This behaves as though a page is\n     * opened in a hidden tab, then displayed when called. This is\n     * powerful, but should only be used when there is absolute\n     * certainty that the prerendered page will be needed. Otherwise\n     * all of the assets are loaded for no reason (i.e. uselessly\n     * consuming bandwidth).\n     * @param {string} url\n     * URL of the page to download and cache.\n     * @param {boolean} [crossorigin]\n     * Set to `true` to identify the request as a cross origin request.\n     * By default, NGN will compare the URL to the current URL in an\n     * attempt to determine if the request is across origins.\n     * @fires network.prerender\n     * Fired when a prerender is issued to the browser.\n     */\n\n  }, {\n    key: 'prerender',\n    value: function prerender(url, cor) {\n      this.prelink(url, 'prerender', cor);\n    }\n\n    /**\n     * @method template\n     * Include a simple letiable replacement template and apply\n     * values to it. This is always cached client side.\n     * @param {string} url\n     * URL of the template to retrieve.\n     * @param {object} [letiables]\n     * A key/value objct containing letiables to replace in\n     * the template.\n     * @param {function} callback\n     * The callback receives a single argument with the HTMLElement/\n     * NodeList generated by the template.\n     */\n\n  }, {\n    key: 'template',\n    value: function template(url, data, callback) {\n      url = this.normalizeUrl(url);\n\n      if (typeof data === 'function') {\n        callback = data;\n        data = {};\n      }\n\n      data = data || {};\n\n      var me = this;\n      var tpl = void 0;\n\n      // Check the cache\n      if (this.importCache.hasOwnProperty(url)) {\n        tpl = this.importCache[url];\n        return this.applyData(tpl, data, callback);\n      }\n\n      this.get(url, function (res) {\n        var ext = null;\n        try {\n          ext = url.split('/').pop().split('?')[0].split('.').pop().toLowerCase();\n        } catch (e) {}\n        if (['js', 'css'].indexOf((ext || '').trim().toLowerCase()) >= 0) {\n          console.warn('Cannot use a .' + ext + ' file as a template. Only HTML templates are supported.');\n          return;\n        }\n\n        me.importCache[url] = res.responseText;\n        me.applyData(res.responseText, data, callback);\n      });\n    }\n  }]);\n\n  return Network;\n}();\n\nNGN.NET = new Network();\n\n/**\n * @class NGN.DOM.svg\n * Provides a way to easily manage SVG images within a document while\n * retaining the ability to style them with external CSS.\n * @singleton\n */\n/* This file should be loaded in the <head>, not at the end of the <body>.\n* By loading this script before the rest of the DOM, it will insert the\n* FOUC (Flash of Unstyled Content) CSS into the page BEFORE unstyled SVG images\n* are loaded. If this script is included in the <body>, the CSS will be loaded\n* AFTER the SVG images are loaded, meaning they may display briefly before\n* proper styling can be applied to the DOM.\n*/\n\n// Prevent FOUC\n// (function () {\n//   let ss = document.createElement('style')\n//   let str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}')\n//   ss.appendChild(str)\n//   document.head.appendChild(ss)\n// })()\nvar fuoc = function fuoc() {\n  var ss = document.createElement('style');\n  var str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}');\n  ss.appendChild(str);\n  document.head.appendChild(ss);\n};\nfuoc();\n\n// SVG Controller\nNGN.DOM = NGN.DOM || {};\nNGN.DOM.svg = {};\n\nObject.defineProperties(NGN.DOM.svg, {\n  /**\n   * @property {Object} _cache\n   * A cache of SVG images.\n   */\n  _cache: NGN.private({}),\n\n  /**\n   * @method swap\n   * Replace image tags with the SVG equivalent.\n   * @param {HTMLElement|NodeList} imgs\n   * The HTML element or node list containing the images that should be swapped out for SVG files.\n   * @param {function} [callback]\n   * Executed when the image swap is complete. There are no arguments passed to the callback.\n   * @private\n   */\n  swap: NGN.privateconst(function (svgs, callback) {\n    var me = this;\n    for (var i = 0; i < svgs.length; i++) {\n      var attr = svgs[i].attributes;\n      var output = me._cache[svgs[i].getAttribute('src')];\n      var attrs = [];\n\n      try {\n        attrs = /<svg(\\s.*=[\\\"\\'].*?[\\\"\\'])?>/i.exec(output)[1].trim();\n        var sep = /[\\\"\\']\\s/i.exec(attrs);\n        sep = sep !== null ? sep[0] : '\\\" ';\n        attrs = attrs.replace(new RegExp(sep, 'gi'), sep.replace(/\\s/ig, ',')).split(',');\n      } catch (e) {\n        console.error(e);\n      }\n\n      attrs = Array.isArray(attrs) ? attrs : [attrs];\n\n      var map = attrs.map(function (els) {\n        return els.split('=')[0].trim().toLowerCase();\n      });\n\n      for (var x = 0; x < attr.length; x++) {\n        var idx = map.indexOf(attr[x].name.toLowerCase());\n        if (idx < 0) {\n          attrs.push(attr[x].name + '=\"' + attr[x].value + '\"');\n        } else {\n          attrs[idx] = attr[x].name + '=\"' + attr[x].value + '\"';\n        }\n      }\n\n      attrs = attrs.filter(function (a) {\n        return a.split('=')[0].toLowerCase() !== 'src';\n      });\n\n      var svg = '<svg ' + attrs.join(' ') + '>';\n\n      svgs[i].outerHTML = output.replace(/<svg.*?>/i, svg);\n    }\n\n    callback && callback();\n  }),\n\n  /**\n   * @method id\n   * @param  {string} url\n   * Create an ID that can be used to reference an SVG symbol.\n   * @return {string}\n   * @private\n   */\n  id: NGN.privateconst(function (url) {\n    return url.replace(/.*\\:\\/\\/|[^A-Za-z0-9]|www/gi, '');\n  }),\n\n  /**\n   * @method cleanCode\n   * Captures all of the content between the <svg></svg> tag.\n   * @param  {string} code\n   * The code to clean up.\n   * @return {string}\n   * @private\n   */\n  cleanCode: NGN.privateconst(function (code) {\n    try {\n      return code.toString().trim().replace(/(\\r\\n|\\n|\\r)/gm, '').replace(/\\s+/g, ' ').match(/\\<svg.*\\<\\/svg\\>/igm, '')[0];\n    } catch (e) {\n      return '';\n    }\n  }),\n\n  /**\n   * @method viewbox\n   * Retrieves the viewbox attribute from the source code.\n   * @param  {string} code\n   * The code to extract the viewbox attribute from.\n   * @return {string}\n   * @private\n   */\n  viewbox: NGN.privateconst(function (code) {\n    return (/(viewbox=[\"'])(.*?)([\"'])/igm.exec(code.toString().trim())[2] || '0 0 100 100'\n    );\n  }),\n\n  cache: NGN.private(function (url, svg) {\n    this._cache[url] = svg;\n  }),\n\n  fetchFile: NGN.private(function (url, callback) {\n    var _this5 = this;\n\n    if (!callback) {\n      return;\n    }\n\n    if (!NGN.nodelike || url.indexOf('http') === 0) {\n      (function () {\n        var me = _this5;\n        NGN.NET.get(url, function (res) {\n          callback && callback(res.status !== 200 ? new Error(res.responseText) : me.cleanCode(res.responseText));\n        });\n      })();\n    } else {\n      var content = '';\n\n      try {\n        content = require('fs').readFileSync(require('path').resolve(url).replace('file://', '')).toString();\n      } catch (e) {\n        try {\n          content = require('fs').readFileSync(require('path').resolve(__dirname, url).replace('file://', '')).toString();\n        } catch (ee) {}\n      }\n\n      callback(content);\n    }\n  }),\n\n  /**\n   * @method update\n   * Replace any <img src=\"*.svg\"> with the SVG equivalent.\n   * @param {HTMLElement|NodeList} section\n   * The HTML DOM element to update. All children of this element will also be updated.\n   * @param {function} callback\n   * Execute this function after the update is complete.\n   */\n  update: NGN.const(function (section, callback) {\n    if (typeof section === 'function') {\n      callback = section;\n      section = document.body;\n    } else {\n      section = section || document.body;\n    }\n\n    if (section.nodeName === '#text') {\n      return;\n    }\n\n    var me = this;\n    section = section.hasOwnProperty('length') === true ? NGN._splice(section) : [section];\n\n    section.forEach(function (sec) {\n      var imgs = sec.querySelectorAll('svg[src]');\n\n      // Loop through images, prime the cache.\n      for (var i = 0; i < imgs.length; i++) {\n        me._cache[imgs[i].getAttribute('src')] = me._cache[imgs[i].getAttribute('src')] || null;\n      }\n\n      // Fetch all of the unrecognized svg files\n      var unfetched = Object.keys(me._cache).filter(function (url) {\n        return me._cache[url] === null;\n      });\n\n      var remaining = unfetched.length;\n      unfetched.forEach(function (url) {\n        me.fetchFile(url, function (content) {\n          if (!(content instanceof Error)) {\n            me.cache(url, content);\n          }\n          remaining--;\n        });\n      });\n\n      // Monitor for download completion\n      var monitor = setInterval(function () {\n        if (remaining === 0) {\n          clearInterval(monitor);\n          me.swap(imgs, callback);\n        }\n      }, 5);\n    });\n  })\n});\n\n'use strict';\n\nNGN.DATA = NGN.DATA || {};\nNGN.DATA.util = {};\n\nObject.defineProperties(NGN.DATA.util, {\n  // CRC table for checksum (cached)\n  crcTable: NGN.private(null),\n\n  /**\n   * @method makeCRCTable\n   * Generate the CRC table for checksums. This is a fairly complex\n   * operation that should only be executed once and cached for\n   * repeat use.\n   * @private\n   */\n  makeCRCTable: NGN.privateconst(function () {\n    var c = void 0;\n    var crcTable = [];\n    for (var n = 0; n < 256; n++) {\n      c = n;\n      for (var k = 0; k < 8; k++) {\n        c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;\n      }\n      crcTable[n] = c;\n    }\n    return crcTable;\n  }),\n\n  /**\n   * @method checksum\n   * Create the checksum of the specified string.\n   * @param  {string} content\n   * The content to generate a checksum for.\n   * @return {string}\n   * Generates a checksum value.\n   */\n  checksum: NGN.const(function (str) {\n    var crcTable = this.crcTable || (this.crcTable = this.makeCRCTable());\n    var crc = 0 ^ -1;\n\n    for (var i = 0; i < str.length; i++) {\n      crc = crc >>> 8 ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];\n    }\n\n    return (crc ^ -1) >>> 0;\n  }),\n\n  /**\n   * @method GUID\n   * Generate  a globally unique identifier.\n   *\n   * This is a \"fast\" GUID generator, designed to work in the browser.\n   * The likelihood of an ID collision is 1:3.26x10^15 (1 in 3.26 Quadrillion),\n   * and it will generate the ID between approximately 105ms (Desktop) and 726ms\n   * (Android) as of May 2016. This code came from StackOverflow, courtesy of\n   * an answer from Jeff Ward.\n   * @return {string}\n   * Returns a V4 GUID.\n   */\n  GUID: NGN.const(function () {\n    var lut = [];\n    for (var i = 0; i < 256; i++) {\n      lut[i] = (i < 16 ? '0' : '') + i.toString(16);\n    }\n\n    var d0 = Math.random() * 0xffffffff | 0;\n    var d1 = Math.random() * 0xffffffff | 0;\n    var d2 = Math.random() * 0xffffffff | 0;\n    var d3 = Math.random() * 0xffffffff | 0;\n\n    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff];\n  })\n});\n\n'use strict';\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nvar Model = function (_NGN$EventEmitter) {\n  _inherits(Model, _NGN$EventEmitter);\n\n  function Model(config) {\n    _classCallCheck(this, Model);\n\n    config = config || {};\n\n    var _this6 = _possibleConstructorReturn(this, (Model.__proto__ || Object.getPrototypeOf(Model)).call(this));\n\n    var me = _this6;\n\n    Object.defineProperties(_this6, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields || {\n        id: {\n          required: true,\n          type: String,\n          'default': config.id || null\n        }\n      }),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isRecordDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[_this6.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @cfgproperty {Date|Number} [expires]\n       * When this is set to a date/time, the model record will be marked\n       * as expired at the specified time/date. If a number is specified\n       * (milliseconds), the record will be marked as expired after the\n       * specified time period has elapsed. When a record/model is marked as\n       * \"expired\", it triggers the `expired` event. By default, expired\n       * records/models within an NGN.DATA.Store will be removed from the store.\n       *\n       * Setting this to any value less than `0` disables expiration.\n       * @fires expired\n       * Triggered when the model/record expires.\n       */\n      expiration: NGN.private(null),\n\n      // Used to hold a setTimeout method for expiration events.\n      expirationTimeout: NGN.private(null),\n\n      // Placeholder expiration flag.\n      hasExpired: NGN.private(false),\n\n      // Used to prevent expiration of a record.\n      ignoreTTL: NGN.private(false),\n\n      /**\n       * @property {Number} created\n       * The date/time when the model is created. This is represented as\n       * the number of milliseconds since the epoch (Jan 1, 1970, 00:00:00 UTC).\n       * @private\n       */\n      createDate: NGN.privateconst(Date.now()),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum;\n        this.changelog = [];\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function min(minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse();\n          }\n\n          return false;\n        },\n\n        max: function max(maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse();\n          }\n\n          return false;\n        },\n\n        enum: function _enum(valid, value) {\n          return valid.indexOf(value) >= 0;\n        },\n\n        required: function required(field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null;\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    });\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    var allfields = _this6.datafields.concat(_this6.virtualdatafields).concat(_this6.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i;\n    });\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.');\n    }\n\n    // Make sure an ID reference is available.\n    if (!_this6.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      };\n    }\n\n    // Add fields\n    Object.keys(_this6.fields).forEach(function (field) {\n      if (_typeof(me.fields[field]) !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        };\n      }\n      me.addField(field, true);\n    });\n\n    // Add virtuals\n    Object.keys(_this6.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me);\n      }));\n    });\n\n    // Add relationships\n    Object.keys(_this6.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true);\n    });\n\n    var events = ['field.update', 'field.create', 'field.remove', 'field.invalid', 'validator.add', 'validator.remove', 'relationship.create', 'relationship.remove', 'expired', 'deleted'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.push(me);\n          args.unshift(eventName);\n          NGN.BUS.emit.apply(NGN.BUS, args);\n        });\n      });\n    }\n\n    // If an expiration is defined, set it.\n    if (config.hasOwnProperty('expires')) {\n      _this6.expires = config.expires;\n    }\n    return _this6;\n  }\n\n  _createClass(Model, [{\n    key: 'expire',\n\n\n    /**\n     * @method expire\n     * Forcibly expire the model/record.\n     * @param {Date|Number} [duration]\n     * Optionally provide a new expiration time. This is an alternative\n     * way of setting #expires. If no value is specified, the record\n     * will immediately be marked as `expired`.\n     */\n    value: function expire(duration) {\n      if (this.expired) {\n        return;\n      }\n\n      if (duration) {\n        this.expires = duration;\n        return;\n      }\n\n      if (this.ignoreTTL) {\n        return;\n      }\n\n      // Force expiration.\n      this.hasExpired = true;\n\n      clearTimeout(this.expirationTimeout);\n\n      this.emit('expired', this);\n    }\n\n    /**\n     * @method disableExpiration\n     * Do not expire this model/record.\n     */\n\n  }, {\n    key: 'disableExpiration',\n    value: function disableExpiration() {\n      this.expires = -1;\n    }\n\n    /**\n      * @method addValidator\n      * Add or update a validation rule for a specific model property.\n      * @param {String} field\n      * The data field to test.\n      * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n      * The validation used to test the property value. This should return\n      * `true` when the data is valid and `false` when it is not.\n      *\n      * * When this is a _function_, the value is passed to it as an argument.\n      * * When this is a _String_, the value is compared for an exact match (case sensitive)\n      * * When this is a _Number_, the value is compared for equality.\n      * * When this is a _Date_, the value is compared for exact equality.\n      * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n      * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n      * * When this is _an array of dates_, the value is compared to each date for equality.\n      * @fires validator.add\n      */\n\n  }, {\n    key: 'addValidator',\n    value: function addValidator(property, validator) {\n      if (!this.hasOwnProperty(property)) {\n        console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '');\n        return;\n      }\n\n      switch (typeof validator === 'undefined' ? 'undefined' : _typeof(validator)) {\n        case 'function':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(validator);\n          this.emit('validator.add', property);\n          break;\n        case 'object':\n          if (Array.isArray(validator)) {\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.indexOf(value) >= 0;\n            });\n            this.emit('validator.add', property);\n          } else if (validator.test) {\n            // RegExp\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.test(value);\n            });\n            this.emit('validator.add', property);\n          } else {\n            console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n          }\n          break;\n        case 'string':\n        case 'number':\n        case 'date':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(function (value) {\n            return value === validator;\n          });\n          this.emit('validator.add', property);\n          break;\n        default:\n          console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n      }\n    }\n\n    /**\n      * @method removeValidator\n      * Remove a data validator from the object.\n      * @param {String} attribute\n      * The name of the attribute to remove from the validators.\n      * @fires validator.remove\n      */\n\n  }, {\n    key: 'removeValidator',\n    value: function removeValidator(attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        delete this.validators[attribute];\n        this.emit('validator.remove', attribute);\n      }\n    }\n\n    /**\n      * @method validate\n      * Validate one or all attributes of the data.\n      * @param {String} [attribute=null]\n      * Validate a specific attribute. By default, all attributes are tested.\n      * @private\n      * @returns {Boolean}\n      * Returns true or false based on the validity of data.\n      */\n\n  }, {\n    key: 'validate',\n    value: function validate(attribute) {\n      // If validation is turned off, treat everything as valid.\n      if (!this.validation) {\n        return true;\n      }\n      var me = this;\n\n      // Single Attribute Validation\n      if (attribute) {\n        if (this.validators.hasOwnProperty(attribute)) {\n          for (var i = 0; i < this.validators[attribute].length; i++) {\n            if (!me.validators[attribute][i].apply(me, [me[attribute]])) {\n              me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute);\n              return false;\n            } else {\n              me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n                return attribute !== attr;\n              });\n            }\n          }\n\n          if (!this.validateDataType(attribute)) {\n            this.invalidDataAttributes.push(attribute);\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      // Validate data type of each attribute\n      this.datafields.forEach(function (field) {\n        me.validate(field);\n      });\n    }\n\n    /**\n     * @method validateDataType\n     * Indicates the data types match.\n     * @param {string} fieldname\n     * Name of the field whose data should be validated.\n     * @private\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'validateDataType',\n    value: function validateDataType(field) {\n      var fieldType = NGN.typeof(this[field]);\n      var expectedType = NGN.typeof(this.fields[field].type);\n\n      if (fieldType !== 'null') {\n        return fieldType === expectedType;\n      }\n\n      if (this[field] === null && this.fields[field].required) {\n        if (this.autoid && field === this.idAttribute) {\n          return true;\n        }\n\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * @method getRelationshipField\n     * Provides specific detail/configuration about a join/relationship.\n     * @param {String} fieldname\n     * The name of the field.\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'getRelationshipField',\n    value: function getRelationshipField(fieldname) {\n      return this.joins[fieldname];\n    }\n\n    /**\n     * @method hasRelationship\n     * Indicates a data join exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasRelationship',\n    value: function hasRelationship(fieldname) {\n      return this.joins.hasOwnProperty(fieldname);\n    }\n\n    /**\n       * @method getDataField\n       * Provides specific detail/configuration about a field.\n       * @param {String} fieldname\n       * The name of the data field.\n       * @returns {Object}\n       */\n\n  }, {\n    key: 'getDataField',\n    value: function getDataField(fieldname) {\n      return this.fields[fieldname];\n    }\n\n    /**\n     * @method hasDataField\n     * Indicates a data field exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasDataField',\n    value: function hasDataField(fieldname) {\n      return this.fields.hasOwnProperty(fieldname);\n    }\n\n    /**\n      * @method serialize\n      * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n      * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n      *\n      * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n      * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n      *\n      * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n      * The model itself can be returned using #getXRef.\n      * @param {Object} [obj]\n      * Defaults to this object.\n      * @protected\n      */\n\n  }, {\n    key: 'serialize',\n    value: function serialize(obj) {\n      var _obj = obj || this.raw;\n      var rtn = {};\n\n      for (var key in _obj) {\n        _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || '';\n        if (this.fields.hasOwnProperty(key)) {\n          key = key === 'id' ? this.idAttribute : key;\n          if (_obj.hasOwnProperty(key) && _obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)) || _obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0) {\n            var dsc = Object.getOwnPropertyDescriptor(_obj, key);\n            if (!dsc.set) {\n              // Handle everything else\n              switch (_typeof(dsc.value)) {\n                case 'function':\n                  // Support date & regex proxies\n                  if (dsc.value.name === 'Date') {\n                    rtn[key] = _obj[key].refs.toJSON();\n                  } else if (dsc.value.name === 'RegExp') {\n                    rtn[key] = dsc.value();\n                  }\n                  break;\n                case 'object':\n                  // Support array proxies\n                  if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                    _obj[key] = _obj[key].slice(0);\n                  }\n\n                  rtn[key] = _obj[key];\n                  break;\n                default:\n                  rtn[key] = _obj[key];\n                  break;\n              }\n            }\n          }\n        }\n      }\n\n      var me = this;\n      this.relationships.forEach(function (r) {\n        rtn[r] = me.rawjoins[r].data;\n      });\n\n      return rtn;\n    }\n\n    /**\n     * @method addField\n     * Add a data field after the initial model definition.\n     * @param {string} fieldname\n     * The name of the field.\n     * @param {object} [fieldConfiguration=null]\n     * The field configuration (see cfg#fields for syntax).\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addField',\n    value: function addField(field, fieldcfg, suppressEvents) {\n      if (typeof fieldcfg === 'boolean') {\n        suppressEvents = fieldcfg;\n        fieldcfg = null;\n      }\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      var me = this;\n      var cfg = null;\n\n      if (field.toLowerCase() !== 'id') {\n        if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object') {\n          if (!field.name) {\n            throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.');\n          }\n\n          cfg = field;\n          field = cfg.name;\n          delete cfg.name;\n        }\n\n        if (me[field] !== undefined) {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '');\n          }\n\n          delete me[field];\n        }\n\n        // Create the data field as an object attribute & getter/setter\n        me.fields[field] = cfg || me.fields[field] || {};\n        me.fields[field].required = NGN.coalesce(me.fields[field].required, false);\n\n        if (!me.fields[field].hasOwnProperty('type')) {\n          if (me.fields[field].hasOwnProperty('default')) {\n            var type = NGN.typeof(me.fields[field].default);\n            type = type.charAt(0).toUpperCase() + type.slice(1);\n            me.fields[field].type = eval(type);\n          }\n        }\n        me.fields[field].type = NGN.coalesce(me.fields[field].type, String);\n        if (field === me.idAttribute && me.autoid === true) {\n          me.fields[field].type = String;\n          me.fields[field]['default'] = NGN.DATA.util.GUID();\n        } else {\n          me.fields[field]['default'] = me.fields[field]['default'] || null;\n        }\n        me.raw[field] = me.fields[field]['default'];\n        me[field] = me.raw[field];\n\n        Object.defineProperty(me, field, {\n          get: function get() {\n            return me.raw[field];\n          },\n          set: function set(value) {\n            var old = me.raw[field];\n            var wasInvalid = !me.validate(field);\n\n            // if (old === value) {\n            //   console.log('HIT')\n            //   return\n            // } else if (me.fields[field].type === Object && typeof value === 'object') {\n            //   if (JSON.stringify(old) === JSON.stringify(value)) {\n            //     return\n            //   }\n            // }\n\n            me.raw[field] = value;\n\n            var c = {\n              action: 'update',\n              field: field,\n              old: old,\n              new: me.raw[field]\n            };\n\n            this.changelog.push(c);\n            this.emit('field.update', c);\n            this.emit('field.update.' + field, c);\n\n            // If the field is invalid, fire event.\n            if (!me.validate(field)) {\n              me.emit('field.invalid', {\n                field: field\n              });\n            } else if (wasInvalid) {\n              // If the field BECAME valid (compared to prior value),\n              // emit an event.\n              me.emit('field.valid', {\n                field: field\n              });\n            }\n          }\n        });\n\n        if (!suppressEvents) {\n          var c = {\n            action: 'create',\n            field: field\n          };\n          this.changelog.push(c);\n          this.emit('field.create', c);\n        }\n\n        // Add field validators\n        if (me.fields.hasOwnProperty(field)) {\n          if (me.fields[field].hasOwnProperty('pattern')) {\n            me.addValidator(field, me.fields[field].pattern);\n          }\n          ['min', 'max', 'enum'].forEach(function (v) {\n            if (me.fields[field].hasOwnProperty(v)) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators[v](me.fields[field][v], val);\n              });\n            }\n          });\n          if (me.fields[field].hasOwnProperty('required')) {\n            if (me.fields[field].required) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators.required(field, val);\n              });\n            }\n          }\n          if (me.fields[field].hasOwnProperty('validate')) {\n            if (typeof me.fields[field].validate === 'function') {\n              me.addValidator(field, function (val) {\n                return me.fields[field].validate.apply(me, [val]);\n              });\n            } else {\n              var _source = NGN.stack.pop();\n              console.warn('Invalid custom validation function (in %c' + _source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '');\n            }\n          }\n        }\n      } else if (me.id === null && me.autoid) {\n        me.id = NGN.DATA.util.GUID();\n      }\n    }\n\n    /**\n     * @method addVirtual\n     * Add a virtual field dynamically.\n     * @param {string} name\n     * The name of the attribute to add.\n     * @param {function} handler\n     * The synchronous method (or generator) that produces\n     * the desired output.\n     */\n\n  }, {\n    key: 'addVirtual',\n    value: function addVirtual(name, fn) {\n      var me = this;\n      Object.defineProperty(this, name, {\n        get: function get() {\n          return fn.apply(me);\n        }\n      });\n    }\n\n    /**\n     * @method addRelationshipField\n     * Join another model dynamically.\n     * @param {string} name\n     * The name of the field to add.\n     * @param {Object|NGN.DATA.Model} config\n     * The configuration or data model type. This follows the same syntax\n     * defined in the #joins attribute.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addRelationshipField',\n    value: function addRelationshipField(name, cfg, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n\n      if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n        throw new Error(name + ' already exists. It cannot be added to the model again.');\n      }\n\n      if (typeof cfg === 'function' || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object' && !cfg.hasOwnProperty('type')) {\n        cfg = {\n          type: cfg\n        };\n      }\n\n      if (!cfg.type) {\n        throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.');\n      }\n\n      cfg.required = NGN.coalesce(cfg.required, true);\n      cfg.default = cfg.default || null;\n\n      var me = this;\n      var entityType = 'model';\n\n      if (cfg.type instanceof NGN.DATA.Store) {\n        entityType = 'store';\n      } else if (NGN.typeof(cfg.type) === 'array') {\n        if (cfg.type.length === 0) {\n          throw new Error(name + ' cannot be an empty store. A model must be provided.');\n        }\n\n        entityType = 'collection';\n      } else if (_typeof(cfg.type) === 'object') {\n        if (cfg.type.model) {\n          entityType = 'store';\n        }\n      }\n\n      if (entityType === 'store') {\n        var storeCfg = {};\n        if (cfg.type instanceof NGN.DATA.Store) {\n          this.rawjoins[name] = cfg.type;\n          storeCfg = null;\n        } else if (cfg.type.model) {\n          storeCfg = cfg.type;\n        } else {\n          throw new Error('Nested store configuration is invalid or was not recognized.');\n        }\n\n        if (storeCfg !== null) {\n          this.rawjoins[name] = new NGN.DATA.Store(storeCfg);\n        }\n        this.applyStoreMonitor(name);\n      } else if (entityType === 'collection') {\n        this.rawjoins[name] = new NGN.DATA.Store({\n          model: cfg.type[0]\n        });\n        this.applyStoreMonitor(name);\n      } else if (!cfg.type.data) {\n        this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type(); // eslint-disable-line new-cap\n        this.applyModelMonitor(name);\n      } else if (cfg.type.data) {\n        this.rawjoins[name] = cfg.type;\n        this.applyStoreMonitor(name);\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.');\n      }\n\n      Object.defineProperty(this, name, {\n        enumerable: true,\n        get: function get() {\n          return me.rawjoins[name];\n        }\n      });\n\n      if (!suppressEvents) {\n        var c = {\n          action: 'create',\n          field: name\n        };\n        this.changelog.push(c);\n        this.emit('relationship.create', c);\n      }\n    }\n\n    /**\n     * @method applyModelMonitor\n     * Applies event handlers for bubbling model events.\n     * @param {string} field\n     * The relationship field name.\n     * @private\n     */\n\n  }, {\n    key: 'applyModelMonitor',\n    value: function applyModelMonitor(name) {\n      var model = this.rawjoins[name];\n      var me = this;\n\n      model.on('field.update', function (delta) {\n        var payload = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.old,\n          new: delta.new,\n          join: true,\n          originalEvent: {\n            event: 'field.update',\n            record: model\n          }\n        };\n\n        me.emit('field.update', payload);\n        me.emit('field.update.' + name + '.' + delta.field, payload);\n      });\n\n      model.on('field.create', function (delta) {\n        var payload = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: null,\n          new: null,\n          join: true,\n          originalEvent: {\n            event: 'field.create',\n            record: model\n          }\n        };\n\n        me.emit('field.update', payload);\n        me.emit('field.update.' + name + '.' + delta.field, payload);\n      });\n\n      model.on('field.remove', function (delta) {\n        var payload = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.value,\n          new: null,\n          join: true,\n          originalEvent: {\n            event: 'field.remove',\n            record: model\n          }\n        };\n\n        me.emit('field.update', payload);\n        me.emit('field.update.' + name + '.' + delta.field, payload);\n      });\n\n      model.on('field.invalid', function (data) {\n        me.emit('field.invalid');\n        me.emit('field.invalid.' + name + '.' + data.field);\n      });\n\n      model.on('field.valid', function (data) {\n        me.emit('field.valid');\n        me.emit('field.valid.' + name + '.' + data.field);\n      });\n    }\n\n    /**\n     * @method applyStoreMonitor\n     * Applies event handlers for store data.\n     * @param {string} name\n     * Name of the raw join.\n     * @private\n     */\n\n  }, {\n    key: 'applyStoreMonitor',\n    value: function applyStoreMonitor(name) {\n      var _this7 = this;\n\n      if (!this.rawjoins.hasOwnProperty(name)) {\n        return;\n      }\n\n      if (this.rawjoins[name].hasOwnProperty('proxy')) {\n        (function () {\n          var me = _this7;\n\n          _this7.rawjoins[name].on('record.create', function (record) {\n            var old = me[name].data;\n            old.pop();\n\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data,\n              originalEvent: {\n                event: 'record.create',\n                record: record\n              }\n            };\n\n            me.emit('field.update', c);\n            me.emit('field.update.' + name, c);\n          });\n\n          _this7.rawjoins[name].on('record.update', function (record, delta) {\n            if (!delta) {\n              return;\n            }\n\n            var c = {\n              action: 'update',\n              field: name + '.' + delta.field,\n              join: true,\n              old: delta.old,\n              new: delta.new,\n              originalEvent: {\n                event: 'record.update',\n                record: record\n              }\n            };\n\n            me.emit('field.update', c);\n            me.emit('field.update.' + name + '.' + delta.field, c);\n          });\n\n          _this7.rawjoins[name].on('record.delete', function (record) {\n            var old = me[name].data;\n            old.push(record.data);\n\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data,\n              originalEvent: {\n                event: 'record.delete',\n                record: record\n              }\n            };\n\n            me.emit('field.update', c);\n            me.emit('field.update.' + name, c);\n          });\n\n          _this7.rawjoins[name].on('record.invalid', function (data) {\n            me.emit('field.invalid', data.field);\n            me.emit('field.invalid.' + name, data.field);\n          });\n\n          _this7.rawjoins[name].on('record.valid', function (data) {\n            me.emit('field.valid', data.field);\n            me.emit('field.valid.' + name, data.field);\n          });\n        })();\n      }\n    }\n\n    /**\n     * @method removeField\n     * Remove a field from the data model.\n     * @param {string} name\n     * Name of the field to remove.\n     */\n\n  }, {\n    key: 'removeField',\n    value: function removeField(name) {\n      if (this.raw.hasOwnProperty(name)) {\n        var val = this.raw[name];\n        delete this[name];\n        delete this.fields[name]; // eslint-disable-line no-undef\n        delete this.raw[name]; // eslint-disable-line no-undef\n        if (this.invalidDataAttributes.indexOf(name) >= 0) {\n          this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1);\n        }\n        var c = {\n          action: 'delete',\n          field: name,\n          value: val\n        };\n        this.emit('field.remove', c);\n        this.changelog.push(c);\n      }\n    }\n\n    /**\n     * @method removeVirtual\n     * Remove a virtual field.\n     * @param {string} name\n     * Name of the field.\n     */\n\n  }, {\n    key: 'removeVirtual',\n    value: function removeVirtual(name) {\n      delete this[name];\n    }\n\n    /**\n     * @method removeRelationshipField\n     * Remove an existing join dynamically.\n     * @param {string} name\n     * The name of the relationship field to remove.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'removeRelationshipField',\n    value: function removeRelationshipField(name, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      if (this.joins.hasOwnProperty(name)) {\n        var val = this.rawjoins[name];\n        delete this.rawjoins[name];\n        delete this[name];\n        delete this.joins[name];\n        if (!suppressEvents) {\n          var c = {\n            action: 'delete',\n            field: name,\n            old: val,\n            join: true\n          };\n          this.changelog.push(c);\n          this.emit('relationship.remove', c);\n        }\n      }\n    }\n\n    /**\n     * @method undo\n     * A rollback function to undo changes. This operation affects\n     * the changelog. It is possible to undo an undo (i.e. redo).\n     * This works with relationship creating/removing relationship fields,\n     * but not updates to the related model. To undo changes to a relationship\n     * field, the `undo()` method _of the related model_ must be called.\n     * @param {number} [OperationCount=1]\n     * The number of operations to \"undo\". Defaults to a single operation.\n     */\n\n  }, {\n    key: 'undo',\n    value: function undo(back) {\n      back = back || 1;\n      var old = this.changelog.splice(this.changelog.length - back, back);\n      var me = this;\n\n      old.reverse().forEach(function (change) {\n        if (!(typeof change.join === 'boolean' ? change.join : false)) {\n          switch (change.action) {\n            case 'update':\n              me[change.field] = change.old;\n              break;\n            case 'create':\n              me.removeField(change.field);\n              break;\n            case 'delete':\n              me.addField(change.field);\n              me[change.field] = me.old;\n              break;\n          }\n        } else {\n          switch (change.action) {\n            case 'create':\n              me.removeRelationshipField(change.field);\n              break;\n            case 'delete':\n              me.addRelationshipField(change.field);\n              me[change.field] = change.old;\n              break;\n          }\n        }\n      });\n    }\n\n    /**\n     * @method load\n     * Load a data record. This clears the #history. #modified\n     * will be set to `false`, as though the record has been untouched.\n     * @param {object} data\n     * The data to apply to the model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load(data) {\n      data = data || {};\n\n      // Handle data maps\n      var me = this;\n      if (this._dataMap !== null) {\n        Object.keys(this.reverseMap).forEach(function (key) {\n          if (data.hasOwnProperty(key)) {\n            data[me.reverseMap[key]] = data[key];\n            delete data[key];\n          }\n        });\n      }\n\n      // Loop through the keys and add data fields\n      Object.keys(data).forEach(function (key) {\n        if (me.fields.hasOwnProperty(key)) {\n          if (me.raw.hasOwnProperty(key)) {\n            me.raw[key] = data[key];\n          } else if (key === me.idAttribute) {\n            me.id = data[key];\n          }\n        } else if (me.joins.hasOwnProperty(key)) {\n          // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n          // tmp.load(data[key])\n          // me.rawjoin[key] = tmp\n          me.rawjoins[key].load(data[key]);\n        } else {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + key + '%c specified as a data field but is not defined in the model.', NGN.css, '');\n          }\n        }\n      });\n\n      this.setUnmodified();\n    }\n  }, {\n    key: 'deleted',\n    get: function get() {\n      return this.isRecordDestroyed;\n    }\n  }, {\n    key: 'isDestroyed',\n    set: function set(value) {\n      if (typeof value !== 'boolean') {\n        console.warn(NGN.stack);\n        throw new Error('Invalid data type. isDestroyed must be a boolean. Received ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));\n      }\n\n      this.isRecordDestroyed = value;\n\n      if (value) {\n        this.emit('deleted');\n      }\n    }\n  }, {\n    key: 'expires',\n    get: function get() {\n      return this.expiration;\n    },\n    set: function set(value) {\n      var _this8 = this;\n\n      // Validate data type\n      if (NGN.typeof(value) !== 'date' && NGN.typeof(value) !== 'number') {\n        try {\n          var source = NGN.stack.pop();\n          console.warn('Expiration could not be set at %c' + source.path + '%c (Invalid data type. Must be a Date or number).', NGN.css, '');\n        } catch (e) {\n          console.warn('Expiration could not be set (Invalid data type. Must be a Date or number).');\n        }\n\n        return;\n      }\n\n      // Clear existing expiration timer if it is already set.\n      clearTimeout(this.expirationTimeout);\n\n      // If the new value is a number, convert to a date.\n      if (NGN.typeof(value) === 'number') {\n        if (value < 0) {\n          this.ignoreTTL = true;\n          return;\n        }\n\n        var currentDate = new Date();\n\n        value = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds() + value);\n      }\n\n      // If the process has reached this far, expiration\n      // actions should be enabled.\n      this.ignoreTTL = false;\n\n      // Set the new expiration time period\n      this.expiration = value;\n\n      // If the record is already expired, immediately trigger the expiration.\n      if (Date.now() >= this.expiration.getTime()) {\n        this.expire();\n        return;\n      }\n\n      this.hasExpired = false;\n\n      // If the expiration is in the future, set a timer to expire.\n      var waitPeriod = this.expiration.getTime() - Date.now();\n      this.expirationTimeout = setTimeout(function () {\n        _this8.expire();\n      }, waitPeriod);\n    }\n\n    /**\n     * @property {boolean} expired\n     * Indicates the record/model is expired.\n     */\n\n  }, {\n    key: 'expired',\n    get: function get() {\n      if (this.ignoreTTL) {\n        return false;\n      }\n\n      return this.hasExpired;\n    }\n\n    /**\n     * @property {Boolean}\n     * Indicates one or more data properties has changed.\n     * @readonly\n     */\n\n  }, {\n    key: 'modified',\n    get: function get() {\n      return this.checksum !== this.benchmark;\n    }\n\n    /**\n     * @cfgproperty {String/Number/Date} [id=null]\n     * The unique ID of the model object. If #idAttribute is defined,\n     * this will get/set the #idAttribute value.\n     */\n\n  }, {\n    key: 'id',\n    get: function get() {\n      return this.oid;\n    },\n    set: function set(value) {\n      this.oid = value;\n    }\n\n    /**\n     * @property checksum\n     * The unique checksum of the record (i.e. a record fingerprint).\n     * This will change as the data changes.\n     */\n\n  }, {\n    key: 'checksum',\n    get: function get() {\n      return NGN.DATA.util.checksum(JSON.stringify(this.data));\n    }\n\n    /**\n     * @property {Object} dataMap\n     * The current data map.\n     * @private\n     */\n\n  }, {\n    key: 'dataMap',\n    get: function get() {\n      return this._dataMap;\n    },\n    set: function set(value) {\n      this._dataMap = value;\n      this._reverseDataMap = null;\n    }\n\n    /**\n     * @property {NGN.DATA.Store} store\n     * If a store is associated with the model, this will\n     * provide a reference to it. If there is no store, this\n     * will return `null`.\n     */\n\n  }, {\n    key: 'datastore',\n    get: function get() {\n      return this._store;\n    }\n\n    /**\n     * @property {boolean} valid\n     * Indicates the record is valid.\n     */\n\n  }, {\n    key: 'valid',\n    get: function get() {\n      this.validate();\n      return this.invalidDataAttributes.length === 0;\n    }\n\n    /**\n     * @property datafields\n     * Provides an array of data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'datafields',\n    get: function get() {\n      return Object.keys(this.fields);\n    }\n\n    /**\n     * @property reslationships\n     * Provides an array of join fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'relationships',\n    get: function get() {\n      return Object.keys(this.joins);\n    }\n\n    /**\n     * @property virtualdatafields\n     * Provides an array of virtual data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'virtualdatafields',\n    get: function get() {\n      return Object.keys(this.virtuals);\n    }\n\n    /**\n     * @property {object} reverseMap\n     * Reverses the data map. For example, if the original #dataMap\n     * looks like:\n     *\n     * ```js\n     * {\n     *    firstname: 'gn',\n     *    lastname: 'sn\n     * }\n     * ```\n     *\n     * The reverse map will look like:\n     *\n     * ```js\n     * {\n     *    gn: 'firstname',\n     *    sn: 'lastname\n     * }\n     * ```\n     */\n\n  }, {\n    key: 'reverseMap',\n    get: function get() {\n      var _this9 = this;\n\n      if (this.dataMap !== null) {\n        var _ret9 = function () {\n          if (_this9._reverseDataMap !== null) {\n            return {\n              v: _this9._reverseDataMap\n            };\n          }\n          var rmap = {};\n          var me = _this9;\n          Object.keys(_this9._dataMap).forEach(function (attr) {\n            rmap[me._dataMap[attr]] = attr;\n          });\n          _this9._reverseDataMap = rmap;\n          return {\n            v: rmap\n          };\n        }();\n\n        if ((typeof _ret9 === 'undefined' ? 'undefined' : _typeof(_ret9)) === \"object\") return _ret9.v;\n      }\n      return null;\n    }\n\n    /**\n      * @property data\n      * Creates a JSON representation of the data entity. This is\n      * a record that can be persisted to a database or other data store.\n      * @readonly.\n      */\n\n  }, {\n    key: 'data',\n    get: function get() {\n      var _this10 = this;\n\n      var d = this.serialize();\n      if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n        d[this.idAttribute] = this[this.idAttribute];\n      }\n      if (this.dataMap) {\n        (function () {\n          var me = _this10;\n          // Loop through the map keys\n          Object.keys(_this10.dataMap).forEach(function (key) {\n            // If the node contains key, make the mapping\n            if (d.hasOwnProperty(key)) {\n              if (d[key] instanceof NGN.DATA.Model) {\n                d[me.dataMap[key]] = d[key].data;\n              } else {\n                d[me.dataMap[key]] = d[key];\n              }\n              delete d[key];\n            }\n          });\n        })();\n      }\n      return d;\n    }\n\n    /**\n     * @property history\n     * The history of the entity (i.e. changelog).The history\n     * is shown from most recent to oldest change. Keep in mind that\n     * some actions, such as adding new custom fields on the fly, may\n     * be triggered before other updates.\n     * @returns {array}\n     */\n\n  }, {\n    key: 'history',\n    get: function get() {\n      return this.changelog.reverse();\n    }\n  }]);\n\n  return Model;\n}(NGN.EventEmitter);\n\nNGN.DATA = NGN.DATA || {};\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    var ModelLoader = function ModelLoader(data) {\n      var model = new Model(cfg);\n      if (data) {\n        model.load(data);\n      }\n      return model;\n    };\n\n    return ModelLoader;\n  }),\n\n  Entity: NGN.private(Model)\n});\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA;\n}\n\n'use strict';\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n */\n\nvar Store = function (_NGN$EventEmitter2) {\n  _inherits(Store, _NGN$EventEmitter2);\n\n  function Store(cfg) {\n    _classCallCheck(this, Store);\n\n    cfg = cfg || {};\n\n    var _this11 = _possibleConstructorReturn(this, (Store.__proto__ || Object.getPrototypeOf(Store)).call(this, cfg));\n\n    Object.defineProperties(_this11, {\n      /**\n       * @cfg {NGN.DATA.Model} model\n       * An NGN Data Model to which data records conform.\n       */\n      model: NGN.const(cfg.model || null),\n\n      // The raw data collection\n      _data: NGN.private([]),\n\n      // The raw filters\n      _filters: NGN.private([]),\n\n      // The raw indexes\n      _index: NGN.private(cfg.index || []),\n\n      // Placeholders to track the data that's added/removed\n      // during the lifespan of the store. Modified data is\n      // tracked within each model record.\n      _created: NGN.private([]),\n      _deleted: NGN.private([]),\n      _loading: NGN.private(false),\n      _softarchive: NGN.private([]),\n\n      /**\n       * @property {NGN.DATA.Proxy} proxy\n       * The proxy used to transmit data over a network.\n       * @private\n       */\n      proxy: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [allowDuplicates=true]\n       * Set to `false` to prevent duplicate records from being added.\n       * If a duplicate record is added, it will be ignored and an\n       * error will be thrown.\n       */\n      allowDuplicates: NGN.public(NGN.coalesce(cfg.allowDuplicates, true)),\n\n      /**\n       * @cfg {boolean} [errorOnDuplicate=false]\n       * Set to `true` to throw an error when a duplicate record is detected.\n       * If this is not set, it will default to the value of #allowDuplicates.\n       * If #allowDuplicates is not defined either, this will be `true`\n       */\n      errorOnDuplicate: NGN.const(NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, true)),\n\n      /**\n       * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n       * When set to `true`, the store will automatically delete expired records.\n       */\n      autoRemoveExpiredRecords: NGN.privateconst(NGN.coalesce(cfg.autoRemoveExpiredRecords, true)),\n\n      /**\n       * @cfg {boolean} [softDelete=false]\n       * When set to `true`, the store makes a copy of a record before removing\n       * it from the store. The store will still emit a `record.delete` event,\n       * and it will still behanve as though the record has been completely\n       * removed. However; the record copy can be retrieved using the #restore\n       * method.\n       *\n       * Since it is not always desirable to store a copy of every deleted\n       * record indefinitely, it is possible to expire and permanently remove\n       * records by setting the #softDeleteTtl.\n       *\n       * ```js\n       * var People = new NGN.DATA.Store({\n       *   model: Person,\n       *   softDelete: true,\n       *   softDeleteTtl: 10000\n       * })\n       *\n       * People.add(somePerson)\n       *\n       * var removedRecordId\n       * People.once('record.delete', function (record) {\n       *   removedRecordId = record.id\n       * })\n       *\n       * People.remove(somePerson)\n       *\n       * setTimeout(function () {\n       *   People.restore(removedRecordId)\n       * }, 5000)\n       *\n       * ```\n       *\n       * The code above creates a new store and adds a person to it.\n       * Then a placeholder variable (`removedRecordId`) is created.\n       * Next, a one-time event listener is added to the store, specifically\n       * for handling the removal of a record. Then the record is removed,\n       * which triggers the `record.delete` event, which populates\n       * `removedRecordId` with the ID of the record that was deleted.\n       * Finally, the code waits for 5 seconds, then restores the record. If\n       * the #restore method _wasn't_ called, the record would be purged\n       * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n       * milliseconds).\n       */\n      softDelete: NGN.privateconst(NGN.coalesce(cfg.softDelete, false)),\n\n      /**\n       * @cfg {number} [softDeleteTtl=-1]\n       * This is the number of milliseconds the store waits before purging a\n       * soft-deleted record from memory. `-1` = Infinite (no TTL).\n       */\n      softDeleteTtl: NGN.private(NGN.coalesce(cfg.softDeleteTtl, -1))\n    });\n\n    var obj = {};\n    _this11._index.forEach(function (i) {\n      obj[i] = [];\n    });\n\n    _this11._index = obj;\n\n    var events = ['record.duplicate', 'record.create', 'record.update', 'record.delete', 'record.restored', 'record.purged', 'record.move', 'record.invalid', 'record.valid', 'clear', 'filter.create', 'filter.delete', 'index.create', 'index.delete'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        _this11.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.shift();\n          args.push(this);\n          NGN.BUS.emit(eventName, args);\n        });\n      });\n    }\n    return _this11;\n  }\n\n  /**\n   * @property {array} data\n   * The complete and unfiltered raw underlying dataset. This data\n   * is usually persisted to a database.\n   * @readonly\n   */\n\n\n  _createClass(Store, [{\n    key: 'add',\n\n\n    /**\n     * @method add\n     * Add a data record.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n    value: function add(data, suppressEvent) {\n      var record = void 0;\n\n      if (!(data instanceof NGN.DATA.Entity)) {\n        try {\n          data = JSON.parse(data);\n        } catch (e) {}\n        if ((typeof data === 'undefined' ? 'undefined' : _typeof(data)) !== 'object') {\n          throw new Error('Cannot add a non-object record.');\n        }\n        if (this.model) {\n          record = new this.model(data); // eslint-disable-line new-cap\n        } else {\n          record = data;\n        }\n      } else {\n        record = data;\n      }\n\n      if (record.hasOwnProperty('_store')) {\n        record._store = this;\n      }\n\n      var dupe = this.isDuplicate(record);\n      if (dupe) {\n        this.emit('record.duplicate', record);\n        if (!this.allowDuplicates) {\n          if (this.errorOnDuplicate) {\n            throw new Error('Cannot add duplicate record (allowDuplicates = false).');\n          }\n          return;\n        }\n      }\n\n      this.listen(record);\n      this.applyIndices(record, this._data.length);\n      this._data.push(record);\n      !this._loading && this._created.indexOf(record) < 0 && this._created.push(record);\n      if (!NGN.coalesce(suppressEvent, false)) {\n        this.emit('record.create', record);\n      }\n      if (!record.valid) {\n        this.emit('record.invalid', record);\n      }\n      return record;\n    }\n\n    /**\n     * @method insertBefore\n     * Add a record before the specified index.\n     * @param  {NGN.DATA.Model|number} target\n     * The model or index where the new record will be added before.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n\n  }, {\n    key: 'insertBefore',\n    value: function insertBefore(index, data) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      return this.insert(index, data, suppressEvent, 'before');\n    }\n\n    /**\n     * @method insertAfter\n     * Add a record after the specified index.\n     * @param  {NGN.DATA.Model|number} target\n     * The model or index where the new record will be added after.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n\n  }, {\n    key: 'insertAfter',\n    value: function insertAfter(index, data) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      return this.insert(index + 1, data, suppressEvent, 'after');\n    }\n\n    /**\n     * @method insert\n     * Add a record somewhere within the existing recordset (as opposed to simply appending).\n     * @param  {NGN.DATA.Model|number} target\n     * The model or index where the new record will be added after.\n     * @param {NGN.DATA.Model|object} data\n     * Accepts an existing NGN Data Model or a JSON object.\n     * If a JSON object is supplied, it will be applied to\n     * the data model specified in cfg#model. If no model\n     * is specified, the raw JSON data will be stored.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     * @param {string} [position=after]\n     * The position (before or after) where the record should be added.\n     * @return {NGN.DATA.Model}\n     * Returns the new record.\n     */\n\n  }, {\n    key: 'insert',\n    value: function insert(index, data) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n      var position = arguments.length <= 3 || arguments[3] === undefined ? 'after' : arguments[3];\n\n      var record = this.add(data, true);\n      if (record) {\n        this.move(this._data.length - 1, index, position, false);\n\n        if (!suppressEvent) {\n          this.emit('record.create', record);\n        }\n      }\n\n      return record;\n    }\n\n    /**\n     * @method isDuplicate\n     * Indicates whether the specified record is a duplicate.\n     * This compares checksum values. Any match is considered a\n     * duplicate. It will also check for duplication of raw JSON\n     * objects (i.e. non-NGN.DATA.Model records).\n     * @param  {NGN.DATA.Model|Object} record\n     * The record or JSON object.\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'isDuplicate',\n    value: function isDuplicate(record) {\n      if (this._data.indexOf(record) >= 0) {\n        return false;\n      }\n      return this._data.filter(function (rec) {\n        return rec.checksum === record.checksum;\n      }).length > 0;\n    }\n\n    /**\n     * @method listen\n     * Listen to a specific record's events and respond.\n     * @param {NGN.DATA.Model} record\n     * The record to listen to.\n     * @fires record.update\n     * Fired when a record is updated. The #record is passed as an argument to\n     * the event handler.\n     * @private\n     */\n\n  }, {\n    key: 'listen',\n    value: function listen(record) {\n      var _this12 = this;\n\n      record.on('field.update', function (delta) {\n        _this12.updateIndice(delta.field, delta.old, delta.new, _this12._data.indexOf(record));\n        _this12.emit('record.update', record, delta);\n      });\n\n      record.on('field.delete', function (delta) {\n        _this12.updateIndice(delta.field, delta.old, undefined, _this12._data.indexOf(record));\n        _this12.emit('record.update', record, delta);\n      });\n\n      record.on('field.invalid', function () {\n        _this12.emit('record.invalid', record);\n      });\n\n      record.on('field.valid', function () {\n        _this12.emit('record.valid', record);\n      });\n\n      record.on('expired', function () {\n        if (!record.expired) {\n          return;\n        }\n\n        _this12.emit('record.expired', record);\n\n        if (_this12.autoRemoveExpiredRecords) {\n          var index = _this12.indexOf(record);\n          if (index >= 0) {\n            _this12.remove(record);\n          }\n        }\n      });\n    }\n\n    /**\n     * @method bulk\n     * Bulk load data.\n     * @param {string} eventName\n     * @param {array} data\n     * @private\n     */\n\n  }, {\n    key: 'bulk',\n    value: function bulk(event, data) {\n      var _this13 = this;\n\n      this._loading = true;\n\n      data.forEach(function (record) {\n        _this13.add(record, true);\n      });\n\n      this._loading = false;\n      this._deleted = [];\n      this._created = [];\n\n      // Slight delay to prevent faster systems from\n      // responding before data is written to memory.\n      setTimeout(function () {\n        _this13.emit(event || 'load');\n      }, 10);\n    }\n\n    /**\n     * @method load\n     * Bulk load data. This acts the same as adding records,\n     * but it suppresses individual record creation events.\n     * This will add data to the existing collection. If you\n     * want to load fresh data, use the #reload method.\n     * @param {array} data\n     * An array of data. Each array element should be an\n     * NGN.DATA.Model or a JSON object that can be applied\n     * to the store's #model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load() {\n      var array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments);\n      this.bulk('load', array);\n    }\n\n    /**\n     * @method reload\n     * Reload data. This is the same as running #clear followed\n     * by #load.\n     */\n\n  }, {\n    key: 'reload',\n    value: function reload(data) {\n      this.clear();\n      var array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments);\n      this.bulk('reload', array);\n    }\n\n    /**\n     * @method indexOf\n     * Find the index number of a record within the collection.\n     * @param  {NGN.DATA.Model} record\n     * The record whose index should be identified.\n     * @return {Number}\n     * Returns a number from `0-collection length`. Returns `-1` if\n     * the record is not found in the collection.\n     */\n\n  }, {\n    key: 'indexOf',\n    value: function indexOf(record) {\n      if ((typeof record === 'undefined' ? 'undefined' : _typeof(record)) !== 'object' || !(record instanceof NGN.DATA.Entity) && !record.checksum) {\n        return -1;\n      }\n\n      return this._data.findIndex(function (el) {\n        return el.checksum === record.checksum;\n      });\n    }\n\n    /**\n     * @method contains\n     * A convenience method that indicates whether a record is in\n     * the store or not.\n     * @param {NGN.DATA.Model} record\n     * The record to check for inclusion in the data collection.\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(record) {\n      return this.indexOf(record) >= 0;\n    }\n\n    /**\n     * @method remove\n     * Remove a record.\n     * @param {NGN.DATA.Model|object|number} data\n     * Accepts an existing NGN Data Model, JSON object,\n     * or index number. Using a JSON object is slower\n     * than using a reference to a data model or an index\n     * number (index is fastest).\n     * @fires record.delete\n     * The record delete event sends 2 arguments to handler methods:\n     * `record` and `index`. The record refers to the model that was\n     * removed. The `index` refers to the position of the record within\n     * the store's data list. **NOTICE** the `index` refers to where\n     * the record _used to be_.\n     * @returns {NGN.DATA.Model}\n     * Returns the data model that was just removed. If a model\n     * is unavailable (i.e. remove didn't find the specified record),\n     * this will return `null`.\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(data, suppressEvents) {\n      var _this14 = this;\n\n      var removedRecord = [];\n      var dataIndex = void 0;\n\n      if (typeof data === 'number') {\n        dataIndex = data;\n      } else if (data && data.checksum && data.checksum !== null || data instanceof NGN.DATA.Model) {\n        dataIndex = this.indexOf(data);\n      } else {\n        (function () {\n          var m = new _this14.model(data, true); // eslint-disable-line new-cap\n          dataIndex = _this14._data.findIndex(function (el) {\n            return el.checksum === m.checksum;\n          });\n        })();\n      }\n\n      // If no record is found, the operation fails.\n      if (dataIndex < 0) {\n        throw new Error('Record removal failed (record not found at index ' + (dataIndex || '').toString() + ').');\n      }\n\n      this._data[dataIndex].isDestroyed = true;\n\n      removedRecord = this._data.splice(dataIndex, 1);\n\n      removedRecord.isDestroyed = true;\n\n      if (removedRecord.length > 0) {\n        removedRecord = removedRecord[0];\n        this.unapplyIndices(dataIndex);\n\n        if (this.softDelete) {\n          if (this.softDeleteTtl >= 0) {\n            (function () {\n              var checksum = removedRecord.checksum;\n              removedRecord.once('expired', function () {\n                _this14.purgeDeletedRecord(checksum);\n              });\n\n              removedRecord.expires = _this14.softDeleteTtl;\n            })();\n          }\n\n          this._softarchive.push(removedRecord);\n        }\n\n        if (!this._loading) {\n          var i = this._created.indexOf(removedRecord);\n          if (i >= 0) {\n            i >= 0 && this._created.splice(i, 1);\n          } else if (this._deleted.indexOf(removedRecord) < 0) {\n            this._deleted.push(removedRecord);\n          }\n        }\n\n        if (!NGN.coalesce(suppressEvents, false)) {\n          this.emit('record.delete', removedRecord, dataIndex);\n        }\n\n        return removedRecord;\n      }\n\n      return null;\n    }\n\n    /**\n     * @method findArchivedRecord\n     * Retrieve an archived record.\n     * @param  {string} checksum\n     * Checksum of the record.\n     * @return {object}\n     * Returns the archived record and it's index within the deletion archive.\n     * ```js\n     * {\n     *   index: <number>,\n     *   record: <NGN.DATA.Model>\n     * }\n     * ```\n     * @private\n     */\n\n  }, {\n    key: 'findArchivedRecord',\n    value: function findArchivedRecord(checksum) {\n      var index = void 0;\n      var record = this._softarchive.filter(function (record, i) {\n        if (record.checksum === checksum) {\n          index = i;\n          return true;\n        }\n      });\n\n      if (record.length !== 1) {\n        var source = void 0;\n        try {\n          source = NGN.stack.pop().path;\n        } catch (e) {\n          source = 'Unknown';\n        }\n\n        console.warn('Cannot purge record. %c' + record.length + ' records found%c. Source: %c' + source, NGN.css, '', NGN.css);\n        return null;\n      }\n\n      return {\n        index: index,\n        record: record[0]\n      };\n    }\n\n    /**\n     * @method purgeDeletedRecord\n     * Remove a soft-deleted record from the store permanently.\n     * This cannot be undone, and there are no events for this action.\n     * @param  {string} checksum\n     * Checksum of the record.\n     * @return {NGN.DATA.Model}\n     * Returns the purged record. This will be `null` if the record cannot be\n     * found or does not exist.\n     * @fires {NGN.DATA.Model} record.purged\n     * This event is triggered when a record is removed from the soft-delete\n     * archive.\n     * @private\n     */\n\n  }, {\n    key: 'purgeDeletedRecord',\n    value: function purgeDeletedRecord(checksum) {\n      var purgedRecord = this.findArchivedRecord(checksum);\n\n      // If there is no record, abort (the findArchivedRecord emits a warning)\n      if (purgedRecord === null) {\n        return null;\n      }\n\n      this._softarchive.splice(purgedRecord.index, 1);\n\n      this.emit('record.purged', purgedRecord.record);\n\n      return purgedRecord.record;\n    }\n\n    /**\n     * @method restore\n     * Restore a soft-deleted record to the store. This does not preserve the\n     * original index (a new index number is assigned).\n     * @param  {string} checksum\n     * Checksum of the record.\n     * @return {NGN.DATA.Model}\n     * Returns the purged record. This will be `null` if the record cannot be\n     * found or does not exist.\n     * @fires record.restored\n     */\n\n  }, {\n    key: 'restore',\n    value: function restore(checksum) {\n      var purgedRecord = this.findArchivedRecord(checksum);\n\n      // If there is no record, abort (the findArchivedRecord emits a warning)\n      if (purgedRecord === null) {\n        return null;\n      }\n\n      purgedRecord.record.removeAllListeners('expired');\n      purgedRecord.record.expires = this.softDeleteTtl;\n\n      this.add(purgedRecord.record, true);\n\n      this._softarchive[purgedRecord.index].removeAllListeners('expired');\n      this._softarchive.splice(purgedRecord.index, 1);\n\n      purgedRecord.record.isDestroyed = false;\n\n      this.emit('record.restored', purgedRecord.record);\n\n      return purgedRecord.record;\n    }\n\n    /**\n     * @method clear\n     * Removes all data.\n     * @param {boolean} [purgeSoftDelete=true]\n     * Purge soft deleted records from memory.\n     * @fires clear\n     * Fired when all data is removed\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      var _this15 = this;\n\n      var purge = arguments.length <= 0 || arguments[0] === undefined ? true : arguments[0];\n\n      if (!purge) {\n        this._softarchive = this._data;\n      } else {\n        this._softarchive = [];\n      }\n\n      this._data = [];\n\n      Object.keys(this._index).forEach(function (index) {\n        _this15._index[index] = [];\n      });\n\n      this.emit('clear');\n    }\n\n    /**\n     * @method find\n     * Retrieve a specific record or set of records.\n     * @param {number|function|string|object} [query=null]\n     * When this is set to a `number`, the corresponding zero-based\n     * record will be returned. A `function` can also be used, which\n     * acts like a filter. Each record is passed to this function.\n     *\n     * For example, if we want to find all administrators within a\n     * set of users, the following could be used:\n     *\n     * ```js\n     *   let record = MyStore.find(function (record) {\n     *     return record.usertype = 'admin'\n     *   })\n     * ```\n     *\n     * It's also possible to supply a String. When this is supplied,\n     * the store will look for a record whose ID (see NGN.DATA.Model#idAttribute)\n     * matches the string. Numberic ID's are matched on their string\n     * equivalent for search purposes (data is not modified).\n     *\n     * An object can be used to search for specific field values. For example:\n     *\n     * ```js\n     * MyStore.find({\n     *   firstname: 'Corey',\n     *   lastname: /Butler|Doe/\n     * })\n     * ```\n     *\n     * The code above will find everyone named Corey Butler or Corey Doe. The\n     * first attribute must match the value exactly whereas `lastname` will\n     * match against the regular expression.\n     *\n     * If this parameter is `undefined` or `null`, all records will be\n     * returned (i.e. no search criteria specified, so return everything).\n     *\n     * If you're using a large dataset, indexing can speed up queries. To take\n     * full advantage of indexing, all of the query elements should be indexed.\n     * For example, if you have `lastname`, 'firstname' in your query and\n     * both of those are indexed, the response time will be substantially faster\n     * than if they're not (in large data sets). However; if one of those\n     * elements is _not_ indexed, performance may not increase.\n     * @param {boolean} [ignoreFilters=false]\n     * Set this to `true` to search the full unfiltered record set.\n     * @return {NGN.DATA.Model|array|null}\n     * An array is returned when a function is specified for the query.\n     * Otherwise the specific record is return. This method assumes\n     * records have unique ID's.\n     */\n\n  }, {\n    key: 'find',\n    value: function find(query, ignoreFilters) {\n      var _this16 = this;\n\n      if (this._data.length === 0) {\n        return [];\n      }\n\n      var resultSet = [];\n\n      var _ret13 = function () {\n        switch (typeof query === 'undefined' ? 'undefined' : _typeof(query)) {\n          case 'function':\n            resultSet = _this16._data.filter(query);\n            break;\n          case 'number':\n            resultSet = query < 0 || query >= _this16._data.length ? null : _this16._data[query];\n            break;\n          case 'string':\n            var indice = _this16.getIndices(_this16._data[0].idAttribute, query.trim());\n            if (indice !== null && indice.length > 0) {\n              indice.forEach(function (index) {\n                resultSet.push(_this16._data[index]);\n              });\n              return {\n                v: resultSet\n              };\n            }\n\n            var recordSet = _this16._data.filter(function (record) {\n              return (record[record.idAttribute] || '').toString().trim() === query.trim();\n            });\n\n            resultSet = recordSet.length === 0 ? null : recordSet[0];\n\n            break;\n          case 'object':\n            if (query instanceof NGN.DATA.Model) {\n              if (_this16.contains(query)) {\n                return {\n                  v: query\n                };\n              }\n\n              return {\n                v: null\n              };\n            }\n\n            var match = [];\n            var noindex = [];\n            var queryKeys = Object.keys(query);\n\n            queryKeys.forEach(function (field) {\n              var index = _this16.getIndices(field, query[field]);\n\n              if (index) {\n                match = match.concat(index || []);\n              } else {\n                field !== null && noindex.push(field);\n              }\n            });\n\n            // Deduplicate\n            match.filter(function (index, i) {\n              return match.indexOf(index) === i;\n            });\n\n            // Get non-indexed matches\n            if (noindex.length > 0) {\n              resultSet = _this16._data.filter(function (record, i) {\n                if (match.indexOf(i) >= 0) {\n                  return false;\n                }\n\n                for (var x = 0; x < noindex.length; x++) {\n                  if (record[noindex[x]] !== query[noindex[x]]) {\n                    return false;\n                  }\n                }\n\n                return true;\n              });\n            }\n\n            // If a combined indexable + nonindexable query\n            resultSet = resultSet.concat(match.map(function (index) {\n              return _this16._data[index];\n            })).filter(function (record) {\n              for (var y = 0; y < queryKeys.length; y++) {\n                if (query[queryKeys[y]] !== record[queryKeys[y]]) {\n                  return false;\n                }\n              }\n\n              return true;\n            });\n            break;\n          default:\n            resultSet = _this16._data;\n        }\n      }();\n\n      if ((typeof _ret13 === 'undefined' ? 'undefined' : _typeof(_ret13)) === \"object\") return _ret13.v;\n      if (resultSet === null) {\n        return null;\n      }\n\n      if (!NGN.coalesce(ignoreFilters, false)) {\n        this.applyFilters(resultSet instanceof Array ? resultSet : [resultSet]);\n      }\n\n      return resultSet;\n    }\n\n    /**\n     * @method applyFilters\n     * Apply filters to a data set.\n     * @param {array} data\n     * The array of data to apply filters to.\n     * @private\n     */\n\n  }, {\n    key: 'applyFilters',\n    value: function applyFilters(data) {\n      if (this._filters.length === 0) {\n        return data;\n      }\n\n      this._filters.forEach(function (filter) {\n        data = data.filter(filter);\n      });\n\n      return data;\n    }\n\n    /**\n     * @method addFilter\n     * Add a filter to the record set.\n     * @param {function} fn\n     * The filter function. This function should comply\n     * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n     * returning a boolean value.\n     * The item passed to the filter will be the NGN.DATA.Model specified\n     * in the cfg#model.\n     * @fires filter.create\n     * Fired when a filter is created.\n     */\n\n  }, {\n    key: 'addFilter',\n    value: function addFilter(fn) {\n      this._filters.push(fn);\n      this.emit('filter.create', fn);\n    }\n\n    /**\n     * @method removeFilter\n     * Remove a filter from the record set.\n     * @param {function|index} filter\n     * This can be the function which was originally passed to\n     * the #addFilter method, or the zero-based #filters index\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing one the creation of the filter.\n     * @fires filter.delete\n     * Fired when a filter is removed.\n     */\n\n  }, {\n    key: 'removeFilter',\n    value: function removeFilter(fn, suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, false);\n\n      var removed = [];\n\n      if (typeof fn === 'number') {\n        removed = this._filters.splice(fn, 1);\n      } else {\n        removed = this._filters.splice(this._filters.indexOf(fn), 1);\n      }\n\n      if (removed.length > 0 && !suppressEvents) {\n        this.emit('filter.delete', removed[0]);\n      }\n    }\n\n    /**\n     * @method clearFilters\n     * Remove all filters.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing one the removal of each filter.\n     */\n\n  }, {\n    key: 'clearFilters',\n    value: function clearFilters(suppressEvents) {\n      suppressEvents = NGN.coalesce(suppressEvents, false);\n\n      if (suppressEvents) {\n        this._filters = [];\n        return;\n      }\n\n      while (this._filters.length > 0) {\n        this.emit('filter.delete', this._filters.pop());\n      }\n    }\n\n    /**\n     * @method deduplicate\n     * Deduplicates the recordset. This compares the checksum of\n     * each of the records to each other and removes duplicates.\n     * This suppresses the removal\n     * @param {boolean} [suppressEvents=true]\n     * Suppress the event that gets fired when a record is removed.\n     */\n\n  }, {\n    key: 'deduplicate',\n    value: function deduplicate(suppressEvents) {\n      var _this17 = this;\n\n      suppressEvents = NGN.coalesce(suppressEvents, true);\n\n      var records = this.data.map(function (rec) {\n        return JSON.stringify(rec);\n      });\n\n      var dupes = [];\n\n      records.forEach(function (record, i) {\n        if (records.indexOf(record) < i) {\n          dupes.push(_this17.find(i));\n        }\n      });\n\n      dupes.forEach(function (duplicate) {\n        _this17.remove(duplicate);\n      });\n    }\n\n    /**\n     * @method sort\n     * Sort the #records. This forces a #reindex, which may potentially be\n     * an expensive operation on large data sets.\n     * @param {function|object} sorter\n     * Using a function is exactly the same as using the\n     * [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsort) method\n     * (this is the compare function). The arguments passed to the\n     * method are NGN.DATA.Model objects.\n     * Alternatively, it is possible to sort by one or more model\n     * attributes. Each attribute For example:\n     *\n     * ```js\n     * let Person = new NGN.DATA.Model({\n     *   fields: {\n     *     fname: null,\n     *     lname: null\n     *   }\n     * })\n     *\n     * let People = new NGN.DATA.Store({\n     *   model: Person\n     * })\n     *\n     * People.add({\n     *   fname: 'John',\n     *   lname: 'Doe',\n     *   age: 37\n     * }, {\n     *   fname: 'Jane',\n     *   lname: 'Doe',\n     *   age: 36\n     * }, {\n     *   fname: 'Jane',\n     *   lname: 'Vaughn',\n     *   age: 42\n     * })\n     *\n     * People.sort({\n     *   lname: 'asc',  // Sort by last name in normal alphabetical order.\n     *   age: 'desc'    // Sort by age, oldest to youngest.\n     * })\n     *\n     * People.records.forEach(function (p) {\n     *   console.log(fname, lname, age)\n     * })\n     *\n     * // DISPLAYS\n     * // John Doe 37\n     * // Jane Doe 36\n     * // Jane Vaughn 42\n     *\n     * People.sort({\n     *   age: 'desc',  // Sort by age, oldest to youngest.\n     *   lname: 'asc'  // Sort by name in normal alphabetical order.\n     * })\n     *\n     * People.records.forEach(function (p) {\n     *   console.log(fname, lname, age)\n     * })\n     *\n     * // DISPLAYS\n     * // Jane Vaughn 42\n     * // John Doe 37\n     * // Jane Doe 36\n     * ```\n     *\n     * It is also posible to provide complex sorters. For example:\n     *\n     * ```js\n     * People.sort({\n     *   lname: 'asc',\n     *   age: function (a, b) {\n     *     if (a.age < 40) {\n     *       return 1\n     *     }\n     *     return a.age < b.age\n     *   }\n     * })\n     * ```\n     *\n     * The sorter above says \"sort alphabetically by last name,\n     * then by age where anyone under 40yrs old shows up before\n     * everyone else, but sort the remainder ages in descending order.\n     */\n\n  }, {\n    key: 'sort',\n    value: function sort(fn) {\n      var _this18 = this;\n\n      if (typeof fn === 'function') {\n        this.records.sort(fn);\n      } else if ((typeof fn === 'undefined' ? 'undefined' : _typeof(fn)) === 'object') {\n        (function () {\n          var functionKeys = Object.keys(fn);\n\n          _this18._data.sort(function (a, b) {\n            for (var i = 0; i < functionKeys.length; i++) {\n              // Make sure both objects have the same sorting key\n              if (a.hasOwnProperty(functionKeys[i]) && !b.hasOwnProperty(functionKeys[i])) {\n                return 1;\n              }\n\n              if (!a.hasOwnProperty(functionKeys[i]) && b.hasOwnProperty(functionKeys[i])) {\n                return -1;\n              }\n\n              // For objects who have the key, sort in the order defined in object.\n              if (a[functionKeys[i]] !== b[functionKeys[i]]) {\n                switch (fn[functionKeys[i]].toString().trim().toLowerCase()) {\n                  case 'asc':\n                    if (_typeof(a.fields[functionKeys[i]])) {\n                      return a[functionKeys[i]].localeCompare(b[functionKeys[i]]);\n                    }\n                    return a[functionKeys[i]] > b[functionKeys[i]] ? 1 : -1;\n\n                  case 'desc':\n                    return a[functionKeys[i]] < b[functionKeys[i]] ? 1 : -1;\n\n                  default:\n                    if (typeof fn[functionKeys[i]] === 'function') {\n                      return fn[functionKeys[i]](a, b);\n                    }\n                    return 0;\n                }\n              }\n            }\n\n            // Everything is equal\n            return 0;\n          });\n        })();\n      }\n      this.reindex();\n    }\n\n    /**\n     * @method createIndex\n     * Add a simple index to the recordset.\n     * @param {string} datafield\n     * The #model data field to index.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing on the creation of the index.\n     * @fires index.create\n     * Fired when an index is created. The datafield name and\n     * store are supplied as an argument to event handlers.\n     */\n\n  }, {\n    key: 'createIndex',\n    value: function createIndex(field, suppressEvents) {\n      if (!this.model.hasOwnProperty(field)) {\n        console.warn('The store\\'s model does not contain a data field called %c' + field + '%c.', NGN.css, '');\n      }\n\n      var exists = this._index.hasOwnProperty(field);\n\n      this._index[field] = this._index[field] || [];\n      if (!NGN.coalesce(suppressEvents, false) && !exists) {\n        this.emit('index.created', {\n          field: field,\n          store: this\n        });\n      }\n    }\n\n    /**\n     * @method deleteIndex\n     * Remove an index.\n     * @param {string} datafield\n     * The #model data field to stop indexing.\n     * @param {boolean} [suppressEvents=false]\n     * Prevent events from firing on the removal of the index.\n     * @fires index.delete\n     * Fired when an index is deleted. The datafield name and\n     * store are supplied as an argument to event handlers.\n     */\n\n  }, {\n    key: 'deleteIndex',\n    value: function deleteIndex(field, suppressEvents) {\n      if (this._index.hasOwnProperty(field)) {\n        delete this._index[field];\n\n        if (!NGN.coalesce(suppressEvents, false)) {\n          this.emit('index.created', {\n            field: field,\n            store: this\n          });\n        }\n      }\n    }\n\n    /**\n     * @method clearIndices\n     * Clear all indices from the indexes.\n     */\n\n  }, {\n    key: 'clearIndices',\n    value: function clearIndices() {\n      var _this19 = this;\n\n      Object.keys(this._index).forEach(function (key) {\n        _this19._index[key] = [];\n      });\n    }\n\n    /**\n     * @method deleteIndexes\n     * Remove all indexes.\n     * @param {boolean} [suppressEvents=true]\n     * Prevent events from firing on the removal of each index.\n     */\n\n  }, {\n    key: 'deleteIndexes',\n    value: function deleteIndexes(suppressEvents) {\n      var _this20 = this;\n\n      suppressEvents = NGN.coalesce(suppressEvents, true);\n\n      Object.keys(this._index).forEach(function (key) {\n        _this20.deleteIndex(key, suppressEvents);\n      });\n    }\n\n    /**\n     * @method applyIndices\n     * Apply the values to the index.\n     * @param {NGN.DATA.Model} record\n     * The record which should be applied to the index.\n     * @param {number} number\n     * The record index number.\n     * @private\n     */\n\n  }, {\n    key: 'applyIndices',\n    value: function applyIndices(record, number) {\n      var _this21 = this;\n\n      var indexes = Object.keys(this._index);\n\n      if (indexes.length === 0) {\n        return;\n      }\n\n      indexes.forEach(function (field) {\n        if (record.hasOwnProperty(field)) {\n          var values = _this21._index[field];\n\n          // Check existing records for similar values\n          for (var i = 0; i < values.length; i++) {\n            if (values[i][0] === record[field]) {\n              _this21._index[field][i].push(number);\n              return;\n            }\n          }\n\n          // No matching words, create a new one.\n          _this21._index[field].push([record[field], number]);\n        }\n      });\n    }\n\n    /**\n     * @method unapplyIndices\n     * This removes a record from all relevant indexes simultaneously.\n     * Commonly used when removing a record from the store.\n     * @param  {number} indexNumber\n     * The record index.\n     * @private\n     */\n\n  }, {\n    key: 'unapplyIndices',\n    value: function unapplyIndices(num) {\n      var _this22 = this;\n\n      Object.keys(this._index).forEach(function (field) {\n        var i = _this22._index[field].indexOf(num);\n        if (i >= 0) {\n          _this22._index[field].splice(i, 1);\n        }\n      });\n    }\n\n    /**\n     * @method updateIndice\n     * Update the index with new values.\n     * @param  {string} fieldname\n     * The name of the indexed field.\n     * @param  {any} oldValue\n     * The original value. This is used to remove the old value from the index.\n     * @param  {any} newValue\n     * The new value.\n     * @param  {number} indexNumber\n     * The number of the record index.\n     * @private\n     */\n\n  }, {\n    key: 'updateIndice',\n    value: function updateIndice(field, oldValue, newValue, num) {\n      if (!this._index.hasOwnProperty(field) || oldValue === newValue) {\n        return;\n      }\n\n      var ct = 0;\n\n      for (var i = 0; i < this._index[field].length; i++) {\n        var value = this._index[field][i][0];\n\n        if (value === oldValue) {\n          this._index[field][i].splice(this._index[field][i].indexOf(num), 1);\n          ct++;\n        } else if (newValue === undefined) {\n          // If thr new value is undefined, the field was removed for the record.\n          // This can be skipped.\n          ct++;\n        } else if (value === newValue) {\n          this._index[field][i].push(num);\n          this._index[field][i].shift();\n          this._index[field][i].sort();\n          this._index[field][i].unshift(value);\n          ct++;\n        }\n\n        if (ct === 2) {\n          return;\n        }\n      }\n    }\n\n    /**\n     * @method getIndices\n     * Retrieve a list of index numbers pertaining to a field value.\n     * @param  {string} field\n     * Name of the data field.\n     * @param  {any} value\n     * The value of the index to match against.\n     * @return {array}\n     * Returns an array of integers representing the index where the\n     * values exist in the record set.\n     */\n\n  }, {\n    key: 'getIndices',\n    value: function getIndices(field, value) {\n      if (!this._index.hasOwnProperty(field)) {\n        return null;\n      }\n\n      var indexes = this._index[field].filter(function (dataArray) {\n        return dataArray.length > 0 && dataArray[0] === value;\n      });\n\n      if (indexes.length === 1) {\n        indexes[0].shift();\n        return indexes[0];\n      }\n\n      return [];\n    }\n\n    /**\n     * @method move\n     * Move an existing record to a specific index. This can be used\n     * to reorder a single record.\n     * @param {NGN.DATA.Model|number|string} source\n     * The record or the index of a record within the store to move.\n     * This can also be the unique ID of a record.\n     * @param {NGN.DATA.Model|number|string} target\n     * The record or the index of a record within the store where the source\n     * will be positioned against. This can also be the unique ID of a record.\n     * @param {boolean} [suppressEvent=false]\n     * Set this to `true` to prevent the `record.create` event\n     * from firing.\n     */\n\n  }, {\n    key: 'move',\n    value: function move(source, target) {\n      var suppressEvent = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];\n\n      if (source === undefined) {\n        console.warn('Cannot move record. No source specified.');\n        return;\n      }\n\n      if (target === undefined) {\n        console.warn('Cannot move record. No target specified.');\n        return;\n      }\n\n      source = this.getRecordIndex(source);\n      target = this.getRecordIndex(target);\n\n      // If the positins haven't actually changed, stop processing.\n      if (source === target) {\n        return;\n      }\n\n      this._data.splice(target, 0, this._data.splice(source, 1)[0]);\n\n      if (!suppressEvent) {\n        this.emit('record.move', {\n          oldIndex: source,\n          newIndex: target,\n          record: this._data[target]\n        });\n      }\n\n      this.reindex();\n    }\n\n    /**\n     * @method getRecordIndex\n     * Returns the index of a record using sanitize input.\n     * @param  {NGN.DATA.Model|number|String} value\n     * The record or the index of a record within the store.\n     * This can also be the unique ID of a record.\n     * @return {NGN.DATA.Model}\n     * Returns the model or `null`\n     */\n\n  }, {\n    key: 'getRecordIndex',\n    value: function getRecordIndex(value) {\n      if (value === undefined) {\n        console.warn('No argument passed to getRecordIndex().');\n        return null;\n      }\n\n      if (typeof value === 'number') {\n        if (value < 0 || value >= this._data.length) {\n          console.warn('%c' + value + '%c out of bounds.', NGN.css, '');\n          return null;\n        }\n\n        return value;\n      } else if (typeof value === 'string') {\n        var id = value;\n\n        value = this.find(id);\n\n        if (!value) {\n          console.warn('%c' + id + '%c does not exist or cannot be found in the store.', NGN.css, '');\n          return null;\n        }\n      }\n\n      return this.indexOf(value);\n    }\n\n    /**\n     * @method reindex\n     * Reindex the entire record set. This can be expensive operation.\n     * Use with caution.\n     * @private\n     */\n\n  }, {\n    key: 'reindex',\n    value: function reindex() {\n      var _this23 = this;\n\n      this.clearIndices();\n      this._data.forEach(function (record, index) {\n        _this23.applyIndices(record, index);\n      });\n    }\n  }, {\n    key: 'data',\n    get: function get() {\n      return this._data.map(function (d) {\n        return d.data;\n      });\n    }\n\n    /**\n     * @property {array} records\n     * An array of NGN.DATA.Model records. If the store has\n     * filters applied, the records will reflect the filtration.\n     * @readonly\n     */\n\n  }, {\n    key: 'records',\n    get: function get() {\n      return this.applyFilters(this._data);\n    }\n\n    /**\n     * @property recordCount\n     * The total number of #records in the collection.\n     * @readonly\n     */\n\n  }, {\n    key: 'recordCount',\n    get: function get() {\n      return this.applyFilters(this._data).length;\n    }\n\n    /**\n     * @property {array} filtered\n     * An array of NGN.DATA.Model records that have been filtered out.\n     * The results reflect the inverse of #records.\n     */\n\n  }, {\n    key: 'filtered',\n    get: function get() {\n      var records = this.records;\n      return this._data.filter(function (record) {\n        return records.filter(function (rec) {\n          return rec.checksum === record.checksum;\n        }).length === 0;\n      });\n    }\n\n    /**\n     * @property {NGN.DATA.Model} first\n     * Return the first record in the store. Returns `null`\n     * if the store is empty.\n     */\n\n  }, {\n    key: 'first',\n    get: function get() {\n      if (this.records.length === 0) {\n        return null;\n      }\n      return this.records[0];\n    }\n\n    /**\n     * @property {NGN.DATA.Model} last\n     * Return the last record in the store. Returns `null`\n     * if the store is empty.\n     */\n\n  }, {\n    key: 'last',\n    get: function get() {\n      if (this.records.length === 0) {\n        return null;\n      }\n      return this.records[this.records.length - 1];\n    }\n  }]);\n\n  return Store;\n}(NGN.EventEmitter);\n\n/**\n * indexes\n * An index consists of an object whose key is name of the\n * data field being indexed. The value is an array of record values\n * and their corresponding index numbers. For example:\n *\n * ```js\n * {\n *   \"lastname\": [[\"Butler\", 0, 1, 3], [\"Doe\", 2, 4]]\n * }\n * ```\n * The above example indicates the store has two unique `lastname`\n * values, \"Butler\" and \"Doe\". Records containing a `lastname` of\n * \"Butler\" exist in the record store as the first, 2nd, and 4th\n * records. Records with the last name \"Doe\" are 3rd and 5th.\n * Remember indexes are zero based since records are stored as an\n * array.\n */\n\nNGN.DATA.Store = Store;\n\n'use strict';\n\n/**\n * @class NGN.DATA.Proxy\n * Provides a gateway to remote services such as HTTP and\n * websocket endpoints. This can be used directly to create\n * custom proxies. However; NGN.DATA.HttpProxy and NGN.DATA.WebSocketProxy\n * are also available for use.\n */\n\nvar Proxy = function (_NGN$EventEmitter3) {\n  _inherits(Proxy, _NGN$EventEmitter3);\n\n  function Proxy(config) {\n    _classCallCheck(this, Proxy);\n\n    config = config || {};\n\n    if (!config.store) {\n      throw new Error('NGN.DATA.Proxy requires a NGN.DATA.Store.');\n    }\n\n    var _this24 = _possibleConstructorReturn(this, (Proxy.__proto__ || Object.getPrototypeOf(Proxy)).call(this));\n\n    config.store.proxy = _this24;\n\n    Object.defineProperties(_this24, {\n      /**\n       * @configproperty {NGN.DATA.Store} store (required)\n       * THe store for data being proxied.\n       */\n      store: NGN.const(config.store),\n\n      /**\n       * @configproperty {string} [url=http://localhost\n       * The root URL for making network requests (HTTP/WS/TLS).\n       */\n      url: NGN.public(config.url || 'http://localhost'),\n\n      /**\n       * @config {string} username\n       * If using basic authentication, provide this as the username.\n       */\n      username: NGN.public(config.username || null),\n\n      /**\n       * @config {string} password\n       * If using basic authentication, provide this as the password.\n       */\n      password: NGN.public(config.password || null),\n\n      /**\n       * @config {string} token\n       * If using an access token, provide this as the value. This\n       * will override basic authentication (#username and #password\n       * are ignored). This sets an `Authorization: Bearer <token>`\n       * HTTP header.\n       */\n      token: NGN.public(config.token || null)\n    });\n    return _this24;\n  }\n\n  /**\n   * @property actions\n   * A list of the record changes that have occurred.\n   * @returns {object}\n   * An object is returned with 3 keys representative of the\n   * action taken:\n   *\n   * ```js\n   * {\n   *   create: [NGN.DATA.Model, NGN.DATA.Model],\n   *   update: [NGN.DATA.Model],\n   *   delete: []\n   * }\n   * ```\n   *\n   * The object above indicates two records have been created\n   * while one record was modified and no records were deleted.\n   * **NOTICE:** If you add or load a JSON object to the store\n   * (as opposed to adding an instance of NGN.DATA.Model), the\n   * raw object will be returned. It is also impossible for the\n   * data store/proxy to determine if these have changed since\n   * the NGN.DATA.Model is responsible for tracking changes to\n   * data objects.\n   * @private\n   */\n\n\n  _createClass(Proxy, [{\n    key: 'save',\n    value: function save() {\n      console.warn('Save should be overridden by a proxy implementation class.');\n    }\n  }, {\n    key: 'fetch',\n    value: function fetch() {\n      console.warn('Fetch should be overridden by a proxy implementation class.');\n    }\n  }, {\n    key: 'actions',\n    get: function get() {\n      var me = this;\n      return {\n        create: this.store._created,\n        update: this.store.records.filter(function (record) {\n          if (me.store._created.indexOf(record) < 0 && me.store._deleted.indexOf(record) < 0) {\n            return false;\n          }\n          return record.modified;\n        }).map(function (record) {\n          return record;\n        }),\n        delete: this.store._deleted\n      };\n    }\n  }]);\n\n  return Proxy;\n}(NGN.EventEmitter);\n\nObject.defineProperty(NGN.DATA, 'Proxy', NGN.const(Proxy));","'use strict'\n\n/**\n * @class NGN.EventEmitter\n * @inheritdoc\n */\nNGN.inherit(Object.defineProperties({}, {\n  queued: NGN.private({}),\n\n  /**\n   * @method pool\n   * A helper command to create multiple related subscribers\n   * all at once. This is a convenience function.\n   * @property {string} [prefix]\n   * Supply a prefix to be added to every event. For example,\n   * `myScope.` would turn `someEvent` into `myScope.someEvent`.\n   * @property {Object} subscriberObject\n   * A key:value object where the key is the name of the\n   * unprefixed event and the key is the handler function.\n   * @property {Function} [callback]\n   * A callback to run after the entire pool is registered. Receives\n   * a single {Object} argument containing all of the subscribers for\n   * each event registered within the pool.\n   */\n  pool: NGN.const(function (prefix, group, callback) {\n    if (typeof prefix !== 'string') {\n      group = prefix\n      prefix = ''\n    }\n\n    let pool = {}\n\n    for (let eventName in group) {\n      let topic = (prefix.trim() || '') + eventName\n      if (typeof group[eventName] === 'function') {\n        pool[eventName] = this.on(topic, group[eventName])\n      } else {\n        console.warn('%c' + topic + '%c could not be pooled in the event emitter because it\\'s value is not a function.', NGN.css, '')\n      }\n    }\n    if (callback) {\n      callback(pool)\n    }\n  }),\n\n  /**\n   * @method attach\n   * Attach a function to a topic. This can be used\n   * to forward events in response to asynchronous functions.\n   *\n   * For example:\n   *\n   * ```js\n   * myAsyncDataFetch(NGN.BUS.attach('topicName'))\n   * ```\n   *\n   * This is the same as:\n   *\n   * ```js\n   * myAsyncCall(function(data){\n   *  NGN.BUS.emit('topicName', data)\n   * })\n   * ```\n   * @param {string} eventName\n   * The name of the event to attach a handler method to.\n   * @param {boolean} [preventDefaultAction=false]\n   * Setting this to `true` will execute a `event.preventDefault()` before\n   * attaching the handler.\n   * @returns {function}\n   * Returns a function that will automatically be associated with an event.\n   */\n  attach: NGN.const(function (eventName, preventDefaultAction) {\n    const me = this\n    preventDefaultAction = NGN.coalesce(preventDefaultAction, false)\n\n    return function (e) {\n      if (preventDefaultAction && e.hasOwnProperty('preventDefault')) {\n        e.preventDefault()\n      }\n      let args = NGN.slice(arguments)//NGN.slice(arguments)\n      args.unshift(eventName)\n      me.emit.apply(me, args)\n    }\n  }),\n\n  /**\n   * @method bind\n   * A special subscriber that fires one or more event in response to\n   * to an event. This is used to bubble events up/down an event chain.\n   *\n   * For example:\n   *\n   * ```js\n   * BUS.bind('sourceEvent', ['someEvent','anotherEvent'], {payload:true})\n   * ```\n   * When `sourceEvent` is published, the bind method triggers `someEvent` and\n   * `anotherEvent`, passing the payload object to `someEvent` and\n   * `anotherEvent` subscribers simultaneously.\n   *\n   * @param {String} sourceEvent\n   * The event to subscribe to.\n   * @param {String|Array} triggeredEvent\n   * An event or array of events to fire in response to the sourceEvent.\n   * @param {any} data\n   * Optional data to pass to each bound event handler.\n   * @returns {Object}\n   * Returns an object with a single `remove()` method.\n   */\n  bind: NGN.const(function (eventName, triggers, payload) {\n    triggers = typeof triggers === 'string' ? [triggers] : triggers\n\n    const me = this\n    let listener = function () {\n      let args = NGN.slice(arguments)\n\n      if (payload) {\n        args.push(payload)\n      }\n\n      for (let trigger in triggers) {\n        let argList = args.slice()\n        argList.unshift(triggers[trigger])\n        me.emit.apply(me, argList)\n      }\n    }\n\n    this.on(eventName, listener)\n\n    // Provide handle back for removal of topic\n    return {\n      remove: function () {\n        me.off(eventName, listener)\n      }\n    }\n  }),\n\n  /**\n   * @method queue\n   * This method waits for the specified duration, then publishes an\n   * event once. This will publish the event only once at the end of the\n   * wait period, even if the event is triggered multiple times. This can\n   * be useful when working with many events triggered in rapid succession.\n   *\n   * For example, an NGN.DATA.Model representing a person may be used to\n   * track a user profile. The NGN.DATA.Model fires an event called `field.update`\n   * every time a data field is modified. In many cases, a user may update\n   * multiple fields of their profile using a form with a \"Save\" button.\n   * Instead of generating a new \"save\" (to disk, to memory, to an API, etc)\n   * operation for each field, the publishOnce event can wait until all\n   * changes are made before running the save operation.\n   *\n   * ```js\n   * // Create a data model representing a person.\n   * var Person = new NGN.DATA.Model({....})\n   *\n   * // Create a new person record for a user.\n   * var user = new Person()\n   *\n   * // When the user is modified, save the data.\n   * user.on('field.update', function () {\n   * \t // Wait 300 milliseconds to trigger the save event\n   *   NGN.BUS.queue('user.save', 300)\n   * })\n   *\n   * // Save the user using an API\n   * NGN.BUS.on('user.save', function () {\n   * \t NGN.HTTP.put({\n   * \t   url: 'https://my.api.com/user',\n   * \t   json: user.data\n   * \t })\n   * })\n   *\n   * // Modify the record attributes (which are blank by default)\n   * user.firstname = 'John'\n   * user.lastname = 'Doe'\n   * user.age = 42\n   *\n   * // Make another update 1 second later\n   * setTimeout(function () {\n   *   user.age = 32\n   * }, 1000)\n   * ```\n   *\n   * The code above sets up a model and record. Then it listens to the record\n   * for field updates. Each time it recognizes an update, it queues the \"save\"\n   * event. When the queue matures, it fires the `user.save` event.\n   *\n   * The first `field.update` is triggered when `user.firstname = 'John'` runs.\n   * This initiates a queue for `user.save`, set to mature in 300 millisenconds.\n   * Next, a `field.update` is triggered when `user.lastname = 'Doe'` runs.\n   * This time, since the queue for `user.save` is already initiated, notthing\n   * new happens. Finally, a `field.update` is triggered when `user.age = 42`\n   * runs. Just like the last one, nothing happens since the `user.save` queue\n   * is already active.\n   *\n   * The `user.save` queue \"matures\" after 300 milliseconds. This means after\n   * 300 milliseconds have elapsed, the `user.save` event is triggered. In this\n   * example, it means the `NGN.HTTP.put()` code will be executed. As a result,\n   * all 3 change (firstname, lastname, and age) will be complete before the\n   * API request is executed. The queue is cleared immediately.\n   *\n   * The final update occurs 1 second later (700 milliseconds after the queue\n   * matures). This triggers a `field.update`, but since the queue is no\n   * longer active, it is re-initiated. 300 milliseconds later, the `user.save`\n   * event is fired again, thus executing the API request again (1.3 seconds\n   * in total).\n   * @param {string} eventName\n   * The event/topic to publish/emit.\n   * @param {Number} [delay=300]\n   * The number of milliseconds to wait before firing the event.\n   * @param {Any} [payload]\n   * An optional payload, such as data to be passed to an event handler.\n   */\n  queue: NGN.const(function (eventName, delay) {\n    if (!this.queued.hasOwnProperty(eventName)) {\n      const me = this\n      let args = NGN.slice(arguments)\n      args.splice(1, 1)\n\n      this.queued[eventName] = setTimeout(function () {\n        delete me.queued[eventName]\n        me.emit.apply(me, args)\n      }, delay)\n    }\n  })\n}), NGN.EventEmitter)\n","// Polyfill for IE11 & Safari\n// This is required to make the remove method work properly.\nif (!Array.prototype.findIndex) {\n  Array.prototype.findIndex = function (predicate) { // eslint-disable-line no-extend-native\n    if (this === null) {\n      throw new Error('Array.prototype.findIndex called on null or undefined')\n    }\n    // if (typeof predicate !== 'function') {\n    //   throw new Error('Predicate must be a function (received ' + (typeof predicate) + ')')\n    // }\n    var list = Object(this)\n    var length = list.length >>> 0\n    var thisArg = arguments[1]\n    var value\n\n    for (var i = 0; i < length; i++) {\n      value = list[i]\n      if (predicate.call(thisArg, value, i, list)) {\n        return i\n      }\n    }\n    return -1\n  }\n}\n","'use strict'\n\n/**\n * @class NGN\n * @singleton\n */\n/**\n  * @method define\n  * Create an object definition for a property.\n  * For example:\n  *\n  * ```\n  * Object.defineProperty('attr', NGN.define(true, false, true, 'value'))\n  *\n  * // The snippet above is the same as:\n  * Object.defineProperty(this, 'attr', {\n  *  enumberable: true,\n  *  writable: false,\n  *  configurable: true,\n  *  value: 'value'\n  * })\n  * ```\n  * @param  {boolean} enumerable\n  * Determines if the attribute is considered an accessible part of the object.\n  * Making an attribute enumerable will make it show up as a key in an object,\n  * which can be iterated over (ex: `Object.keys()`). A non-enumerable asset is\n  * treated as a private attribute.\n  * @param  {boolean} writable\n  * Determines whether the value can be changed.\n  * @param  {boolean} configurable\n  * Determines whether the attribute can be removed from the object.\n  * @param  {any} value\n  * The actual value of the attribute.\n  * @private\n  */\nObject.defineProperty(NGN, 'define', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: function (e, w, c, v) {\n    return {\n      enumerable: e,\n      writable: w,\n      configurable: c,\n      value: v\n    }\n  }\n})\n\nObject.defineProperties(NGN, {\n  /**\n   * @method public\n   * Create a `public` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.public('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  public: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, typeof value !== 'function', false, value)\n  }),\n\n  /**\n   * @method private\n   * Create a `private` property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.private('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: true,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  private: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, typeof value !== 'function', false, value)\n  }),\n\n  /**\n   * @method const\n   * Create a `public` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.const('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  const: NGN.define(false, false, false, function (value) {\n    return NGN.define(true, false, false, value)\n  }),\n\n  /**\n   * @method privateconst\n   * Create a `private` constant property definition for an object.\n   * Example:\n   *\n   * ```\n   * Object.defineProperty(this, 'attr', NGN.privateconst('somevalue'))\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  writable: false,\n   *  configurable: false,\n   *  value: 'somevalue'\n   * })\n   * ```\n   * @param  {any} value\n   * Any valid JavaScript value (function, boolean, number, string, etc)\n   * used as the value for the object attribute.\n   * @private\n   */\n  privateconst: NGN.define(false, false, false, function (value) {\n    return NGN.define(false, false, false, value)\n  }),\n\n  /**\n   * @method get\n   * Create a private `getter` property definition for an object.\n   * Public getters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  get: function () {\n   *    return 'somevalue'\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid async JavaScript function with a `return` value.\n   * @private\n   */\n  get: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      get: fn\n    }\n  }),\n\n  /**\n   * @method get\n   * Create a private `setter` property definition for an object.\n   * Public setters are part of the ES2015 class spec.\n   *\n   * Example:\n   *\n   * ```\n   * let myFunction = function () {\n   *  return 'somevalue'\n   * }\n   *\n   * // Longhand equivalent\n   * Object.defineProperty(this, 'attr', {\n   *  enumerable: false,\n   *  set: function (value) {\n   *    somethingElse = value\n   *  }\n   * })\n   * ```\n   * @param  {function} fn\n   * Any valid async JavaScript function with a `return` value.\n   * @private\n   */\n  set: NGN.define(false, false, false, function (fn) {\n    return {\n      enumerable: false,\n      set: fn\n    }\n  })\n})\n\nObject.defineProperties(NGN, {\n  /**\n   * @method extend\n   * Extend the NGN core object. Extending NGN is the equivalent of:\n   *\n   * Example:\n   * ```\n   * NGN.extend('greet', NGN.public(function (recipient) {\n   *  return 'Hello, ' + recipient + '!'\n   * }))\n   *\n   * // Equivalent of:\n   *\n   * Object.defineProperty(NGN, 'greet', {\n   *  enumerable: true,\n   *  writable: false,\n   *  configurable: false,\n   *  value: function (recipient) {\n   *    return 'Hello, ' + recipient + '!'\n   *  }\n   * })\n   * ```\n   * The example above produces a public function available from NGN:\n   *\n   * ```\n   * console.log(NGN.greet('world')) // outputs Hello, world!\n   * @param  {string} attribute\n   * Name of the attribute to add to the object.\n   * @param  {Object} specification\n   * The object specification, i.e.\n   * ```\n   * {\n   *  enumerable: true/false,\n   *  writable: true/false,\n   *  configurable: true/false,\n   *  value: {any}\n   * }\n   *\n   * // OR\n   *\n   * {\n   *  enumerable: true/false,\n   *  get: function () { return ... },\n   *  set: function (value) { some = value ... }\n   * }\n   * ```\n   * @private\n   */\n  extend: NGN.privateconst(function (attribute, specification) {\n    Object.defineProperty(this, attribute, specification)\n  }),\n\n  /**\n   * @method inherit\n   * Inherit the properties of another object/class.\n   * @param  {object|function} source\n   * The source object (i.e. what gets copied)\n   * @param  {object|function} destination\n   * The object properties get copied to.\n   */\n  inherit: NGN.const(function (source, dest) {\n    if (!source || !dest) {\n      return\n    }\n    source = typeof source === 'function' ? source.prototype : source\n    dest = typeof dest === 'function' ? dest.prototype : dest\n    Object.getOwnPropertyNames(source).forEach(function (attr) {\n      const definition = Object.getOwnPropertyDescriptor(source, attr)\n      Object.defineProperty(dest, attr, definition)\n    })\n  }),\n\n  /**\n   * @method slice\n   * Converts an array-like object to an array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.slice(arguments)\n   * }\n   * @param  {Object} obj\n   * The object to slice into an array.\n   * @return {array}\n   * @private\n   */\n  slice: NGN.private(function (obj) {\n    return Array.prototype.slice.call(obj)\n  }),\n\n  /**\n   * @method splice\n   * Converts an array-like object to a spliced array.\n   *\n   * Example:\n   * ```\n   * function () {\n   *  return NGN.splice(arguments)\n   * }\n   * @param  {Object} obj\n   * The object to splice into an array.\n   * @return {array}\n   * @private\n   */\n  splice: NGN.private(function (obj) {\n    return Array.prototype.splice.call(obj)\n  }),\n\n  /**\n   * @method coalesce\n   * Finds the first non-null/defined value in a list of arguments.\n   * This can be used with {@link Boolean Boolean} values, since `true`/`false` is a\n   * non-null/defined value.\n   * @param {Mixed} args\n   * Any number of arguments can be passed to this method.\n   */\n  coalesce: NGN.public(function () {\n    for (let arg in arguments) {\n      if (arguments[arg] !== undefined && arguments[arg] !== null) {\n        return arguments[arg]\n      }\n    }\n    return null\n  }),\n\n  /**\n   * @property {boolean} nodelike\n   * Indicates NGN is running in a node-like environment supporting\n   * the `require` statement. This will detect node, io.js, Electron,\n   * NW.js, and other environments presumably supporting Node.js.\n   * @private\n   */\n  nodelike: NGN.get(function () {\n    let node = false\n    try {\n      node = require !== undefined\n    } catch (e) {}\n    return node\n  }),\n\n  /**\n   * @method dedupe\n   * Deduplicate a simple array.\n   * @param {array} array\n   * The array to deduplicate.\n   * @return {array}\n   * The array with unique records.\n   * @private\n   */\n  dedupe: NGN.private(function (array) {\n    return array.filter(function (element, index) {\n      return array.indexOf(element) === index\n    })\n  }),\n\n  /**\n   * @method typeof\n   * A more specific typeof method.\n   * @param  {any} element\n   * The element to determine the type of.\n   * @return {string}\n   * Returns the type (all lower case).\n   */\n  typeof: NGN.define(false, false, false, function (el) {\n    var value = Object.prototype.toString.call(el).split(' ')[1].replace(/\\]|\\[/gi, '').toLowerCase()\n    if (value === 'function') {\n      if (!el.name) {\n        return el.toString().replace(/\\n/gi, '').replace(/^function\\s|\\(.*$/mgi,'').toLowerCase()\n      } else {\n        value = el.name || 'function'\n      }\n    }\n    return value.toLowerCase();\n   }),\n\n  /**\n   * @method stack\n   * Retrieve the stack trace from a specific code location without throwing\n   * an exception. Files are always listed from the root. This is the default\n   * order in browsers, but the reverse of the normal stack order in node-like\n   * environments.\n   *\n   * For example, the following stack on node shows `_test.js` as the last item\n   * in the array. In node-like environments, the `_test.js` would normally be\n   * the first item in the stacktrace.\n   *\n   * ```js\n   * [\n   *   { path: 'node.js:348:7', file: 'node.js', line: 348, column: 7 },\n   *   { path: 'module.js:575:10',\n   *     file: 'module.js',\n   *     line: 575,\n   *     column: 10 },\n   *   { path: 'module.js:550:10',\n   *     file: 'module.js',\n   *     line: 550,\n   *     column: 10 },\n   *   { path: 'module.js:541:32',\n   *     file: 'module.js',\n   *     line: 541,\n   *     column: 32 },\n   *   { path: '/_test.js:8:14', file: '/_test.js', line: 8, column: 14 }\n   * ]\n   * ```\n   *\n   * By standardizing the order of the stack trace, it is easier to programmatically\n   * identify sources of problems. This method does not prevent developers from\n   * accessing a normal stacktrace.\n   * @private\n   * @returns {array}\n   * Returns an array of objects. Each object contains the file, line, column,\n   * and path within the stack. For example:\n   *\n   * ```\n   * {\n   * \t path: 'path/to/file.js:127:14'\n   *   file: 'path/to/file.js',\n   *   line: 127,\n   *   column: 14\n   * }\n   * ```\n   *\n   * If a stacktrace is unavailable for any reason, the array will contain a\n   * single element like:\n   *\n   * ```js\n   * {\n   *   path: 'unknown',\n   *   file: 'unknown',\n   *   line: 0,\n   *   column: 0\n   * }\n   * ```\n   */\n  stack: NGN.get(function () {\n    const me = this\n    const originalStack = (new Error).stack.split('\\n')\n    let stack = (new Error).stack.split('\\n') || []\n\n    stack = stack.filter(function (item) {\n      return item.split(':').length > 1\n    }).map(function (item) {\n      item = item\n        .replace(/^.*\\s\\(/i, '')\n        .replace(/\\)/gi, '')\n        .replace(/^.*\\@/i, '')\n        .replace((window !== undefined ? window.location.origin : (process !== undefined ? process.cwd() : '')), '')\n        .replace(/^.*\\:\\/\\//, '')\n        .replace(/\\s{1,100}at\\s{1,100}/gi, '')\n        .replace(/anonymous\\>/, 'console')\n        .trim().split(':')\n\n      return {\n        path: item[0].substr(me.nodelike ? 0 : 1, item[0].length - (me.nodelike ? 0 : 1)) + ':' + item[1] + ':' + item[2],\n        file: item[0].substr(me.nodelike ? 0 : 1, item[0].length - (me.nodelike ? 0 : 1)),\n        line: parseInt(item[1], 10),\n        column: parseInt(item[2], 10)\n      }\n    })\n\n    if (stack.length === 0) {\n      return [{\n        path: 'unknown',\n        file: 'unknown',\n        line: 0,\n        column: 0\n      }]\n    } else if (me.nodelike) {\n      stack.reverse()\n    }\n\n    return stack\n  }),\n\n  /**\n   * @property css\n   * A CSS string used for highlighting console output in Chrome and Firefox.\n   *\n   * **Example:**\n   *\n   * ```js\n   * console.log('%cHighlight %c some text and leave the rest normal.', NGN.css, '')\n   * ```\n   * @private\n   */\n  css: NGN.privateconst('font-weight: bold;')\n})\n","'use strict'\n\nObject.defineProperty(NGN, 'global', NGN.privateconst(NGN.nodelike ? global : window))\n\n// Force scope\ndocument.addEventListener('DOMContentLoaded', function () {\n  document.body.classList.add('ngn')\n})\n","'use strict'\n\n/**\n * @class NGN\n * @inheritdoc\n */\n /**\n  * @method createException\n  * Create a custom global exception.\n  * For more information, see the [Custom Exceptions Guide](#!/guide/customerrors).\n  * @param {Object} config\n  * The configuration of the new error.\n  * @param {String} [config.name=NgnError]\n  * The pretty name of the exception. Alphanumeric characters only (underscore is acceptable).\n  * @param {String} [config.type=TypeError]\n  * The type of error. This is commonly `TypeError` or `ReferenceError`, but\n  * it can be any custom value.\n  * @param {String} [config.severity=minor]\n  * A descriptive \"level\" indicating how critical the error is.\n  * @param {String} [config.message=Unknown Error]\n  * The default message to output when none is specified.\n  * @param {Object} [config.custom]\n  * Provide a key/value object of custom attributes for the error.\n  * There are two \"special\" custom attributes: `help` and `cause`.\n  * When provided, these will be written to stdout whenever the error's\n  * stack is viewed.\n  *\n  * For example:\n  *\n  * ```js\n  * require('ngn')\n  *\n  * NGN.createException({\n  *   name: 'Test Problem',\n  *   message: 'An example error.',\n  *   custom: {\n  *     help: 'Remove the throw statement.',\n  *     cause: 'Testing the error output.'\n  *   }\n  * });\n  *\n  * throw TestProblem()\n  * ```\n  * The code above generates the following console output:\n  *\n  * ```sh\n  * Testing the error output.\n  * Remove the throw statement.\n  * /path/to/test.js:12\n  *    throw TestProblem();\n  *    ^\n  *\n  * TestProblem: An example error.\n  *    at null._onTimeout (/path/to/test.js:12:11)\n  *    at Timer.listOnTimeout (timers.js:92:15)\n  * ```\n  */\nNGN.extend('createException', NGN.public(function (config) {\n  config = config || {}\n  config = typeof config === 'string' ? { message: config } : config\n  config.name = config.name || 'NgnError'\n  config.name = config.name.replace(/[^a-zA-Z0-9_]/gi, '')\n\n  // Create the error as a function\n  NGN.global[config.name] = function () {\n    if (arguments.length > 0) {\n      config.message = arguments[0]\n    }\n    return new CustomException(config)\n  }\n}))\n","/**\n * @class DOM\n * A utility class to simplify some DOM management tasks.\n */\nNGN.DOM = {}\n\nObject.defineProperties(NGN.DOM, {\n  /**\n   * @method ready\n   * Executes code after the DOM is loaded.\n   * @param {function} callback\n   * The function to call when the DOM is fully loaded.\n   */\n  ready: NGN.const(function (callback) {\n    document.addEventListener('DOMContentLoaded', callback)\n  }),\n\n  /**\n   * @method destroy\n   * Remove a DOM element.\n   * @param {HTMLElement|NodeList|String|Array} node\n   * Accepts a single `HTMLElement`, a `NodeList`, a CSS selector, or\n   * an array of `HTMLElements`/`NodeList`/CSS Selectors.\n   */\n  destroy: NGN.const(function (element) {\n    // Process a CSS selector\n    if (typeof element === 'string') {\n      let str = element\n      element = document.querySelectorAll(element)\n\n      if (element.length === 0) {\n        console.warn('The \\\"' + str + '\\\" selector did not return any elements.')\n        return\n      }\n      // Iterate through results and remove each element.\n      NGN.slice(element).forEach(this.destroy)\n    } else {\n      switch (NGN.typeof(element)) {\n        case 'array':\n          element.forEach(this.destroy)\n          return\n        case 'nodelist':\n          NGN.slice(element).forEach(this.destroy)\n          return\n        case 'htmlelement':\n          element.parentNode.removeChild(element)\n          return\n        default:\n          if (/^html.*element$/.test(NGN.typeof(element))) {\n            element.parentNode.removeChild(element)\n            return\n          }\n          console.warn('An unknown error occurred while trying to remove DOM elements.')\n          console.log('Unknown Element', element)\n      }\n    }\n  }),\n\n  /**\n   * @method findParent\n   * Find a distant parent of a DOM element. This can be thought\n   * of as a reverse CSS selector that traverses UP the DOM chain\n   * to find the parent element.\n   *\n   * For example:\n   *\n   * Assume the following HTML structure & JS code:\n   *\n   * ```html\n   * <section>\n   *   <header class=\"MyGroup\">\n   *     <div>\n   *       <div>\n   *         <button>Delete Entire Group</button>\n   *       </div>\n   *     </div>\n   *   </header>\n   * </section>\n   * ```\n   *\n   * ```js\n   * ref.find('button.remove').addEventListener('click', function (event) {\n   *   event.preventDefault()\n   *   let removeButton = event.currentTarget\n   *   let group = ref.findParent(removeButton,'header')\n   *   ref.destroy(group)\n   * })\n   * ```\n   *\n   * The code above listens for a click on the button. When the button\n   * is clicked, the `findPerent` method recognizes the \"Delete Entire Group\"\n   * button and traverses UP the DOM chain until it finds a `header` DOM\n   * element. The `header` DOM element is returned (as `group` letiable). The\n   * group is then removed using the `ref.destroy` method.\n   *\n   * Alternatively, the same effect could have been achieved if line 4\n   * of the JS code was:\n   * ```js\n   * let group = ref.findParent(removeButton, '.MyGroup')\n   * ```\n   * @param {HTMLElement|String} element\n   * The DOM element or a CSS selector string identifying the\n   * element whose parent should be found.\n   * @param {String} selector\n   * A minimal CSS selector used to identify the parent.\n   * @param {Number} maxDepth\n   * The maximum number of elements to traverse. This can be used to\n   * cap a selector and force it to fail before reaching a known limit.\n   * By default, there is no limit (i.e. maxDepth=null).\n   * @returns {HTMLElement}\n   * Responds with the DOM Element, or `null` if none was found.\n   */\n  findParent: NGN.const(function (node, selector, maxDepth) {\n    if (typeof node === 'string') {\n      node = document.querySelectorAll(node)\n      if (node.length === 0) {\n        console.warn('\\\"' + node + '\\\" is an invalid CSS selector (Does not identify any DOM elements).')\n        return null\n      }\n      node = node[0]\n    }\n\n    let currentNode = node.parentNode\n    let i = 0\n    maxDepth = typeof maxDepth === 'number' ? maxDepth : -1\n\n    while (currentNode.parentNode.querySelector(selector) === null && currentNode.nodeName !== 'BODY') {\n      i++\n      if (maxDepth > 0 && i > maxDepth) {\n        return null\n      }\n      currentNode = currentNode.parentNode\n    }\n\n    return currentNode\n  }),\n\n  /**\n   * @method indexOfParent\n   * Returns the zero-based index of the DOM element related\n   * to its parent element.\n   * For example:\n   *\n   * `html\n   * <div>\n   *   <p>...</p>\n   *   <p>...</p>\n   *   <button id=\"btn\"></button>\n   *   <p>...</p>\n   * </div>\n   * ```\n   *\n   * ```js\n   * let i = NGN.DOM.indexOfParent(document.getElementById('btn'))\n   * console.log(i) // 2\n   * ```\n   * @param {HTMLElement} el\n   * The reference element.\n   * @returns {number}\n   */\n  indexOfParent: NGN.const(function (element) {\n    return NGN.slice(element.parentNode.children).indexOf(element)\n  })\n})\n","/**\n * @class BUS\n * The bus acts as a pub/sub messaging system (as opposed to a queue). It is primarily\n * designed for asynchronous communication between javascript objects, but can also be\n * bound to DOM events.\n *\n * The most common use looks like:\n * ```js\n *   var subscriber = NGN.BUS.subscribe('test', function () {\n *     console.log('test handled')\n *   })\n *\n *   NGN.BUS.subscribeOnce('test', function () {\n *     console.log('RESPOND ONCE!')\n *   })\n *\n *   NGN.BUS.publish('test') // Outputs \"test handled\" and \"RESPOND ONCE\".\n *\n *   NGN.BUS.publish('test') // Outputs \"test handled\" only.\n *\n *   subscriber.unsubscribe() // Removes the listener\n *\n *   NGN.BUS.publish('test') // Outputs nothing since the subscription was removed.\n * ```\n * There are a few aliases for ease of use, including `on() --> subscribe()`,\n * `once() --> subscribeOnce()`, and `emit() --> publish()`.\n *\n * It is also possible to use a wildcard in a subscription.\n *\n * ```js\n *   var subscriber = NGN.BUS.subscribe('test.*', function () {\n *     console.log('test handled')\n *   })\n *   var subscriber = NGN.BUS.subscribe('test.create', function () {\n *     console.log('test create handled')\n *   })\n *\n *   NGN.BUS.publish('test.create') // Outputs \"test handled\" and \"test create handled\"\n *\n *   NGN.BUS.publish('test.delete') // Outputs \"test handled\"\n * ```\n * @singleton\n */\nNGN.extend('BUS', NGN.const(new NGN.EventEmitter()))\n","/**\n * @class NGN.ref\n * A global \"pointer\" to DOM elements. This is used to reference and manipulate\n * DOM elements in a simple and standard way, without restricting native functionality.\n */\n'use strict'\n\nNGN.ref = new function () {\n  var requireBUS = function (trigger, event, scope, nm, preventDefault) {\n    if (NGN.BUS === undefined) {\n      return console.error('The event BUS is required for ' + nm + '().')\n    }\n    preventDefault = NGN.coalesce(preventDefault, false)\n    var fn = function (e) {\n      if (preventDefault && e.preventDefault) {\n        e.preventDefault()\n      }\n      NGN.BUS.emit(event, e)\n    }\n    scope.addEventListener(trigger, fn)\n  }\n\n  var qs = function (value, selector, all) {\n    if (typeof value === 'string') {\n      return document[all ? 'querySelector' : 'querySelectorAll']((value + ' > ' + selector).trim())\n    }\n    return value[all ? 'querySelector' : 'querySelectorAll'](selector.trim())\n  }\n\n  Object.defineProperties(this, {\n\n    keys: NGN.define(false, true, false, {}),\n\n    _find: NGN.define(false, false, false, function (value, selector) {\n      if (typeof value === 'string') {\n        var reference = NGN.ref.find((value + ' > ' + selector).trim())\n        if (reference.length === 0) {\n          var tmpref = NGN.ref.find((value).trim())[0].parentNode.querySelectorAll(selector)\n          if (tmpref.length > 0) {\n            if (tmpref.length === 1) {\n              return tmpref[0]\n            }\n            return tmpref\n          }\n        }\n        return reference\n      }\n      return NGN.ref.find(value.querySelectorAll(selector))\n    }),\n\n    /**\n     * @method find\n     * Retrieve the DOM element(s) for the given selector. This method provides\n     * an **unmanaged** reference object.\n     * @private\n     * @param {String} selector\n     * The selector (CSS-style).\n     * @returns {ref}\n     * Returns an instance of the reference.\n     */\n    find: NGN.define(false, false, false, function (value) {\n      var html = typeof value !== 'string'\n      var els = html === false ? document.querySelectorAll(value) : value\n      var result = null\n\n      if (els.length === 1) {\n        if (!els[0].hasOwnProperty('isArray')) {\n          Object.defineProperties(els[0], {\n            isArray: NGN.get(function () {\n              return false\n            }, false)\n          })\n        }\n\n        if (!els[0].hasOwnProperty('find')) {\n          Object.defineProperty(els[0], 'find', NGN.const(function (selector) {\n            return NGN.ref._find(value, selector)\n          }))\n        }\n\n        if (!els[0].hasOwnProperty('forward')) {\n          Object.defineProperty(els[0], 'forward', NGN.const(function (trigger, event) {\n            requireBUS(trigger, event, this, 'forward')\n          }))\n        }\n\n        if (!els[0].hasOwnProperty('on')) {\n          Object.defineProperty(els[0], 'on', NGN.const(function () {\n            this.addEventListener.apply(this, arguments)\n          }))\n        }\n\n        result = els[0]\n      } else {\n        var base = NGN.slice(els)\n        if (NGN.typeof(els) === 'nodelist' && base.length === 1) {\n          base = base[0]\n        }\n\n        // Apply querySelector/All to the response for chaining.\n        Object.defineProperties(base, {\n          querySelector: NGN.define(false, false, false, function (selector) {\n            qs(value, selector)\n          }),\n\n          querySelectorAll: NGN.define(false, false, false, function (selector) {\n            qs(value, selector, true)\n          }),\n\n          addEventListener: NGN.define(false, false, false, function (evt, fn) {\n            for (var el = 0; el < this.length; el++) {\n              this[el].addEventListener(evt, fn)\n            }\n          }),\n\n          removeEventListener: NGN.define(false, false, false, function (evt, fn) {\n            for (var el = 0; el < this.length; el++) {\n              this[el].removeEventListener(evt, fn)\n            }\n          }),\n\n          find: NGN.const(function (selector) {\n            return NGN.ref._find(value, selector)\n          }),\n\n          isArray: NGN.get(function () {\n            return true\n          }, false),\n\n          forward: NGN.define(false, false, false, function (trigger, event) {\n            requireBUS(trigger, event, this, 'forward')\n          })\n        })\n        result = base\n      }\n\n      return result\n    }),\n\n    /**\n     * @method create\n     * Add a reference.\n     * @param {String} [key]\n     * The key/name of the reference. For example, if this is `myElement`,\n     * then `ref.myElement` will return a pointer to this reference.\n     * @param {string} selector\n     * The CSS selector path.\n     */\n    create: NGN.const(function (key, value) {\n      // If the key is not provided but the value is a DOM element, make\n      // an ephemeral reference.\n      if (!value && typeof key !== 'string') {\n        return this.find(key)\n      }\n\n      // Basic error checking\n      if (typeof key !== 'string' && typeof key !== 'number') {\n        throw new Error('Cannot add a non-alphanumeric selector reference.')\n      }\n      if (key.trim().length === 0) {\n        throw new Error('Cannot add a blank selector reference.')\n      }\n      if (value === undefined || value === null || value.trim().length === 0) {\n        throw new Error('Cannot create a null/undefined selector reference.')\n      }\n\n      // Create a reference object\n      var cleankey = this.cleanKey(key)\n      var me = this\n      Object.defineProperty(NGN.ref, cleankey, NGN.private(value))\n\n      Object.defineProperty(NGN.ref, key, {\n        enumerable: true,\n        get: function () {\n          return me.find(value)\n        },\n        set: function (val) {\n          if (val === undefined || val === null || val.trim().length === 0) {\n            throw new Error('Cannot create a null/undefined selector reference.')\n          }\n          NGN.ref[cleankey] = val\n        }\n      })\n\n      this.keys[key] = value\n      this.keys[this.cleanKey(key)] = value\n    }),\n\n    /**\n     * @method remove\n     * Removes a key from the reference manager.\n     */\n    remove: NGN.const(function (key) {\n      if (this[key]) {\n        delete this[key]\n        delete this.keys[key]\n      }\n      var ck = this.cleanKey(key)\n      if (this[ck]) {\n        delete this[ck]\n        delete this.keys[ck]\n      }\n    }),\n\n    /**\n     * @method cleanKey\n     * Creates a clean version of the key used to uniquely identify the reference.\n     * @private\n     * @param {String} key\n     * The key to clean.\n     */\n    cleanKey: NGN.define(false, false, false, function (key) {\n      return key.replace(/[^A-Za-z0-9\\_\\#\\$\\@\\-\\+]/gi, '') + key.length\n    }),\n\n    /**\n     * @property json\n     * A JSON representation of the managed keys and their associated selectors.\n     * @returns {Object}\n     * A key:selector object.\n     */\n    json: {\n      enumerable: true,\n      get: function () {\n        var me = this\n        var obj = {}\n\n        Object.keys(this).forEach(function (el) {\n          if (me.hasOwnProperty(el) && ['json', 'find', 'remove'].indexOf(el.trim().toLowerCase()) < 0 && typeof me[el] !== 'function') {\n            obj[el] = me.keys[el]\n          }\n        })\n        return obj\n      }\n    }\n  })\n}()\n","/**\n * @class NGN.NET\n * A library to issue network requests, typically viaHTTP/S requests.\n * This acts as an AJAX library among other things.\n * @author Corey Butler\n * @singleton\n */\nconst parser = new DOMParser()\nlet fs = NGN.nodelike ? require('fs') : null\n\nclass Network {\n  constructor () {\n    Object.defineProperties(this, {\n      /**\n       * @method xhr\n       * Issue an XHR request.\n       * @private\n       * @param  {Function} callback\n       * The callback to execute when the request finishes (or times out.)\n       */\n      xhr: NGN.privateconst(function (callback) {\n        let res\n\n        if (window.XMLHttpRequest) {\n          // code for IE7+, Firefox, Chrome, Opera, Safari\n          res = new XMLHttpRequest()\n        }\n\n        res.onreadystatechange = function () {\n          if (res.readyState === 4) {\n            if (callback) {\n              callback(res)\n            }\n          }\n        }\n\n        return res\n      }),\n\n      /**\n       * @method run\n       * A wrapper to execute a request.\n       * @private\n       * @param  {string} method required\n       * The method to issue, such as GET, POST, PUT, DELETE, OPTIONS, etc.\n       * @param  {string} url\n       * The URL where the request is issued to.\n       * @param  {Function} callback\n       * A function to call upon completion.\n       */\n      run: NGN.privateconst(function (method, url, callback) {\n        let res = NGN.NET.xhr(callback)\n        res.open(method, url, true)\n        res.send()\n      }),\n\n      /**\n       * @method applyRequestSettings\n       * Apply any configuration details to issue with the request,\n       * such as `username`, `password`, `headers`, etc.\n       * @private\n       * @param {object} xhr\n       * The XHR request object.\n       * @param {object} cfg\n       * The key/value configuration object to apply to the request.\n       * @param {object} cfg.params\n       * A key/value object containing URL paramaters to be passed with the request.\n       * These will automatically be URI-encoded.\n       * @param {object} cfg.headers\n       * A key/value object containing additional headers and associated values to\n       * be passed with the request.\n       * @param {object} cfg.body\n       * An arbitrary body to pass with the request. If no `Content-Type` header is\n       * provided, a `Content-Type: application/textcharset=UTF-8` header is automatically supplied.\n       * This cannot be used with @cfg.json.\n       * @param {object} cfg.json\n       * A JSON object to be sent with the request. It will automatically be\n       * parsed for submission. By default, a `Content-Type: application/json`\n       * header will be applied (this can be overwritten using @cfg.headers).\n       * @param {object} cfg.form\n       * This accepts a key/value object of form elements, or a reference to a <FORM>\n       * HTML element. This automatically adds the appropriate headers.\n       * @param {string} username\n       * A basicauth username to add to the request. This is sent in plain\n       * text, so using SSL to encrypt/protect it is recommended.\n       * @param {string} password\n       * A basicauth password to add to the request. This is sent in plain\n       * text, so using SSL to encrypt/protect it is recommended.\n       * @param {boolean} [withCredentials=false]\n       * indicates whether or not cross-site `Access-Control` requests should be\n       * made using credentials such as cookies or authorization headers.\n       * The default is `false`.\n       */\n      applyRequestSettings: NGN.privateconst(function (xhr, cfg) {\n        if (!xhr || !cfg) {\n          throw new Error('No XHR or configuration object defined.')\n        }\n\n        // Add URL Parameters\n        if (cfg.params) {\n          let parms = Object.keys(cfg.params).map(function (parm) {\n            return parm + '=' + encodeURIComponent(cfg.params[parm])\n          })\n          cfg.url += '?' + parms.join('&')\n        }\n\n        xhr.open(cfg.method || 'POST', cfg.url, true)\n\n        // Set headers\n        cfg.header = cfg.header || cfg.headers || {}\n        Object.keys(cfg.header).forEach(function (header) {\n          xhr.setRequestHeader(header, cfg.header[header])\n        })\n\n        // Handle body (Blank, plain text, or JSON)\n        let body = null\n        if (cfg.json) {\n          if (!cfg.header || (cfg.header && !cfg.header['Content-Type'])) {\n            xhr.setRequestHeader('Content-Type', 'application/json')\n          }\n          body = JSON.stringify(cfg.json).trim()\n        } else if (cfg.body) {\n          if (!cfg.header || (cfg.header && !cfg.header['Content-Type'])) {\n            xhr.setRequestHeader('Content-Type', 'application/text')\n          }\n          body = cfg.body\n        } else if (cfg.form) {\n          body = new FormData()\n          Object.keys(cfg.form).forEach(function (el) {\n            body.append(el, cfg.form[el])\n          })\n        }\n\n        // Handle withCredentials\n        if (cfg.withCredentials) {\n          xhr.withCredentials = cfg.withCredentials\n        }\n\n        // Handle credentials sent with request\n        if (cfg.username && cfg.password) {\n          // Basic Auth\n          xhr.setRequestHeader('Authorization', 'Basic ' + btoa(cfg.username + ':' + cfg.password))\n        } else if (cfg.accessToken) {\n          // Bearer Auth\n          xhr.setRequestHeader('Authorization', 'Bearer ' + cfg.accessToken)\n        }\n\n        return body\n      }),\n\n      /**\n       * @method prepend\n       * A helper method to prepend arguments.\n       * @private\n       * @param  {[type]} args [description]\n       * @param  {[type]} el   [description]\n       * @return {[type]}      [description]\n       */\n      prepend: NGN.privateconst(function (args, el) {\n        args = NGN.slice(args)\n        args.unshift(el)\n        return args\n      }),\n\n      /**\n       * @method getFile\n       * A \"get\" method specifically for node-like environments.\n       * @param {string} url\n       * The URL to issue the request to.\n       * @param {Function} callback\n       * A callback method to run when the request is complete.\n       * This receives the response object as the only argument.\n       * @private\n       */\n      getFile: NGN.privateconst(function (url) {\n        if (fs !== null) {\n          let rsp = {\n            status: fs.existsSync(url.replace('file://', '')) ? 200 : 400\n          }\n          rsp.responseText = rsp.status === 200 ? fs.readFileSync(url.replace('file://', '')).toString() : 'File could not be found.'\n          return rsp\n        } else {\n          throw new Error(url + ' does not exist or could not be found.')\n        }\n      }),\n\n      /**\n       * @method normalizeUrl\n       * Cleanup a URL.\n       * @private\n       */\n      normalizeUrl: NGN.privateconst(function (url) {\n        let uri = []\n\n        url.split('/').forEach(function (el) {\n          if (el === '..') {\n            uri.pop()\n          } else if (el !== '.') {\n            uri.push(el)\n          }\n        })\n\n        return uri.join('/').replace(/\\:\\/{3,50}/gi, '://')\n      }),\n\n      /**\n       * @method processImport\n       * A helper class to process imported content and place\n       * it in the DOM accordingly.\n       * @param {string} url\n       * The URL of remote HTML snippet.\n       * @param {HTMLElement} target\n       * The DOM element where the resulting code should be appended.\n       * @param {string} callback\n       * Returns the HTMLElement, which can be directly inserted into the DOM.\n       * @param {HTMLElement} callback.element\n       * The new DOM element/NodeList.\n       * @param {boolean} [before=false]\n       * If set to true, insert before the callback.element.\n       * @private\n       */\n      processImport: NGN.privateconst(function (url, target, callback, before) {\n        before = before !== undefined ? before : false\n        this.import(url, function (element) {\n          if (typeof element === 'string') {\n            element = document.createTextNode(element)\n          } else if (element.length) {\n            let out = []\n            NGN.slice(element).forEach(function (el) {\n              if (before) {\n                out.push(target.parentNode.insertBefore(el, target))\n                target = el\n              } else {\n                out.push(target.appendChild(el))\n              }\n            })\n            callback && callback(out)\n            return\n          }\n          if (before) {\n            target.parentNode.insertBefore(element, target)\n          } else {\n            target.appendChild(element)\n          }\n          callback && callback(element)\n        })\n      }),\n\n      /**\n       * @method domainRoot\n       * Returns the root (no http/s) of the URL.\n       * @param {string} url\n       * The URL to get the root of.\n       * @private\n       */\n      domainRoot: NGN.privateconst(function (url) {\n        let r = (url.search(/^https?\\:\\/\\//) !== -1 ? url.match(/^https?\\:\\/\\/([^\\/?#]+)(?:[\\/?#]|$)/i, '') : url.match(/^([^\\/?#]+)(?:[\\/?#]|$)/i, ''))\n        return r === null || r[1].length < 3 ? window.location.host : r[1]\n      }),\n\n      /**\n       * @method isCrossOrigin\n       * Determine if accessing a URL is considered a cross origin request.\n       * @param {string} url\n       * The URL to identify as a COR.\n       * @returns {boolean}\n       * @private\n       */\n      isCrossOrigin: NGN.privateconst(function (url) {\n        return this.domainRoot(url) !== window.location.host\n      }),\n\n      /**\n       * @method prelink\n       * A helper method to construct pre-fetch style DOM elements.\n       * This also fires an event when the element is added to the DOM.\n       * @param {string} url\n       * The URL of the operation.\n       * @param {string} rel\n       * The type of operation. For example: `preconnect`.\n       * @param {boolean} [crossorigin]\n       * Set to `true` to identify the request as a cross origin request.\n       * By default, NGN will compare the URL to the current URL in an\n       * attempt to determine if the request is across origins.\n       * @private\n       */\n      prelink: NGN.privateconst(function (url, rel, cor) {\n        if (!document.head) {\n          console.warn('Cannot use a preconnect, predns, etc because there is no HEAD in the HTML document.')\n          return\n        }\n\n        let p = document.createElement('link')\n        p.rel = rel\n        p.href = url.trim().toLowerCase().substr(0, 4) !== 'http' ? this.normalizeUrl(window.location.origin + window.location.pathname + url) : url\n\n        NGN.coalesce(cor, this.isCrossOrigin(url)) && (p.setAttribute('crossorigin', 'true'))\n        document.head.appendChild(p)\n        NGN.BUS.emit('network.' + rel)\n      }),\n\n      importCache: NGN.private({}),\n\n      createElement: NGN.privateconst(function (str) {\n        return parser.parseFromString(str, 'text/html').querySelector('body').children\n      }),\n\n      applyData: NGN.privateconst(function (tpl, data, callback) {\n        if (tpl === undefined) {\n          console.warn('Empty template.')\n          callback && callback()\n          return\n        }\n\n        // Apply data to the template.\n        Object.keys(data).forEach(function (key) {\n          let re = new RegExp('\\{\\{' + key + '\\}\\}', 'gm')\n          tpl = tpl.replace(re, data[key])\n        })\n\n        // Clear any unused template code\n        tpl = tpl.replace(/(\\{\\{.*\\}\\})/gm, '')\n\n        let el = this.createElement(tpl)\n        callback && callback(el[0])\n      })\n    })\n  }\n\n  /**\n   * @method send\n   * Send the request via HTTP/S.\n   * @param  {object} cfg\n   * The configuration to use when sending the request. See @applyRequestSettings#cfg\n   * for configuration details.\n   * @param  {Function} callback\n   * A callback to excute upon completion. This receives a standard response\n   * object.\n   */\n  send (cfg, callback) {\n    cfg = cfg || {}\n    let res = this.xhr(callback)\n    let body = this.applyRequestSettings(res, cfg)\n    res.send(body)\n  }\n\n  /**\n   * @method get\n   * Issue a `GET` request.\n   * @param {string} url\n   * The URL to issue the request to.\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  get () {\n    if (typeof arguments[0] === 'object') {\n      let cfg = arguments[0]\n      cfg.method = 'GET'\n      cfg.url = typeof arguments[1] === 'string' ? arguments[1] : cfg.url\n      if (cfg.url.substr(0, 4) && NGN.nodelike) {\n        return arguments[arguments.length - 1](this.getFile(cfg.url))\n      }\n      return this.send(cfg, arguments[arguments.length - 1])\n    }\n    if (arguments[0].substr(0, 4) === 'file' && NGN.nodelike) {\n      return arguments[arguments.length - 1](this.getFile(arguments[0]))\n    }\n    this.run.apply(this.run, this.prepend(arguments, 'GET'))\n  }\n\n  /**\n   * @method head\n   * Issue a `HEAD` request.\n   * @param {string} url\n   * The URL to issue the request to.\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  head (uri, callback) {\n    if (typeof arguments[0] === 'object') {\n      let cfg = arguments[0]\n      cfg.method = 'HEAD'\n      cfg.url = typeof arguments[1] === 'string' ? arguments[1] : cfg.url\n      return this.send(cfg, arguments[arguments.length - 1])\n    }\n    this.run.apply(this.run, this.prepend(arguments, 'HEAD'))\n  }\n\n  /**\n   * @method put\n   * Issue a `PUT` request.\n   * @param  {object} cfg\n   * See the options for @send#cfg\n   * @param  {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  put (cfg, callback) {\n    cfg = cfg || {}\n    cfg.method = 'PUT'\n    cfg.url = cfg.url || window.location\n    this.send(cfg, callback)\n  }\n\n  /**\n   * @method post\n   * Issue a `POST` request.\n   * @param  {object} cfg\n   * See the options for @send#cfg\n   * @param  {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  post (cfg, callback) {\n    cfg = cfg || {}\n    cfg.method = 'POST'\n    cfg.url = cfg.url || window.location\n    this.send(cfg, callback)\n  }\n\n  /**\n   * @method delete\n   * Issue a `DELETE` request.\n   * @param {string} url\n   * The URL to issue the request to.\n   * @param {Function} callback\n   * A callback method to run when the request is complete.\n   * This receives the response object as the only argument.\n   */\n  delete () {\n    this.run.apply(this.run, this.prepend(arguments, 'DELETE'))\n  }\n\n  /**\n   * @method json\n   * This is a shortcut method for creating a `GET` request and\n   * auto-processing the response body into a JSON object.\n   * @param  {string} url\n   * The URL to issue the request to.\n   * @param  {Function} callback\n   * This receives a JSON response object from the server as its only argument.\n   */\n  json (cfg, url, callback) {\n    if (typeof cfg === 'string') {\n      callback = url\n      url = cfg\n      cfg = null\n    }\n    if (cfg === null) {\n      this.run('GET', url, function (res) {\n        if (res.status !== 200) {\n          throw Error('Could not retrieve JSON data from ' + url + ' (Status Code: ' + res.status + ').')\n        }\n        try {\n          res.json = JSON.parse(res.responseText)\n        } catch (e) {\n          res.json = null\n        }\n        callback && callback(res.json)\n      })\n    } else {\n      cfg.url = url\n      this.get(cfg, function (res) {\n        if (res.status !== 200) {\n          throw Error('Could not retrieve JSON data from ' + url + ' (Status Code: ' + res.status + ').')\n        }\n        try {\n          res.json = JSON.parse(res.responseText)\n        } catch (e) {\n          res.json = null\n        }\n        callback && callback(res.json)\n      })\n    }\n  }\n\n  /**\n   * @method import\n   * Import a remote HTML fragment.\n   * @param {string|array} url\n   * The URL of remote HTML snippet. If the URL has a `.js` or `.css`\n   * extension, it will automatically be added to the `<head>`.\n   * It is also possible to provide an array of string values. Take\n   * note that the callback may return a different value based on\n   * this input.\n   * @param {string|array} callback\n   * If a **string** is provided as the URL, this returns the HTMLElement,\n   * which can be directly inserted into the DOM. If an **array** is\n   * provided as the URL, the callback will return an array of HTMLElements.\n   * For example:\n   *\n   * ```js\n   * NGN.NET.import([\n   *   '/path/a.html',\n   *   '/path/b.html',\n   *   '/path/a.js'],\n   *    function (elements){\n   *      console.dir(elements)\n   *    }\n   * })\n   *```\n   * The result `elements` array would look like:\n   *\n   * ```js\n   * [\n   *   HTMLElement, // DOM element created for a.html\n   *   HTMLElement, // DOM element created for b.html\n   *   HTMLElement  // DOM element created for a.js (this will be in the <head>)\n   * ]\n   * ```\n   * The last array element is `null`\n   * @param {boolean} [bypassCache=false]\n   * When set to `true`, bypass the cache.\n   * @fires html.import\n   * Returns the HTMLElement/NodeList as an argument to the event handler.\n   */\n  import (url, callback, bypassCache) {\n    // Support multiple simultaneous imports\n    if (Array.isArray(url)) {\n      let self = this\n      let out = new Array(url.length)\n      let i = 0\n      url.forEach(function (uri, num) {\n        self.import(uri, function (el) {\n          out[num] = el\n          i++\n        }, bypassCache)\n      })\n      if (callback) {\n        let int = setInterval(function () {\n          if (i === url.length) {\n            clearInterval(int)\n            callback(out)\n          }\n        }, 5)\n      }\n      return\n    }\n\n    // Support JS/CSS\n    let ext = null\n    try {\n      ext = url.split('/').pop().split('?')[0].split('.').pop().toLowerCase()\n      let s\n      if (ext === 'js') {\n        s = document.createElement('script')\n        s.setAttribute('type', 'text/javascript')\n        s.setAttribute('src', url)\n      } else if (ext === 'css') {\n        s = document.createElement('link')\n        s.setAttribute('rel', 'stylesheet')\n        s.setAttribute('type', 'text/css')\n        s.setAttribute('href', url)\n      }\n      s.onload = typeof callback === 'function' ? function () { callback(s) } : function () {}\n      document.getElementsByTagName('head')[0].appendChild(s)\n    } catch (e) {}\n\n    if (['js', 'css'].indexOf((ext || '').trim().toLowerCase()) >= 0) {\n      return\n    }\n\n    bypassCache = typeof bypassCache === 'boolean' ? bypassCache : false\n\n    // If a local reference is provided, complete the path.\n    if (url.substr(0, 4) !== 'http') {\n      let path = window.location.href.split('/')\n      path.pop()\n      url = path.join('/') + '/' + url\n    }\n\n    // Use the cache if defined & not bypassed\n    if (!bypassCache && this.importCache.hasOwnProperty(url)) {\n      let doc = this.createElement(this.importCache[url])\n      callback && callback(doc.length === 1 ? doc[0] : doc)\n      if (window.NGN.BUS) {\n        window.NGN.BUS.emit('html.import', doc.length === 1 ? doc[0] : doc)\n      }\n      // console.warn('Used cached version of '+url)\n      return\n    }\n\n    // Retrieve the file content\n    let me = this\n    this.get(url, function (res) {\n      if (res.status !== 200) {\n        return console.warn('Check the file path of the snippet that needs to be imported. ' + url + ' could not be found (' + res.status + ')')\n      }\n\n      let doc = me.createElement(res.responseText)\n      me.importCache[url] = res.responseText\n\n      if (doc.length === 0) {\n        console.warn(me.normalizeUrl(url) + ' import has no HTML tags.')\n        callback && callback(res.responseText)\n        if (window.NGN.BUS) {\n          window.NGN.BUS.emit('html.import', res.responseText)\n        }\n      } else {\n        let el = doc.length === 1 ? doc[0] : doc\n        callback && callback(el)\n        if (window.NGN.BUS) {\n          window.NGN.BUS.emit('html.import', el)\n        }\n      }\n    })\n  }\n\n  /**\n   * @method importTo\n   * This helper method uses the #import method to retrieve an HTML\n   * fragment and insert it into the specified DOM element. This is\n   * the equivalent of using results of the #import to retrieve a\n   * snippet, then doing a `target.appendChild(importedElement)`.\n   * @param {string} url\n   * The URL of remote HTML snippet.\n   * @param {HTMLElement} target\n   * The DOM element where the resulting code should be appended.\n   * @param {string} callback\n   * Returns the HTMLElement, which can be directly inserted into the DOM.\n   * @param {HTMLElement} callback.element\n   * The new DOM element/NodeList.\n   */\n  importTo (url, target, callback) {\n    this.processImport(url, target, callback)\n  }\n\n  /**\n   * @method importBefore\n   * This helper method uses the #import method to retrieve an HTML\n   * fragment and insert it into the DOM before the target element. This is\n   * the equivalent of using results of the #import to retrieve a snippet,\n   * then doing a `target.parentNode.insertBefore(importedElement, target)`.\n   * @param {string} url\n   * The URL of remote HTML snippet.\n   * @param {HTMLElement} target\n   * The DOM element where the resulting code should be appended.\n   * @param {string} callback\n   * Returns the HTMLElement/NodeList, which can be directly inserted into the DOM.\n   * @param {HTMLElement} callback.element\n   * The new DOM element/NodeList.\n   */\n  importBefore (url, target, callback) {\n    this.processImport(url, target, callback, true)\n  }\n\n  /**\n   * @method predns\n   * This notifies the browser domains which will be accessed at a later\n   * time. This helps the browser resolve DNS inquiries quickly.\n   * @param {string} domain\n   * The domain to resolve.\n   * @param {boolean} [crossorigin]\n   * Set to `true` to identify the request as a cross origin request.\n   * By default, NGN will compare the URL to the current URL in an\n   * attempt to determine if the request is across origins.\n   * @fires network-dns-prefetch\n   * Fired when a pre-fetched DNS request is issued to the browser.\n   */\n  predns (domain, cor) {\n    this.prelink(window.location.protocol + '//' + domain, 'dns-prefetch', cor)\n  }\n\n  /**\n   * @method preconnect\n   * Tell the browser which remote resources will or may be used in the\n   * future by issuing a `Preconnect`. This will resolve DNS (#predns), make the TCP\n   * handshake, and negotiate TLS (if necessary). This can be done directly\n   * in HTML without JS, but this method allows you to easily preconnect\n   * a resource in response to a user interaction or NGN.BUS activity.\n   * @param {string} url\n   * The URL to preconnect to.\n   * @param {boolean} [crossorigin]\n   * Set to `true` to identify the request as a cross origin request.\n   * By default, NGN will compare the URL to the current URL in an\n   * attempt to determine if the request is across origins.\n   * @fires network.preconnect\n   * Fired when a preconnect is issued to the browser.\n   */\n  preconnect (url, cor) {\n    this.prelink(url, 'preconnect', cor)\n  }\n\n  /**\n   * @method prefetch\n   * Fetch a specific resource and cache it.\n   * @param {string} url\n   * URL of the resource to download and cache.\n   * @param {boolean} [crossorigin]\n   * Set to `true` to identify the request as a cross origin request.\n   * By default, NGN will compare the URL to the current URL in an\n   * attempt to determine if the request is across origins.\n   * @fires network.prefetch\n   * Fired when a prefetch is issued to the browser.\n   */\n  prefetch (url, cor) {\n    this.prelink(url, 'prefetch', cor)\n  }\n\n  /**\n   * @method subresource\n   * A prioritized version of #prefetch. This should be used\n   * if the asset is required for the current page. Think of this\n   * as \"needed ASAP\". Otherwise, use #prefetch.\n   * @param {string} url\n   * URL of the resource to download and cache.\n   * @param {boolean} [crossorigin]\n   * Set to `true` to identify the request as a cross origin request.\n   * By default, NGN will compare the URL to the current URL in an\n   * attempt to determine if the request is across origins.\n   * @fires network.prefetch\n   * Fired when a prefetch is issued to the browser.\n   */\n  subresource (url, cor) {\n    this.prelink(url, 'subresource', cor)\n  }\n\n  /**\n   * @method prerender\n   * Prerender an entire page. This behaves as though a page is\n   * opened in a hidden tab, then displayed when called. This is\n   * powerful, but should only be used when there is absolute\n   * certainty that the prerendered page will be needed. Otherwise\n   * all of the assets are loaded for no reason (i.e. uselessly\n   * consuming bandwidth).\n   * @param {string} url\n   * URL of the page to download and cache.\n   * @param {boolean} [crossorigin]\n   * Set to `true` to identify the request as a cross origin request.\n   * By default, NGN will compare the URL to the current URL in an\n   * attempt to determine if the request is across origins.\n   * @fires network.prerender\n   * Fired when a prerender is issued to the browser.\n   */\n  prerender (url, cor) {\n    this.prelink(url, 'prerender', cor)\n  }\n\n  /**\n   * @method template\n   * Include a simple letiable replacement template and apply\n   * values to it. This is always cached client side.\n   * @param {string} url\n   * URL of the template to retrieve.\n   * @param {object} [letiables]\n   * A key/value objct containing letiables to replace in\n   * the template.\n   * @param {function} callback\n   * The callback receives a single argument with the HTMLElement/\n   * NodeList generated by the template.\n   */\n  template (url, data, callback) {\n    url = this.normalizeUrl(url)\n\n    if (typeof data === 'function') {\n      callback = data\n      data = {}\n    }\n\n    data = data || {}\n\n    let me = this\n    let tpl\n\n    // Check the cache\n    if (this.importCache.hasOwnProperty(url)) {\n      tpl = this.importCache[url]\n      return this.applyData(tpl, data, callback)\n    }\n\n    this.get(url, function (res) {\n      let ext = null\n      try {\n        ext = url.split('/').pop().split('?')[0].split('.').pop().toLowerCase()\n      } catch (e) {}\n      if (['js', 'css'].indexOf((ext || '').trim().toLowerCase()) >= 0) {\n        console.warn('Cannot use a .' + ext + ' file as a template. Only HTML templates are supported.')\n        return\n      }\n\n      me.importCache[url] = res.responseText\n      me.applyData(res.responseText, data, callback)\n    })\n  }\n}\n\nNGN.NET = new Network()\n","/**\n * @class NGN.DOM.svg\n * Provides a way to easily manage SVG images within a document while\n * retaining the ability to style them with external CSS.\n * @singleton\n */\n/* This file should be loaded in the <head>, not at the end of the <body>.\n* By loading this script before the rest of the DOM, it will insert the\n* FOUC (Flash of Unstyled Content) CSS into the page BEFORE unstyled SVG images\n* are loaded. If this script is included in the <body>, the CSS will be loaded\n* AFTER the SVG images are loaded, meaning they may display briefly before\n* proper styling can be applied to the DOM.\n*/\n\n// Prevent FOUC\n// (function () {\n//   let ss = document.createElement('style')\n//   let str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}')\n//   ss.appendChild(str)\n//   document.head.appendChild(ss)\n// })()\nconst fuoc = function () {\n  var ss = document.createElement('style')\n  var str = document.createTextNode('svg[src]{display:none}svg.loading{height:0px !important;width:0px !important}')\n  ss.appendChild(str)\n  document.head.appendChild(ss)\n}\nfuoc()\n\n// SVG Controller\nNGN.DOM = NGN.DOM || {}\nNGN.DOM.svg = {}\n\nObject.defineProperties(NGN.DOM.svg, {\n  /**\n   * @property {Object} _cache\n   * A cache of SVG images.\n   */\n  _cache: NGN.private({}),\n\n  /**\n   * @method swap\n   * Replace image tags with the SVG equivalent.\n   * @param {HTMLElement|NodeList} imgs\n   * The HTML element or node list containing the images that should be swapped out for SVG files.\n   * @param {function} [callback]\n   * Executed when the image swap is complete. There are no arguments passed to the callback.\n   * @private\n   */\n  swap: NGN.privateconst(function (svgs, callback) {\n    let me = this\n    for (let i = 0; i < svgs.length; i++) {\n      let attr = svgs[i].attributes\n      let output = me._cache[svgs[i].getAttribute('src')]\n      let attrs = []\n\n      try {\n        attrs = /<svg(\\s.*=[\\\"\\'].*?[\\\"\\'])?>/i.exec(output)[1].trim()\n        let sep = /[\\\"\\']\\s/i.exec(attrs)\n        sep = sep !== null ? sep[0] : '\\\" '\n        attrs = attrs.replace(new RegExp(sep, 'gi'), sep.replace(/\\s/ig, ',')).split(',')\n      } catch (e) {\n        console.error(e)\n      }\n\n      attrs = Array.isArray(attrs) ? attrs : [attrs]\n\n      let map = attrs.map(function (els) {\n        return els.split('=')[0].trim().toLowerCase()\n      })\n\n      for (let x = 0; x < attr.length; x++) {\n        let idx = map.indexOf(attr[x].name.toLowerCase())\n        if (idx < 0) {\n          attrs.push(attr[x].name + '=\"' + attr[x].value + '\"')\n        } else {\n          attrs[idx] = attr[x].name + '=\"' + attr[x].value + '\"'\n        }\n      }\n\n      attrs = attrs.filter(function (a) {\n        return a.split('=')[0].toLowerCase() !== 'src'\n      })\n\n      let svg = '<svg ' + attrs.join(' ') + '>'\n\n      svgs[i].outerHTML = output.replace(/<svg.*?>/i, svg)\n    }\n\n    callback && callback()\n  }),\n\n  /**\n   * @method id\n   * @param  {string} url\n   * Create an ID that can be used to reference an SVG symbol.\n   * @return {string}\n   * @private\n   */\n  id: NGN.privateconst(function (url) {\n    return url.replace(/.*\\:\\/\\/|[^A-Za-z0-9]|www/gi, '')\n  }),\n\n  /**\n   * @method cleanCode\n   * Captures all of the content between the <svg></svg> tag.\n   * @param  {string} code\n   * The code to clean up.\n   * @return {string}\n   * @private\n   */\n  cleanCode: NGN.privateconst(function (code) {\n    try {\n      return code.toString().trim().replace(/(\\r\\n|\\n|\\r)/gm, '').replace(/\\s+/g, ' ').match(/\\<svg.*\\<\\/svg\\>/igm, '')[0]\n    } catch (e) {\n      return ''\n    }\n  }),\n\n  /**\n   * @method viewbox\n   * Retrieves the viewbox attribute from the source code.\n   * @param  {string} code\n   * The code to extract the viewbox attribute from.\n   * @return {string}\n   * @private\n   */\n  viewbox: NGN.privateconst(function (code) {\n    return /(viewbox=[\"'])(.*?)([\"'])/igm.exec(code.toString().trim())[2] || '0 0 100 100'\n  }),\n\n  cache: NGN.private(function (url, svg) {\n    this._cache[url] = svg\n  }),\n\n  fetchFile: NGN.private(function (url, callback) {\n    if (!callback) {\n      return\n    }\n\n    if (!NGN.nodelike || url.indexOf('http') === 0) {\n      let me = this\n      NGN.NET.get(url, function (res) {\n        callback && callback(res.status !== 200 ? new Error(res.responseText) : me.cleanCode(res.responseText))\n      })\n    } else {\n      let content = ''\n\n      try {\n        content = require('fs').readFileSync(require('path').resolve(url).replace('file://', '')).toString()\n      } catch (e) {\n        try {\n          content = require('fs').readFileSync(require('path').resolve(__dirname, url).replace('file://', '')).toString()\n        } catch (ee) {}\n      }\n\n      callback(content)\n    }\n  }),\n\n  /**\n   * @method update\n   * Replace any <img src=\"*.svg\"> with the SVG equivalent.\n   * @param {HTMLElement|NodeList} section\n   * The HTML DOM element to update. All children of this element will also be updated.\n   * @param {function} callback\n   * Execute this function after the update is complete.\n   */\n  update: NGN.const(function (section, callback) {\n    if (typeof section === 'function') {\n      callback = section\n      section = document.body\n    } else {\n      section = section || document.body\n    }\n\n    if (section.nodeName === '#text') {\n      return\n    }\n\n    let me = this\n    section = section.hasOwnProperty('length') === true\n      ? NGN._splice(section)\n      : [section]\n\n    section.forEach(function (sec) {\n      let imgs = sec.querySelectorAll('svg[src]')\n\n      // Loop through images, prime the cache.\n      for (let i = 0; i < imgs.length; i++) {\n        me._cache[imgs[i].getAttribute('src')] = me._cache[imgs[i].getAttribute('src')] || null\n      }\n\n      // Fetch all of the unrecognized svg files\n      let unfetched = Object.keys(me._cache).filter(function (url) {\n        return me._cache[url] === null\n      })\n\n      let remaining = unfetched.length\n      unfetched.forEach(function (url) {\n        me.fetchFile(url, function (content) {\n          if (!(content instanceof Error)) {\n            me.cache(url, content)\n          }\n          remaining--\n        })\n      })\n\n      // Monitor for download completion\n      let monitor = setInterval(function () {\n        if (remaining === 0) {\n          clearInterval(monitor)\n          me.swap(imgs, callback)\n        }\n      }, 5)\n    })\n  })\n})\n","'use strict'\n\nNGN.DATA = NGN.DATA || {}\nNGN.DATA.util = {}\n\nObject.defineProperties(NGN.DATA.util, {\n  // CRC table for checksum (cached)\n  crcTable: NGN.private(null),\n\n  /**\n   * @method makeCRCTable\n   * Generate the CRC table for checksums. This is a fairly complex\n   * operation that should only be executed once and cached for\n   * repeat use.\n   * @private\n   */\n  makeCRCTable: NGN.privateconst(function () {\n    let c\n    let crcTable = []\n    for (let n = 0; n < 256; n++) {\n      c = n\n      for (let k = 0; k < 8; k++) {\n        c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1))\n      }\n      crcTable[n] = c\n    }\n    return crcTable\n  }),\n\n  /**\n   * @method checksum\n   * Create the checksum of the specified string.\n   * @param  {string} content\n   * The content to generate a checksum for.\n   * @return {string}\n   * Generates a checksum value.\n   */\n  checksum: NGN.const(function (str) {\n    let crcTable = this.crcTable || (this.crcTable = this.makeCRCTable())\n    let crc = 0 ^ (-1)\n\n    for (let i = 0; i < str.length; i++) {\n      crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF]\n    }\n\n    return (crc ^ (-1)) >>> 0\n  }),\n\n  /**\n   * @method GUID\n   * Generate  a globally unique identifier.\n   *\n   * This is a \"fast\" GUID generator, designed to work in the browser.\n   * The likelihood of an ID collision is 1:3.26x10^15 (1 in 3.26 Quadrillion),\n   * and it will generate the ID between approximately 105ms (Desktop) and 726ms\n   * (Android) as of May 2016. This code came from StackOverflow, courtesy of\n   * an answer from Jeff Ward.\n   * @return {string}\n   * Returns a V4 GUID.\n   */\n  GUID: NGN.const(function () {\n    let lut = []\n    for (var i = 0; i < 256; i++) {\n      lut[i] = (i < 16 ? '0' : '') + (i).toString(16)\n    }\n\n    const d0 = Math.random() * 0xffffffff | 0\n    const d1 = Math.random() * 0xffffffff | 0\n    const d2 = Math.random() * 0xffffffff | 0\n    const d3 = Math.random() * 0xffffffff | 0\n\n    return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] +\n      '-' + lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] +\n      lut[d1 >> 24 & 0xff] + '-' + lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' +\n      lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] + lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] +\n      lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]\n  })\n})\n","'use strict'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nclass Model extends NGN.EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields ||\n        {\n          id: {\n            required: true,\n            type: String,\n            'default': config.id || null\n          }\n        }\n      ),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isRecordDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @cfgproperty {Date|Number} [expires]\n       * When this is set to a date/time, the model record will be marked\n       * as expired at the specified time/date. If a number is specified\n       * (milliseconds), the record will be marked as expired after the\n       * specified time period has elapsed. When a record/model is marked as\n       * \"expired\", it triggers the `expired` event. By default, expired\n       * records/models within an NGN.DATA.Store will be removed from the store.\n       *\n       * Setting this to any value less than `0` disables expiration.\n       * @fires expired\n       * Triggered when the model/record expires.\n       */\n      expiration: NGN.private(null),\n\n      // Used to hold a setTimeout method for expiration events.\n      expirationTimeout: NGN.private(null),\n\n      // Placeholder expiration flag.\n      hasExpired: NGN.private(false),\n\n      // Used to prevent expiration of a record.\n      ignoreTTL: NGN.private(false),\n\n      /**\n       * @property {Number} created\n       * The date/time when the model is created. This is represented as\n       * the number of milliseconds since the epoch (Jan 1, 1970, 00:00:00 UTC).\n       * @private\n       */\n      createDate: NGN.privateconst(Date.now()),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum\n        this.changelog = []\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function (minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse()\n          }\n\n          return false\n        },\n\n        max: function (maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse()\n          }\n\n          return false\n        },\n\n        enum: function (valid, value) {\n          return valid.indexOf(value) >= 0\n        },\n\n        required: function (field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    })\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    let allfields = this.datafields.concat(this.virtualdatafields).concat(this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i\n    })\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.')\n    }\n\n    // Make sure an ID reference is available.\n    if (!this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      }\n    }\n\n    // Add fields\n    Object.keys(this.fields).forEach(function (field) {\n      if (typeof me.fields[field] !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        }\n      }\n      me.addField(field, true)\n    })\n\n    // Add virtuals\n    Object.keys(this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me)\n      }))\n    })\n\n    // Add relationships\n    Object.keys(this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true)\n    })\n\n    let events = [\n      'field.update',\n      'field.create',\n      'field.remove',\n      'field.invalid',\n      'validator.add',\n      'validator.remove',\n      'relationship.create',\n      'relationship.remove',\n      'expired',\n      'deleted'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.push(me)\n          args.unshift(eventName)\n          NGN.BUS.emit.apply(NGN.BUS, args)\n        })\n      })\n    }\n\n    // If an expiration is defined, set it.\n    if (config.hasOwnProperty('expires')) {\n      this.expires = config.expires\n    }\n  }\n\n  get deleted () {\n    return this.isRecordDestroyed\n  }\n\n  set isDestroyed (value) {\n    if (typeof value !== 'boolean') {\n      console.warn(NGN.stack)\n      throw new Error('Invalid data type. isDestroyed must be a boolean. Received ' + (typeof value))\n    }\n\n    this.isRecordDestroyed = value\n\n    if (value) {\n      this.emit('deleted')\n    }\n  }\n\n  get expires () {\n    return this.expiration\n  }\n\n  set expires (value) {\n    // Validate data type\n    if (NGN.typeof(value) !== 'date' && NGN.typeof(value) !== 'number') {\n      try {\n        const source = NGN.stack.pop()\n        console.warn('Expiration could not be set at %c' + source.path + '%c (Invalid data type. Must be a Date or number).', NGN.css, '')\n      } catch (e) {\n        console.warn('Expiration could not be set (Invalid data type. Must be a Date or number).')\n      }\n\n      return\n    }\n\n    // Clear existing expiration timer if it is already set.\n    clearTimeout(this.expirationTimeout)\n\n    // If the new value is a number, convert to a date.\n    if (NGN.typeof(value) === 'number') {\n      if (value < 0) {\n        this.ignoreTTL = true\n        return\n      }\n\n      const currentDate = new Date()\n\n      value = new Date (\n        currentDate.getFullYear(),\n        currentDate.getMonth(),\n        currentDate.getDate(),\n        currentDate.getHours(),\n        currentDate.getMinutes(),\n        currentDate.getSeconds(),\n        currentDate.getMilliseconds() + value\n      )\n    }\n\n    // If the process has reached this far, expiration\n    // actions should be enabled.\n    this.ignoreTTL = false\n\n    // Set the new expiration time period\n    this.expiration = value\n\n    // If the record is already expired, immediately trigger the expiration.\n    if (Date.now() >= this.expiration.getTime()) {\n      this.expire()\n      return\n    }\n\n    this.hasExpired = false\n\n    // If the expiration is in the future, set a timer to expire.\n    let waitPeriod = this.expiration.getTime() - Date.now()\n    this.expirationTimeout = setTimeout(() => {\n      this.expire()\n    }, waitPeriod)\n  }\n\n  /**\n   * @property {boolean} expired\n   * Indicates the record/model is expired.\n   */\n  get expired () {\n    if (this.ignoreTTL) {\n      return false\n    }\n\n    return this.hasExpired\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n  get modified () {\n    return this.checksum !== this.benchmark\n  }\n\n  /**\n   * @cfgproperty {String/Number/Date} [id=null]\n   * The unique ID of the model object. If #idAttribute is defined,\n   * this will get/set the #idAttribute value.\n   */\n  get id () {\n    return this.oid\n  }\n\n  set id (value) {\n    this.oid = value\n  }\n\n  /**\n   * @property checksum\n   * The unique checksum of the record (i.e. a record fingerprint).\n   * This will change as the data changes.\n   */\n  get checksum () {\n    return NGN.DATA.util.checksum(JSON.stringify(this.data))\n  }\n\n  /**\n   * @property {Object} dataMap\n   * The current data map.\n   * @private\n   */\n  get dataMap () {\n    return this._dataMap\n  }\n\n  set dataMap (value) {\n    this._dataMap = value\n    this._reverseDataMap = null\n  }\n\n  /**\n   * @property {NGN.DATA.Store} store\n   * If a store is associated with the model, this will\n   * provide a reference to it. If there is no store, this\n   * will return `null`.\n   */\n  get datastore () {\n    return this._store\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the record is valid.\n   */\n  get valid () {\n    this.validate()\n    return this.invalidDataAttributes.length === 0\n  }\n\n  /**\n   * @property datafields\n   * Provides an array of data fields associated with the model.\n   * @returns {String[]}\n   */\n  get datafields () {\n    return Object.keys(this.fields)\n  }\n\n  /**\n   * @property reslationships\n   * Provides an array of join fields associated with the model.\n   * @returns {String[]}\n   */\n  get relationships () {\n    return Object.keys(this.joins)\n  }\n\n  /**\n   * @property virtualdatafields\n   * Provides an array of virtual data fields associated with the model.\n   * @returns {String[]}\n   */\n  get virtualdatafields () {\n    return Object.keys(this.virtuals)\n  }\n\n  /**\n   * @property {object} reverseMap\n   * Reverses the data map. For example, if the original #dataMap\n   * looks like:\n   *\n   * ```js\n   * {\n   *    firstname: 'gn',\n   *    lastname: 'sn\n   * }\n   * ```\n   *\n   * The reverse map will look like:\n   *\n   * ```js\n   * {\n   *    gn: 'firstname',\n   *    sn: 'lastname\n   * }\n   * ```\n   */\n  get reverseMap () {\n    if (this.dataMap !== null) {\n      if (this._reverseDataMap !== null) {\n        return this._reverseDataMap\n      }\n      let rmap = {}\n      const me = this\n      Object.keys(this._dataMap).forEach(function (attr) {\n        rmap[me._dataMap[attr]] = attr\n      })\n      this._reverseDataMap = rmap\n      return rmap\n    }\n    return null\n  }\n\n  /**\n    * @property data\n    * Creates a JSON representation of the data entity. This is\n    * a record that can be persisted to a database or other data store.\n    * @readonly.\n    */\n  get data () {\n    let d = this.serialize()\n    if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n      d[this.idAttribute] = this[this.idAttribute]\n    }\n    if (this.dataMap) {\n      const me = this\n      // Loop through the map keys\n      Object.keys(this.dataMap).forEach(function (key) {\n        // If the node contains key, make the mapping\n        if (d.hasOwnProperty(key)) {\n          if (d[key] instanceof NGN.DATA.Model) {\n            d[me.dataMap[key]] = d[key].data\n          } else {\n            d[me.dataMap[key]] = d[key]\n          }\n          delete d[key]\n        }\n      })\n    }\n    return d\n  }\n\n  /**\n   * @property history\n   * The history of the entity (i.e. changelog).The history\n   * is shown from most recent to oldest change. Keep in mind that\n   * some actions, such as adding new custom fields on the fly, may\n   * be triggered before other updates.\n   * @returns {array}\n   */\n  get history () {\n    return this.changelog.reverse()\n  }\n\n  /**\n   * @method expire\n   * Forcibly expire the model/record.\n   * @param {Date|Number} [duration]\n   * Optionally provide a new expiration time. This is an alternative\n   * way of setting #expires. If no value is specified, the record\n   * will immediately be marked as `expired`.\n   */\n  expire (duration) {\n    if (this.expired) {\n      return\n    }\n\n    if (duration) {\n      this.expires = duration\n      return\n    }\n\n    if (this.ignoreTTL) {\n      return\n    }\n\n    // Force expiration.\n    this.hasExpired = true\n\n    clearTimeout(this.expirationTimeout)\n\n    this.emit('expired', this)\n  }\n\n  /**\n   * @method disableExpiration\n   * Do not expire this model/record.\n   */\n  disableExpiration () {\n    this.expires = -1\n  }\n\n  /**\n    * @method addValidator\n    * Add or update a validation rule for a specific model property.\n    * @param {String} field\n    * The data field to test.\n    * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n    * The validation used to test the property value. This should return\n    * `true` when the data is valid and `false` when it is not.\n    *\n    * * When this is a _function_, the value is passed to it as an argument.\n    * * When this is a _String_, the value is compared for an exact match (case sensitive)\n    * * When this is a _Number_, the value is compared for equality.\n    * * When this is a _Date_, the value is compared for exact equality.\n    * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n    * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n    * * When this is _an array of dates_, the value is compared to each date for equality.\n    * @fires validator.add\n    */\n  addValidator (property, validator) {\n    if (!this.hasOwnProperty(property)) {\n      console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '')\n      return\n    }\n\n    switch (typeof validator) {\n      case 'function':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(validator)\n        this.emit('validator.add', property)\n        break\n      case 'object':\n        if (Array.isArray(validator)) {\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.indexOf(value) >= 0\n          })\n          this.emit('validator.add', property)\n        } else if (validator.test) { // RegExp\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.test(value)\n          })\n          this.emit('validator.add', property)\n        } else {\n          console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n        }\n        break\n      case 'string':\n      case 'number':\n      case 'date':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(function (value) {\n          return value === validator\n        })\n        this.emit('validator.add', property)\n        break\n      default:\n        console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n    }\n  }\n\n  /**\n    * @method removeValidator\n    * Remove a data validator from the object.\n    * @param {String} attribute\n    * The name of the attribute to remove from the validators.\n    * @fires validator.remove\n    */\n  removeValidator (attribute) {\n    if (this.validators.hasOwnProperty(attribute)) {\n      delete this.validators[attribute]\n      this.emit('validator.remove', attribute)\n    }\n  }\n\n  /**\n    * @method validate\n    * Validate one or all attributes of the data.\n    * @param {String} [attribute=null]\n    * Validate a specific attribute. By default, all attributes are tested.\n    * @private\n    * @returns {Boolean}\n    * Returns true or false based on the validity of data.\n    */\n  validate (attribute) {\n    // If validation is turned off, treat everything as valid.\n    if (!this.validation) {\n      return true\n    }\n    const me = this\n\n    // Single Attribute Validation\n    if (attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        for (let i = 0; i < this.validators[attribute].length; i++) {\n          if (!me.validators[attribute][i].apply(me, [me[attribute]])) {\n            me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute)\n            return false\n          } else {\n            me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n              return attribute !== attr\n            })\n          }\n        }\n\n        if (!this.validateDataType(attribute)) {\n          this.invalidDataAttributes.push(attribute)\n          return false\n        }\n      }\n\n      return true\n    }\n\n    // Validate data type of each attribute\n    this.datafields.forEach(function (field) {\n      me.validate(field)\n    })\n  }\n\n  /**\n   * @method validateDataType\n   * Indicates the data types match.\n   * @param {string} fieldname\n   * Name of the field whose data should be validated.\n   * @private\n   * @return {boolean}\n   */\n  validateDataType (field) {\n    const fieldType = NGN.typeof(this[field])\n    const expectedType = NGN.typeof(this.fields[field].type)\n\n    if (fieldType !== 'null') {\n      return fieldType === expectedType\n    }\n\n    if (this[field] === null && this.fields[field].required) {\n      if (this.autoid && field === this.idAttribute) {\n        return true\n      }\n\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * @method getRelationshipField\n   * Provides specific detail/configuration about a join/relationship.\n   * @param {String} fieldname\n   * The name of the field.\n   * @returns {Object}\n   */\n  getRelationshipField (fieldname) {\n    return this.joins[fieldname]\n  }\n\n  /**\n   * @method hasRelationship\n   * Indicates a data join exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasRelationship (fieldname) {\n    return this.joins.hasOwnProperty(fieldname)\n  }\n\n  /**\n     * @method getDataField\n     * Provides specific detail/configuration about a field.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Object}\n     */\n  getDataField (fieldname) {\n    return this.fields[fieldname]\n  }\n\n  /**\n   * @method hasDataField\n   * Indicates a data field exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasDataField (fieldname) {\n    return this.fields.hasOwnProperty(fieldname)\n  }\n\n  /**\n    * @method serialize\n    * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n    * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n    *\n    * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n    * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n    *\n    * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n    * The model itself can be returned using #getXRef.\n    * @param {Object} [obj]\n    * Defaults to this object.\n    * @protected\n    */\n  serialize (obj) {\n    let _obj = obj || this.raw\n    let rtn = {}\n\n    for (let key in _obj) {\n      _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || ''\n      if (this.fields.hasOwnProperty(key)) {\n        key = key === 'id' ? this.idAttribute : key\n        if ((_obj.hasOwnProperty(key) && (_obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)))) || (_obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0)) {\n          let dsc = Object.getOwnPropertyDescriptor(_obj, key)\n          if (!dsc.set) {\n            // Handle everything else\n            switch (typeof dsc.value) {\n              case 'function':\n                // Support date & regex proxies\n                if (dsc.value.name === 'Date') {\n                  rtn[key] = _obj[key].refs.toJSON()\n                } else if (dsc.value.name === 'RegExp') {\n                  rtn[key] = dsc.value()\n                }\n                break\n              case 'object':\n                // Support array proxies\n                if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                  _obj[key] = _obj[key].slice(0)\n                }\n\n                rtn[key] = _obj[key]\n                break\n              default:\n                rtn[key] = _obj[key]\n                break\n            }\n          }\n        }\n      }\n    }\n\n    const me = this\n    this.relationships.forEach(function (r) {\n      rtn[r] = me.rawjoins[r].data\n    })\n\n    return rtn\n  }\n\n  /**\n   * @method addField\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {object} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (field, fieldcfg, suppressEvents) {\n    if (typeof fieldcfg === 'boolean') {\n      suppressEvents = fieldcfg\n      fieldcfg = null\n    }\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    const me = this\n    let cfg = null\n\n    if (field.toLowerCase() !== 'id') {\n      if (typeof field === 'object') {\n        if (!field.name) {\n          throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.')\n        }\n\n        cfg = field\n        field = cfg.name\n        delete cfg.name\n      }\n\n      if (me[field] !== undefined) {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '')\n        }\n\n        delete me[field]\n      }\n\n      // Create the data field as an object attribute & getter/setter\n      me.fields[field] = cfg || me.fields[field] || {}\n      me.fields[field].required = NGN.coalesce(me.fields[field].required, false)\n\n      if (!me.fields[field].hasOwnProperty('type')) {\n        if (me.fields[field].hasOwnProperty('default')) {\n          let type = NGN.typeof(me.fields[field].default)\n          type = type.charAt(0).toUpperCase() + type.slice(1)\n          me.fields[field].type = eval(type)\n        }\n      }\n      me.fields[field].type = NGN.coalesce(me.fields[field].type, String)\n      if (field === me.idAttribute && me.autoid === true) {\n        me.fields[field].type = String\n        me.fields[field]['default'] = NGN.DATA.util.GUID()\n      } else {\n        me.fields[field]['default'] = me.fields[field]['default'] || null\n      }\n      me.raw[field] = me.fields[field]['default']\n      me[field] = me.raw[field]\n\n      Object.defineProperty(me, field, {\n        get: function () {\n          return me.raw[field]\n        },\n        set: function (value) {\n          let old = me.raw[field]\n          const wasInvalid = !me.validate(field)\n\n          // if (old === value) {\n          //   console.log('HIT')\n          //   return\n          // } else if (me.fields[field].type === Object && typeof value === 'object') {\n          //   if (JSON.stringify(old) === JSON.stringify(value)) {\n          //     return\n          //   }\n          // }\n\n          me.raw[field] = value\n\n          let c = {\n            action: 'update',\n            field: field,\n            old: old,\n            new: me.raw[field]\n          }\n\n          this.changelog.push(c)\n          this.emit('field.update', c)\n          this.emit('field.update.' + field, c)\n\n          // If the field is invalid, fire event.\n          if (!me.validate(field)) {\n            me.emit('field.invalid', {\n              field: field\n            })\n          } else if (wasInvalid) {\n            // If the field BECAME valid (compared to prior value),\n            // emit an event.\n            me.emit('field.valid', {\n              field: field\n            })\n          }\n        }\n      })\n\n      if (!suppressEvents) {\n        let c = {\n          action: 'create',\n          field: field\n        }\n        this.changelog.push(c)\n        this.emit('field.create', c)\n      }\n\n      // Add field validators\n      if (me.fields.hasOwnProperty(field)) {\n        if (me.fields[field].hasOwnProperty('pattern')) {\n          me.addValidator(field, me.fields[field].pattern)\n        }\n        ['min', 'max', 'enum'].forEach(function (v) {\n          if (me.fields[field].hasOwnProperty(v)) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators[v](me.fields[field][v], val)\n            })\n          }\n        })\n        if (me.fields[field].hasOwnProperty('required')) {\n          if (me.fields[field].required) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators.required(field, val)\n            })\n          }\n        }\n        if (me.fields[field].hasOwnProperty('validate')) {\n          if (typeof me.fields[field].validate === 'function') {\n            me.addValidator(field, function (val) {\n              return me.fields[field].validate.apply(me, [val])\n            })\n          } else {\n            const source = NGN.stack.pop()\n            console.warn('Invalid custom validation function (in %c' + source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '')\n          }\n        }\n      }\n    } else if (me.id === null && me.autoid) {\n      me.id = NGN.DATA.util.GUID()\n    }\n  }\n\n  /**\n   * @method addVirtual\n   * Add a virtual field dynamically.\n   * @param {string} name\n   * The name of the attribute to add.\n   * @param {function} handler\n   * The synchronous method (or generator) that produces\n   * the desired output.\n   */\n  addVirtual (name, fn) {\n    const me = this\n    Object.defineProperty(this, name, {\n      get: function () {\n        return fn.apply(me)\n      }\n    })\n  }\n\n  /**\n   * @method addRelationshipField\n   * Join another model dynamically.\n   * @param {string} name\n   * The name of the field to add.\n   * @param {Object|NGN.DATA.Model} config\n   * The configuration or data model type. This follows the same syntax\n   * defined in the #joins attribute.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addRelationshipField (name, cfg, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n\n    if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n      throw new Error(name + ' already exists. It cannot be added to the model again.')\n    }\n\n    if (typeof cfg === 'function' || typeof cfg === 'object' && !cfg.hasOwnProperty('type')) {\n      cfg = {\n        type: cfg\n      }\n    }\n\n    if (!cfg.type) {\n      throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.')\n    }\n\n    cfg.required = NGN.coalesce(cfg.required, true)\n    cfg.default = cfg.default || null\n\n    const me = this\n    let entityType = 'model'\n\n    if (cfg.type instanceof NGN.DATA.Store) {\n      entityType = 'store'\n    } else if (NGN.typeof(cfg.type) === 'array') {\n      if (cfg.type.length === 0) {\n        throw new Error(name + ' cannot be an empty store. A model must be provided.')\n      }\n\n      entityType = 'collection'\n    } else if (typeof cfg.type === 'object') {\n      if (cfg.type.model) {\n        entityType = 'store'\n      }\n    }\n\n    if (entityType === 'store') {\n      let storeCfg = {}\n      if (cfg.type instanceof NGN.DATA.Store) {\n        this.rawjoins[name] = cfg.type\n        storeCfg = null\n      } else if (cfg.type.model) {\n        storeCfg = cfg.type\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.')\n      }\n\n      if (storeCfg !== null) {\n        this.rawjoins[name] = new NGN.DATA.Store(storeCfg)\n      }\n      this.applyStoreMonitor(name)\n    } else if (entityType === 'collection') {\n      this.rawjoins[name] = new NGN.DATA.Store({\n        model: cfg.type[0]\n      })\n      this.applyStoreMonitor(name)\n    } else if (!cfg.type.data) {\n      this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type()  // eslint-disable-line new-cap\n      this.applyModelMonitor(name)\n    } else if (cfg.type.data) {\n      this.rawjoins[name] = cfg.type\n      this.applyStoreMonitor(name)\n    } else {\n      throw new Error('Nested store configuration is invalid or was not recognized.')\n    }\n\n    Object.defineProperty(this, name, {\n      enumerable: true,\n      get: function () {\n        return me.rawjoins[name]\n      }\n    })\n\n    if (!suppressEvents) {\n      let c = {\n        action: 'create',\n        field: name\n      }\n      this.changelog.push(c)\n      this.emit('relationship.create', c)\n    }\n  }\n\n  /**\n   * @method applyModelMonitor\n   * Applies event handlers for bubbling model events.\n   * @param {string} field\n   * The relationship field name.\n   * @private\n   */\n  applyModelMonitor (name) {\n    const model = this.rawjoins[name]\n    const me = this\n\n    model.on('field.update', function (delta) {\n      let payload = {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.old,\n        new: delta.new,\n        join: true,\n        originalEvent: {\n          event: 'field.update',\n          record: model\n        }\n      }\n\n      me.emit('field.update', payload)\n      me.emit('field.update.' + name + '.' + delta.field, payload)\n    })\n\n    model.on('field.create', function (delta) {\n      let payload = {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: null,\n        new: null,\n        join: true,\n        originalEvent: {\n          event: 'field.create',\n          record: model\n        }\n      }\n\n      me.emit('field.update', payload)\n      me.emit('field.update.' + name + '.' + delta.field, payload)\n    })\n\n    model.on('field.remove', function (delta) {\n      let payload = {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.value,\n        new: null,\n        join: true,\n        originalEvent: {\n          event: 'field.remove',\n          record: model\n        }\n      }\n\n      me.emit('field.update', payload)\n      me.emit('field.update.' + name + '.' + delta.field, payload)\n    })\n\n    model.on('field.invalid', function (data) {\n      me.emit('field.invalid')\n      me.emit('field.invalid.' + name + '.' + data.field)\n    })\n\n    model.on('field.valid', function (data) {\n      me.emit('field.valid')\n      me.emit('field.valid.' + name + '.' + data.field)\n    })\n  }\n\n  /**\n   * @method applyStoreMonitor\n   * Applies event handlers for store data.\n   * @param {string} name\n   * Name of the raw join.\n   * @private\n   */\n  applyStoreMonitor (name) {\n    if (!this.rawjoins.hasOwnProperty(name)) {\n      return\n    }\n\n    if (this.rawjoins[name].hasOwnProperty('proxy')) {\n      const me = this\n\n      this.rawjoins[name].on('record.create', function (record) {\n        let old = me[name].data\n        old.pop()\n\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data,\n          originalEvent: {\n            event: 'record.create',\n            record: record\n          }\n        }\n\n        me.emit('field.update', c)\n        me.emit('field.update.' + name, c)\n      })\n\n      this.rawjoins[name].on('record.update', function (record, delta) {\n        if (!delta) {\n          return\n        }\n\n        let c = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          join: true,\n          old: delta.old,\n          new: delta.new,\n          originalEvent: {\n            event: 'record.update',\n            record: record\n          }\n        }\n\n        me.emit('field.update', c)\n        me.emit('field.update.' + name + '.' + delta.field, c)\n      })\n\n      this.rawjoins[name].on('record.delete', function (record) {\n        let old = me[name].data\n        old.push(record.data)\n\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data,\n          originalEvent: {\n            event: 'record.delete',\n            record: record\n          }\n        }\n\n        me.emit('field.update', c)\n        me.emit('field.update.' + name, c)\n      })\n\n      this.rawjoins[name].on('record.invalid', function (data) {\n        me.emit('field.invalid', data.field)\n        me.emit('field.invalid.' + name, data.field)\n      })\n\n      this.rawjoins[name].on('record.valid', function (data) {\n        me.emit('field.valid', data.field)\n        me.emit('field.valid.' + name, data.field)\n      })\n    }\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   */\n  removeField (name) {\n    if (this.raw.hasOwnProperty(name)) {\n      let val = this.raw[name]\n      delete this[name]\n      delete this.fields[name] // eslint-disable-line no-undef\n      delete this.raw[name] // eslint-disable-line no-undef\n      if (this.invalidDataAttributes.indexOf(name) >= 0) {\n        this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1)\n      }\n      let c = {\n        action: 'delete',\n        field: name,\n        value: val\n      }\n      this.emit('field.remove', c)\n      this.changelog.push(c)\n    }\n  }\n\n  /**\n   * @method removeVirtual\n   * Remove a virtual field.\n   * @param {string} name\n   * Name of the field.\n   */\n  removeVirtual (name) {\n    delete this[name]\n  }\n\n  /**\n   * @method removeRelationshipField\n   * Remove an existing join dynamically.\n   * @param {string} name\n   * The name of the relationship field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  removeRelationshipField (name, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    if (this.joins.hasOwnProperty(name)) {\n      let val = this.rawjoins[name]\n      delete this.rawjoins[name]\n      delete this[name]\n      delete this.joins[name]\n      if (!suppressEvents) {\n        let c = {\n          action: 'delete',\n          field: name,\n          old: val,\n          join: true\n        }\n        this.changelog.push(c)\n        this.emit('relationship.remove', c)\n      }\n    }\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog. It is possible to undo an undo (i.e. redo).\n   * This works with relationship creating/removing relationship fields,\n   * but not updates to the related model. To undo changes to a relationship\n   * field, the `undo()` method _of the related model_ must be called.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   */\n  undo (back) {\n    back = back || 1\n    let old = this.changelog.splice(this.changelog.length - back, back)\n    const me = this\n\n    old.reverse().forEach(function (change) {\n      if (!(typeof change.join === 'boolean' ? change.join : false)) {\n        switch (change.action) {\n          case 'update':\n            me[change.field] = change.old\n            break\n          case 'create':\n            me.removeField(change.field)\n            break\n          case 'delete':\n            me.addField(change.field)\n            me[change.field] = me.old\n            break\n        }\n      } else {\n        switch (change.action) {\n          case 'create':\n            me.removeRelationshipField(change.field)\n            break\n          case 'delete':\n            me.addRelationshipField(change.field)\n            me[change.field] = change.old\n            break\n        }\n      }\n    })\n  }\n\n  /**\n   * @method load\n   * Load a data record. This clears the #history. #modified\n   * will be set to `false`, as though the record has been untouched.\n   * @param {object} data\n   * The data to apply to the model.\n   */\n  load (data) {\n    data = data || {}\n\n    // Handle data maps\n    const me = this\n    if (this._dataMap !== null) {\n      Object.keys(this.reverseMap).forEach(function (key) {\n        if (data.hasOwnProperty(key)) {\n          data[me.reverseMap[key]] = data[key]\n          delete data[key]\n        }\n      })\n    }\n\n    // Loop through the keys and add data fields\n    Object.keys(data).forEach(function (key) {\n      if (me.fields.hasOwnProperty(key)) {\n        if (me.raw.hasOwnProperty(key)) {\n          me.raw[key] = data[key]\n        } else if (key === me.idAttribute) {\n          me.id = data[key]\n        }\n      } else if (me.joins.hasOwnProperty(key)) {\n        // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n        // tmp.load(data[key])\n        // me.rawjoin[key] = tmp\n        me.rawjoins[key].load(data[key])\n      } else {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + key + '%c specified as a data field but is not defined in the model.', NGN.css, '')\n        }\n      }\n    })\n\n    this.setUnmodified()\n  }\n}\n\nNGN.DATA = NGN.DATA || {}\n\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    const ModelLoader = function (data) {\n      let model = new Model(cfg)\n      if (data) {\n        model.load(data)\n      }\n      return model\n    }\n\n    return ModelLoader\n  }),\n\n  Entity: NGN.private(Model)\n})\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA\n}\n","'use strict'\n\n/**\n * @class NGN.DATA.Store\n * Represents a collection of data.\n * @fires record.create\n * Fired when a new record is created. The new\n * record is provided as an argument to the event\n * handler.\n * @fires record.delete\n * Fired when a record(s) is removed. The old record\n * is provided as an argument to the event handler.\n */\nclass Store extends NGN.EventEmitter {\n  constructor (cfg) {\n    cfg = cfg || {}\n    super(cfg)\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {NGN.DATA.Model} model\n       * An NGN Data Model to which data records conform.\n       */\n      model: NGN.const(cfg.model || null),\n\n      // The raw data collection\n      _data: NGN.private([]),\n\n      // The raw filters\n      _filters: NGN.private([]),\n\n      // The raw indexes\n      _index: NGN.private(cfg.index || []),\n\n      // Placeholders to track the data that's added/removed\n      // during the lifespan of the store. Modified data is\n      // tracked within each model record.\n      _created: NGN.private([]),\n      _deleted: NGN.private([]),\n      _loading: NGN.private(false),\n      _softarchive: NGN.private([]),\n\n      /**\n       * @property {NGN.DATA.Proxy} proxy\n       * The proxy used to transmit data over a network.\n       * @private\n       */\n      proxy: NGN.private(null),\n\n      /**\n       * @cfg {boolean} [allowDuplicates=true]\n       * Set to `false` to prevent duplicate records from being added.\n       * If a duplicate record is added, it will be ignored and an\n       * error will be thrown.\n       */\n      allowDuplicates: NGN.public(NGN.coalesce(cfg.allowDuplicates, true)),\n\n      /**\n       * @cfg {boolean} [errorOnDuplicate=false]\n       * Set to `true` to throw an error when a duplicate record is detected.\n       * If this is not set, it will default to the value of #allowDuplicates.\n       * If #allowDuplicates is not defined either, this will be `true`\n       */\n      errorOnDuplicate: NGN.const(NGN.coalesce(cfg.errorOnDuplicate, cfg.allowDuplicates, true)),\n\n      /**\n       * @cfgproperty {boolean} [autoRemoveExpiredRecords=true]\n       * When set to `true`, the store will automatically delete expired records.\n       */\n      autoRemoveExpiredRecords: NGN.privateconst(NGN.coalesce(cfg.autoRemoveExpiredRecords, true)),\n\n      /**\n       * @cfg {boolean} [softDelete=false]\n       * When set to `true`, the store makes a copy of a record before removing\n       * it from the store. The store will still emit a `record.delete` event,\n       * and it will still behanve as though the record has been completely\n       * removed. However; the record copy can be retrieved using the #restore\n       * method.\n       *\n       * Since it is not always desirable to store a copy of every deleted\n       * record indefinitely, it is possible to expire and permanently remove\n       * records by setting the #softDeleteTtl.\n       *\n       * ```js\n       * var People = new NGN.DATA.Store({\n       *   model: Person,\n       *   softDelete: true,\n       *   softDeleteTtl: 10000\n       * })\n       *\n       * People.add(somePerson)\n       *\n       * var removedRecordId\n       * People.once('record.delete', function (record) {\n       *   removedRecordId = record.id\n       * })\n       *\n       * People.remove(somePerson)\n       *\n       * setTimeout(function () {\n       *   People.restore(removedRecordId)\n       * }, 5000)\n       *\n       * ```\n       *\n       * The code above creates a new store and adds a person to it.\n       * Then a placeholder variable (`removedRecordId`) is created.\n       * Next, a one-time event listener is added to the store, specifically\n       * for handling the removal of a record. Then the record is removed,\n       * which triggers the `record.delete` event, which populates\n       * `removedRecordId` with the ID of the record that was deleted.\n       * Finally, the code waits for 5 seconds, then restores the record. If\n       * the #restore method _wasn't_ called, the record would be purged\n       * from memory after 10 seconds (because `softDeleteTtl` is set to 10000\n       * milliseconds).\n       */\n      softDelete: NGN.privateconst(NGN.coalesce(cfg.softDelete, false)),\n\n      /**\n       * @cfg {number} [softDeleteTtl=-1]\n       * This is the number of milliseconds the store waits before purging a\n       * soft-deleted record from memory. `-1` = Infinite (no TTL).\n       */\n      softDeleteTtl: NGN.private(NGN.coalesce(cfg.softDeleteTtl, -1))\n    })\n\n    let obj = {}\n    this._index.forEach(i => {\n      obj[i] = []\n    })\n\n    this._index = obj\n\n    const events = [\n      'record.duplicate',\n      'record.create',\n      'record.update',\n      'record.delete',\n      'record.restored',\n      'record.purged',\n      'record.move',\n      'record.invalid',\n      'record.valid',\n      'clear',\n      'filter.create',\n      'filter.delete',\n      'index.create',\n      'index.delete'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(eventName => {\n        this.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.shift()\n          args.push(this)\n          NGN.BUS.emit(eventName, args)\n        })\n      })\n    }\n  }\n\n  /**\n   * @property {array} data\n   * The complete and unfiltered raw underlying dataset. This data\n   * is usually persisted to a database.\n   * @readonly\n   */\n  get data () {\n    return this._data.map(function (d) {\n      return d.data\n    })\n  }\n\n  /**\n   * @property {array} records\n   * An array of NGN.DATA.Model records. If the store has\n   * filters applied, the records will reflect the filtration.\n   * @readonly\n   */\n  get records () {\n    return this.applyFilters(this._data)\n  }\n\n  /**\n   * @property recordCount\n   * The total number of #records in the collection.\n   * @readonly\n   */\n  get recordCount () {\n    return this.applyFilters(this._data).length\n  }\n\n  /**\n   * @property {array} filtered\n   * An array of NGN.DATA.Model records that have been filtered out.\n   * The results reflect the inverse of #records.\n   */\n  get filtered () {\n    let records = this.records\n    return this._data.filter(function (record) {\n      return records.filter(function (rec) {\n        return rec.checksum === record.checksum\n      }).length === 0\n    })\n  }\n\n  /**\n   * @property {NGN.DATA.Model} first\n   * Return the first record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get first () {\n    if (this.records.length === 0) {\n      return null\n    }\n    return this.records[0]\n  }\n\n  /**\n   * @property {NGN.DATA.Model} last\n   * Return the last record in the store. Returns `null`\n   * if the store is empty.\n   */\n  get last () {\n    if (this.records.length === 0) {\n      return null\n    }\n    return this.records[this.records.length - 1]\n  }\n\n  /**\n   * @method add\n   * Add a data record.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  add (data, suppressEvent) {\n    let record\n\n    if (!(data instanceof NGN.DATA.Entity)) {\n      try { data = JSON.parse(data) } catch (e) {}\n      if (typeof data !== 'object') {\n        throw new Error('Cannot add a non-object record.')\n      }\n      if (this.model) {\n        record = new this.model(data) // eslint-disable-line new-cap\n      } else {\n        record = data\n      }\n    } else {\n      record = data\n    }\n\n    if (record.hasOwnProperty('_store')) {\n      record._store = this\n    }\n\n    let dupe = this.isDuplicate(record)\n    if (dupe) {\n      this.emit('record.duplicate', record)\n      if (!this.allowDuplicates) {\n        if (this.errorOnDuplicate) {\n          throw new Error('Cannot add duplicate record (allowDuplicates = false).')\n        }\n        return\n      }\n    }\n\n    this.listen(record)\n    this.applyIndices(record, this._data.length)\n    this._data.push(record)\n    !this._loading && this._created.indexOf(record) < 0 && this._created.push(record)\n    if (!NGN.coalesce(suppressEvent, false)) {\n      this.emit('record.create', record)\n    }\n    if (!record.valid) {\n      this.emit('record.invalid', record)\n    }\n    return record\n  }\n\n  /**\n   * @method insertBefore\n   * Add a record before the specified index.\n   * @param  {NGN.DATA.Model|number} target\n   * The model or index where the new record will be added before.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insertBefore (index, data, suppressEvent = false) {\n    return this.insert(index, data, suppressEvent, 'before')\n  }\n\n  /**\n   * @method insertAfter\n   * Add a record after the specified index.\n   * @param  {NGN.DATA.Model|number} target\n   * The model or index where the new record will be added after.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insertAfter (index, data, suppressEvent = false) {\n    return this.insert(index + 1, data, suppressEvent, 'after')\n  }\n\n  /**\n   * @method insert\n   * Add a record somewhere within the existing recordset (as opposed to simply appending).\n   * @param  {NGN.DATA.Model|number} target\n   * The model or index where the new record will be added after.\n   * @param {NGN.DATA.Model|object} data\n   * Accepts an existing NGN Data Model or a JSON object.\n   * If a JSON object is supplied, it will be applied to\n   * the data model specified in cfg#model. If no model\n   * is specified, the raw JSON data will be stored.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   * @param {string} [position=after]\n   * The position (before or after) where the record should be added.\n   * @return {NGN.DATA.Model}\n   * Returns the new record.\n   */\n  insert (index, data, suppressEvent = false, position = 'after') {\n    let record = this.add(data, true)\n    if (record) {\n      this.move(this._data.length - 1, index, position, false)\n\n      if (!suppressEvent) {\n        this.emit('record.create', record)\n      }\n    }\n\n    return record\n  }\n\n  /**\n   * @method isDuplicate\n   * Indicates whether the specified record is a duplicate.\n   * This compares checksum values. Any match is considered a\n   * duplicate. It will also check for duplication of raw JSON\n   * objects (i.e. non-NGN.DATA.Model records).\n   * @param  {NGN.DATA.Model|Object} record\n   * The record or JSON object.\n   * @return {boolean}\n   */\n  isDuplicate (record) {\n    if (this._data.indexOf(record) >= 0) {\n      return false\n    }\n    return this._data.filter(function (rec) {\n      return rec.checksum === record.checksum\n    }).length > 0\n  }\n\n  /**\n   * @method listen\n   * Listen to a specific record's events and respond.\n   * @param {NGN.DATA.Model} record\n   * The record to listen to.\n   * @fires record.update\n   * Fired when a record is updated. The #record is passed as an argument to\n   * the event handler.\n   * @private\n   */\n  listen (record) {\n    record.on('field.update', delta => {\n      this.updateIndice(delta.field, delta.old, delta.new, this._data.indexOf(record))\n      this.emit('record.update', record, delta)\n    })\n\n    record.on('field.delete', delta => {\n      this.updateIndice(delta.field, delta.old, undefined, this._data.indexOf(record))\n      this.emit('record.update', record, delta)\n    })\n\n    record.on('field.invalid', () => {\n      this.emit('record.invalid', record)\n    })\n\n    record.on('field.valid', () => {\n      this.emit('record.valid', record)\n    })\n\n    record.on('expired', () => {\n      if (!record.expired) {\n        return\n      }\n\n      this.emit('record.expired', record)\n\n      if (this.autoRemoveExpiredRecords) {\n        const index = this.indexOf(record)\n        if (index >= 0) {\n          this.remove(record)\n        }\n      }\n    })\n  }\n\n  /**\n   * @method bulk\n   * Bulk load data.\n   * @param {string} eventName\n   * @param {array} data\n   * @private\n   */\n  bulk (event, data) {\n    this._loading = true\n\n    data.forEach(record => {\n      this.add(record, true)\n    })\n\n    this._loading = false\n    this._deleted = []\n    this._created = []\n\n    // Slight delay to prevent faster systems from\n    // responding before data is written to memory.\n    setTimeout(() => {\n      this.emit(event || 'load')\n    }, 10)\n  }\n\n  /**\n   * @method load\n   * Bulk load data. This acts the same as adding records,\n   * but it suppresses individual record creation events.\n   * This will add data to the existing collection. If you\n   * want to load fresh data, use the #reload method.\n   * @param {array} data\n   * An array of data. Each array element should be an\n   * NGN.DATA.Model or a JSON object that can be applied\n   * to the store's #model.\n   */\n  load () {\n    let array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments)\n    this.bulk('load', array)\n  }\n\n  /**\n   * @method reload\n   * Reload data. This is the same as running #clear followed\n   * by #load.\n   */\n  reload (data) {\n    this.clear()\n    let array = Array.isArray(arguments[0]) ? arguments[0] : NGN.slice(arguments)\n    this.bulk('reload', array)\n  }\n\n  /**\n   * @method indexOf\n   * Find the index number of a record within the collection.\n   * @param  {NGN.DATA.Model} record\n   * The record whose index should be identified.\n   * @return {Number}\n   * Returns a number from `0-collection length`. Returns `-1` if\n   * the record is not found in the collection.\n   */\n  indexOf (record) {\n    if (typeof record !== 'object' || (!(record instanceof NGN.DATA.Entity) && !record.checksum)) {\n      return -1\n    }\n\n    return this._data.findIndex(function (el) {\n      return el.checksum === record.checksum\n    })\n  }\n\n  /**\n   * @method contains\n   * A convenience method that indicates whether a record is in\n   * the store or not.\n   * @param {NGN.DATA.Model} record\n   * The record to check for inclusion in the data collection.\n   * @return {Boolean}\n   */\n  contains (record) {\n    return this.indexOf(record) >= 0\n  }\n\n  /**\n   * @method remove\n   * Remove a record.\n   * @param {NGN.DATA.Model|object|number} data\n   * Accepts an existing NGN Data Model, JSON object,\n   * or index number. Using a JSON object is slower\n   * than using a reference to a data model or an index\n   * number (index is fastest).\n   * @fires record.delete\n   * The record delete event sends 2 arguments to handler methods:\n   * `record` and `index`. The record refers to the model that was\n   * removed. The `index` refers to the position of the record within\n   * the store's data list. **NOTICE** the `index` refers to where\n   * the record _used to be_.\n   * @returns {NGN.DATA.Model}\n   * Returns the data model that was just removed. If a model\n   * is unavailable (i.e. remove didn't find the specified record),\n   * this will return `null`.\n   */\n  remove (data, suppressEvents) {\n    let removedRecord = []\n    let dataIndex\n\n    if (typeof data === 'number') {\n      dataIndex = data\n    } else if (data && data.checksum && data.checksum !== null || data instanceof NGN.DATA.Model) {\n      dataIndex = this.indexOf(data)\n    } else {\n      let m = new this.model(data, true) // eslint-disable-line new-cap\n      dataIndex = this._data.findIndex(function (el) {\n        return el.checksum === m.checksum\n      })\n    }\n\n    // If no record is found, the operation fails.\n    if (dataIndex < 0) {\n      throw new Error('Record removal failed (record not found at index ' + (dataIndex || '').toString() + ').')\n    }\n\n    this._data[dataIndex].isDestroyed = true\n\n    removedRecord = this._data.splice(dataIndex, 1)\n\n    removedRecord.isDestroyed = true\n\n    if (removedRecord.length > 0) {\n      removedRecord = removedRecord[0]\n      this.unapplyIndices(dataIndex)\n\n      if (this.softDelete) {\n        if (this.softDeleteTtl >= 0) {\n          const checksum = removedRecord.checksum\n          removedRecord.once('expired', () => {\n            this.purgeDeletedRecord(checksum)\n          })\n\n          removedRecord.expires = this.softDeleteTtl\n        }\n\n        this._softarchive.push(removedRecord)\n      }\n\n      if (!this._loading) {\n        let i = this._created.indexOf(removedRecord)\n        if (i >= 0) {\n          i >= 0 && this._created.splice(i, 1)\n        } else if (this._deleted.indexOf(removedRecord) < 0) {\n          this._deleted.push(removedRecord)\n        }\n      }\n\n      if (!NGN.coalesce(suppressEvents, false)) {\n        this.emit('record.delete', removedRecord, dataIndex)\n      }\n\n      return removedRecord\n    }\n\n    return null\n  }\n\n  /**\n   * @method findArchivedRecord\n   * Retrieve an archived record.\n   * @param  {string} checksum\n   * Checksum of the record.\n   * @return {object}\n   * Returns the archived record and it's index within the deletion archive.\n   * ```js\n   * {\n   *   index: <number>,\n   *   record: <NGN.DATA.Model>\n   * }\n   * ```\n   * @private\n   */\n  findArchivedRecord (checksum) {\n    let index\n    let record = this._softarchive.filter((record, i) => {\n      if (record.checksum === checksum) {\n        index = i\n        return true\n      }\n    })\n\n    if (record.length !== 1) {\n      let source\n      try {\n        source = NGN.stack.pop().path\n      } catch (e) {\n        source = 'Unknown'\n      }\n\n      console.warn('Cannot purge record. %c' + record.length + ' records found%c. Source: %c' + source, NGN.css, '', NGN.css)\n      return null\n    }\n\n    return {\n      index: index,\n      record: record[0]\n    }\n  }\n\n  /**\n   * @method purgeDeletedRecord\n   * Remove a soft-deleted record from the store permanently.\n   * This cannot be undone, and there are no events for this action.\n   * @param  {string} checksum\n   * Checksum of the record.\n   * @return {NGN.DATA.Model}\n   * Returns the purged record. This will be `null` if the record cannot be\n   * found or does not exist.\n   * @fires {NGN.DATA.Model} record.purged\n   * This event is triggered when a record is removed from the soft-delete\n   * archive.\n   * @private\n   */\n  purgeDeletedRecord (checksum) {\n    const purgedRecord = this.findArchivedRecord(checksum)\n\n    // If there is no record, abort (the findArchivedRecord emits a warning)\n    if (purgedRecord === null) {\n      return null\n    }\n\n    this._softarchive.splice(purgedRecord.index, 1)\n\n    this.emit('record.purged', purgedRecord.record)\n\n    return purgedRecord.record\n  }\n\n  /**\n   * @method restore\n   * Restore a soft-deleted record to the store. This does not preserve the\n   * original index (a new index number is assigned).\n   * @param  {string} checksum\n   * Checksum of the record.\n   * @return {NGN.DATA.Model}\n   * Returns the purged record. This will be `null` if the record cannot be\n   * found or does not exist.\n   * @fires record.restored\n   */\n  restore (checksum) {\n    const purgedRecord = this.findArchivedRecord(checksum)\n\n    // If there is no record, abort (the findArchivedRecord emits a warning)\n    if (purgedRecord === null) {\n      return null\n    }\n\n    purgedRecord.record.removeAllListeners('expired')\n    purgedRecord.record.expires = this.softDeleteTtl\n\n    this.add(purgedRecord.record, true)\n\n    this._softarchive[purgedRecord.index].removeAllListeners('expired')\n    this._softarchive.splice(purgedRecord.index, 1)\n\n    purgedRecord.record.isDestroyed = false\n\n    this.emit('record.restored', purgedRecord.record)\n\n    return purgedRecord.record\n  }\n\n  /**\n   * @method clear\n   * Removes all data.\n   * @param {boolean} [purgeSoftDelete=true]\n   * Purge soft deleted records from memory.\n   * @fires clear\n   * Fired when all data is removed\n   */\n  clear (purge = true) {\n    if (!purge) {\n      this._softarchive = this._data\n    } else {\n      this._softarchive = []\n    }\n\n    this._data = []\n\n    Object.keys(this._index).forEach(index => {\n      this._index[index] = []\n    })\n\n    this.emit('clear')\n  }\n\n  /**\n   * @method find\n   * Retrieve a specific record or set of records.\n   * @param {number|function|string|object} [query=null]\n   * When this is set to a `number`, the corresponding zero-based\n   * record will be returned. A `function` can also be used, which\n   * acts like a filter. Each record is passed to this function.\n   *\n   * For example, if we want to find all administrators within a\n   * set of users, the following could be used:\n   *\n   * ```js\n   *   let record = MyStore.find(function (record) {\n   *     return record.usertype = 'admin'\n   *   })\n   * ```\n   *\n   * It's also possible to supply a String. When this is supplied,\n   * the store will look for a record whose ID (see NGN.DATA.Model#idAttribute)\n   * matches the string. Numberic ID's are matched on their string\n   * equivalent for search purposes (data is not modified).\n   *\n   * An object can be used to search for specific field values. For example:\n   *\n   * ```js\n   * MyStore.find({\n   *   firstname: 'Corey',\n   *   lastname: /Butler|Doe/\n   * })\n   * ```\n   *\n   * The code above will find everyone named Corey Butler or Corey Doe. The\n   * first attribute must match the value exactly whereas `lastname` will\n   * match against the regular expression.\n   *\n   * If this parameter is `undefined` or `null`, all records will be\n   * returned (i.e. no search criteria specified, so return everything).\n   *\n   * If you're using a large dataset, indexing can speed up queries. To take\n   * full advantage of indexing, all of the query elements should be indexed.\n   * For example, if you have `lastname`, 'firstname' in your query and\n   * both of those are indexed, the response time will be substantially faster\n   * than if they're not (in large data sets). However; if one of those\n   * elements is _not_ indexed, performance may not increase.\n   * @param {boolean} [ignoreFilters=false]\n   * Set this to `true` to search the full unfiltered record set.\n   * @return {NGN.DATA.Model|array|null}\n   * An array is returned when a function is specified for the query.\n   * Otherwise the specific record is return. This method assumes\n   * records have unique ID's.\n   */\n  find (query, ignoreFilters) {\n    if (this._data.length === 0) {\n      return []\n    }\n\n    let resultSet = []\n\n    switch (typeof query) {\n      case 'function':\n        resultSet = this._data.filter(query)\n        break\n      case 'number':\n        resultSet = (query < 0 || query >= this._data.length) ? null : this._data[query]\n        break\n      case 'string':\n        let indice = this.getIndices(this._data[0].idAttribute, query.trim())\n        if (indice !== null && indice.length > 0) {\n          indice.forEach(index => {\n            resultSet.push(this._data[index])\n          })\n          return resultSet\n        }\n\n        let recordSet = this._data.filter(function (record) {\n          return (record[record.idAttribute] || '').toString().trim() === query.trim()\n        })\n\n        resultSet = recordSet.length === 0 ? null : recordSet[0]\n\n        break\n      case 'object':\n        if (query instanceof NGN.DATA.Model) {\n          if (this.contains(query)) {\n            return query\n          }\n\n          return null\n        }\n\n        let match = []\n        let noindex = []\n        let queryKeys = Object.keys(query)\n\n        queryKeys.forEach(field => {\n          let index = this.getIndices(field, query[field])\n\n          if (index) {\n            match = match.concat(index || [])\n          } else {\n            field !== null && noindex.push(field)\n          }\n        })\n\n        // Deduplicate\n        match.filter(function (index, i) {\n          return match.indexOf(index) === i\n        })\n\n        // Get non-indexed matches\n        if (noindex.length > 0) {\n          resultSet = this._data.filter(function (record, i) {\n            if (match.indexOf(i) >= 0) {\n              return false\n            }\n\n            for (let x = 0; x < noindex.length; x++) {\n              if (record[noindex[x]] !== query[noindex[x]]) {\n                return false\n              }\n            }\n\n            return true\n          })\n        }\n\n        // If a combined indexable + nonindexable query\n        resultSet = resultSet.concat(match.map(index => {\n          return this._data[index]\n        })).filter(function (record) {\n          for (let y = 0; y < queryKeys.length; y++) {\n            if (query[queryKeys[y]] !== record[queryKeys[y]]) {\n              return false\n            }\n          }\n\n          return true\n        })\n        break\n      default:\n        resultSet = this._data\n    }\n\n    if (resultSet === null) {\n      return null\n    }\n\n    if (!NGN.coalesce(ignoreFilters, false)) {\n      this.applyFilters(resultSet instanceof Array ? resultSet : [resultSet])\n    }\n\n    return resultSet\n  }\n\n  /**\n   * @method applyFilters\n   * Apply filters to a data set.\n   * @param {array} data\n   * The array of data to apply filters to.\n   * @private\n   */\n  applyFilters (data) {\n    if (this._filters.length === 0) {\n      return data\n    }\n\n    this._filters.forEach(function (filter) {\n      data = data.filter(filter)\n    })\n\n    return data\n  }\n\n  /**\n   * @method addFilter\n   * Add a filter to the record set.\n   * @param {function} fn\n   * The filter function. This function should comply\n   * with the [Array.filter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) specification,\n   * returning a boolean value.\n   * The item passed to the filter will be the NGN.DATA.Model specified\n   * in the cfg#model.\n   * @fires filter.create\n   * Fired when a filter is created.\n   */\n  addFilter (fn) {\n    this._filters.push(fn)\n    this.emit('filter.create', fn)\n  }\n\n  /**\n   * @method removeFilter\n   * Remove a filter from the record set.\n   * @param {function|index} filter\n   * This can be the function which was originally passed to\n   * the #addFilter method, or the zero-based #filters index\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing one the creation of the filter.\n   * @fires filter.delete\n   * Fired when a filter is removed.\n   */\n  removeFilter (fn, suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, false)\n\n    let removed = []\n\n    if (typeof fn === 'number') {\n      removed = this._filters.splice(fn, 1)\n    } else {\n      removed = this._filters.splice(this._filters.indexOf(fn), 1)\n    }\n\n    if (removed.length > 0 && !suppressEvents) {\n      this.emit('filter.delete', removed[0])\n    }\n  }\n\n  /**\n   * @method clearFilters\n   * Remove all filters.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing one the removal of each filter.\n   */\n  clearFilters (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, false)\n\n    if (suppressEvents) {\n      this._filters = []\n      return\n    }\n\n    while (this._filters.length > 0) {\n      this.emit('filter.delete', this._filters.pop())\n    }\n  }\n\n  /**\n   * @method deduplicate\n   * Deduplicates the recordset. This compares the checksum of\n   * each of the records to each other and removes duplicates.\n   * This suppresses the removal\n   * @param {boolean} [suppressEvents=true]\n   * Suppress the event that gets fired when a record is removed.\n   */\n  deduplicate (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, true)\n\n    let records = this.data.map(function (rec) {\n      return JSON.stringify(rec)\n    })\n\n    let dupes = []\n\n    records.forEach((record, i) => {\n      if (records.indexOf(record) < i) {\n        dupes.push(this.find(i))\n      }\n    })\n\n    dupes.forEach(duplicate => {\n      this.remove(duplicate)\n    })\n  }\n\n  /**\n   * @method sort\n   * Sort the #records. This forces a #reindex, which may potentially be\n   * an expensive operation on large data sets.\n   * @param {function|object} sorter\n   * Using a function is exactly the same as using the\n   * [Array.sort()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray%2Fsort) method\n   * (this is the compare function). The arguments passed to the\n   * method are NGN.DATA.Model objects.\n   * Alternatively, it is possible to sort by one or more model\n   * attributes. Each attribute For example:\n   *\n   * ```js\n   * let Person = new NGN.DATA.Model({\n   *   fields: {\n   *     fname: null,\n   *     lname: null\n   *   }\n   * })\n   *\n   * let People = new NGN.DATA.Store({\n   *   model: Person\n   * })\n   *\n   * People.add({\n   *   fname: 'John',\n   *   lname: 'Doe',\n   *   age: 37\n   * }, {\n   *   fname: 'Jane',\n   *   lname: 'Doe',\n   *   age: 36\n   * }, {\n   *   fname: 'Jane',\n   *   lname: 'Vaughn',\n   *   age: 42\n   * })\n   *\n   * People.sort({\n   *   lname: 'asc',  // Sort by last name in normal alphabetical order.\n   *   age: 'desc'    // Sort by age, oldest to youngest.\n   * })\n   *\n   * People.records.forEach(function (p) {\n   *   console.log(fname, lname, age)\n   * })\n   *\n   * // DISPLAYS\n   * // John Doe 37\n   * // Jane Doe 36\n   * // Jane Vaughn 42\n   *\n   * People.sort({\n   *   age: 'desc',  // Sort by age, oldest to youngest.\n   *   lname: 'asc'  // Sort by name in normal alphabetical order.\n   * })\n   *\n   * People.records.forEach(function (p) {\n   *   console.log(fname, lname, age)\n   * })\n   *\n   * // DISPLAYS\n   * // Jane Vaughn 42\n   * // John Doe 37\n   * // Jane Doe 36\n   * ```\n   *\n   * It is also posible to provide complex sorters. For example:\n   *\n   * ```js\n   * People.sort({\n   *   lname: 'asc',\n   *   age: function (a, b) {\n   *     if (a.age < 40) {\n   *       return 1\n   *     }\n   *     return a.age < b.age\n   *   }\n   * })\n   * ```\n   *\n   * The sorter above says \"sort alphabetically by last name,\n   * then by age where anyone under 40yrs old shows up before\n   * everyone else, but sort the remainder ages in descending order.\n   */\n  sort (fn) {\n    if (typeof fn === 'function') {\n      this.records.sort(fn)\n    } else if (typeof fn === 'object') {\n      let functionKeys = Object.keys(fn)\n\n      this._data.sort(function (a, b) {\n        for (let i = 0; i < functionKeys.length; i++) {\n          // Make sure both objects have the same sorting key\n          if (a.hasOwnProperty(functionKeys[i]) && !b.hasOwnProperty(functionKeys[i])) {\n            return 1\n          }\n\n          if (!a.hasOwnProperty(functionKeys[i]) && b.hasOwnProperty(functionKeys[i])) {\n            return -1\n          }\n\n          // For objects who have the key, sort in the order defined in object.\n          if (a[functionKeys[i]] !== b[functionKeys[i]]) {\n            switch (fn[functionKeys[i]].toString().trim().toLowerCase()) {\n              case 'asc':\n                if (typeof a.fields[functionKeys[i]]) {\n                  return a[functionKeys[i]].localeCompare(b[functionKeys[i]])\n                }\n                return a[functionKeys[i]] > b[functionKeys[i]] ? 1 : -1\n\n              case 'desc':\n                return a[functionKeys[i]] < b[functionKeys[i]] ? 1 : -1\n\n              default:\n                if (typeof fn[functionKeys[i]] === 'function') {\n                  return fn[functionKeys[i]](a, b)\n                }\n                return 0\n            }\n          }\n        }\n\n        // Everything is equal\n        return 0\n      })\n    }\n    this.reindex()\n  }\n\n  /**\n   * @method createIndex\n   * Add a simple index to the recordset.\n   * @param {string} datafield\n   * The #model data field to index.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing on the creation of the index.\n   * @fires index.create\n   * Fired when an index is created. The datafield name and\n   * store are supplied as an argument to event handlers.\n   */\n  createIndex (field, suppressEvents) {\n    if (!this.model.hasOwnProperty(field)) {\n      console.warn('The store\\'s model does not contain a data field called %c' + field + '%c.', NGN.css, '')\n    }\n\n    let exists = this._index.hasOwnProperty(field)\n\n    this._index[field] = this._index[field] || []\n    if (!NGN.coalesce(suppressEvents, false) && !exists) {\n      this.emit('index.created', {\n        field: field,\n        store: this\n      })\n    }\n  }\n\n  /**\n   * @method deleteIndex\n   * Remove an index.\n   * @param {string} datafield\n   * The #model data field to stop indexing.\n   * @param {boolean} [suppressEvents=false]\n   * Prevent events from firing on the removal of the index.\n   * @fires index.delete\n   * Fired when an index is deleted. The datafield name and\n   * store are supplied as an argument to event handlers.\n   */\n  deleteIndex (field, suppressEvents) {\n    if (this._index.hasOwnProperty(field)) {\n      delete this._index[field]\n\n      if (!NGN.coalesce(suppressEvents, false)) {\n        this.emit('index.created', {\n          field: field,\n          store: this\n        })\n      }\n    }\n  }\n\n  /**\n   * @method clearIndices\n   * Clear all indices from the indexes.\n   */\n  clearIndices () {\n    Object.keys(this._index).forEach(key => {\n      this._index[key] = []\n    })\n  }\n\n  /**\n   * @method deleteIndexes\n   * Remove all indexes.\n   * @param {boolean} [suppressEvents=true]\n   * Prevent events from firing on the removal of each index.\n   */\n  deleteIndexes (suppressEvents) {\n    suppressEvents = NGN.coalesce(suppressEvents, true)\n\n    Object.keys(this._index).forEach(key => {\n      this.deleteIndex(key, suppressEvents)\n    })\n  }\n\n  /**\n   * @method applyIndices\n   * Apply the values to the index.\n   * @param {NGN.DATA.Model} record\n   * The record which should be applied to the index.\n   * @param {number} number\n   * The record index number.\n   * @private\n   */\n  applyIndices (record, number) {\n    let indexes = Object.keys(this._index)\n\n    if (indexes.length === 0) {\n      return\n    }\n\n    indexes.forEach(field => {\n      if (record.hasOwnProperty(field)) {\n        let values = this._index[field]\n\n        // Check existing records for similar values\n        for (let i = 0; i < values.length; i++) {\n          if (values[i][0] === record[field]) {\n            this._index[field][i].push(number)\n            return\n          }\n        }\n\n        // No matching words, create a new one.\n        this._index[field].push([record[field], number])\n      }\n    })\n  }\n\n  /**\n   * @method unapplyIndices\n   * This removes a record from all relevant indexes simultaneously.\n   * Commonly used when removing a record from the store.\n   * @param  {number} indexNumber\n   * The record index.\n   * @private\n   */\n  unapplyIndices (num) {\n    Object.keys(this._index).forEach(field => {\n      const i = this._index[field].indexOf(num)\n      if (i >= 0) {\n        this._index[field].splice(i, 1)\n      }\n    })\n  }\n\n  /**\n   * @method updateIndice\n   * Update the index with new values.\n   * @param  {string} fieldname\n   * The name of the indexed field.\n   * @param  {any} oldValue\n   * The original value. This is used to remove the old value from the index.\n   * @param  {any} newValue\n   * The new value.\n   * @param  {number} indexNumber\n   * The number of the record index.\n   * @private\n   */\n  updateIndice (field, oldValue, newValue, num) {\n    if (!this._index.hasOwnProperty(field) || oldValue === newValue) {\n      return\n    }\n\n    let ct = 0\n\n    for (let i = 0; i < this._index[field].length; i++) {\n      let value = this._index[field][i][0]\n\n      if (value === oldValue) {\n        this._index[field][i].splice(this._index[field][i].indexOf(num), 1)\n        ct++\n      } else if (newValue === undefined) {\n        // If thr new value is undefined, the field was removed for the record.\n        // This can be skipped.\n        ct++\n      } else if (value === newValue) {\n        this._index[field][i].push(num)\n        this._index[field][i].shift()\n        this._index[field][i].sort()\n        this._index[field][i].unshift(value)\n        ct++\n      }\n\n      if (ct === 2) {\n        return\n      }\n    }\n  }\n\n  /**\n   * @method getIndices\n   * Retrieve a list of index numbers pertaining to a field value.\n   * @param  {string} field\n   * Name of the data field.\n   * @param  {any} value\n   * The value of the index to match against.\n   * @return {array}\n   * Returns an array of integers representing the index where the\n   * values exist in the record set.\n   */\n  getIndices (field, value) {\n    if (!this._index.hasOwnProperty(field)) {\n      return null\n    }\n\n    let indexes = this._index[field].filter(function (dataArray) {\n      return dataArray.length > 0 && dataArray[0] === value\n    })\n\n    if (indexes.length === 1) {\n      indexes[0].shift()\n      return indexes[0]\n    }\n\n    return []\n  }\n\n  /**\n   * @method move\n   * Move an existing record to a specific index. This can be used\n   * to reorder a single record.\n   * @param {NGN.DATA.Model|number|string} source\n   * The record or the index of a record within the store to move.\n   * This can also be the unique ID of a record.\n   * @param {NGN.DATA.Model|number|string} target\n   * The record or the index of a record within the store where the source\n   * will be positioned against. This can also be the unique ID of a record.\n   * @param {boolean} [suppressEvent=false]\n   * Set this to `true` to prevent the `record.create` event\n   * from firing.\n   */\n  move (source, target, suppressEvent = false) {\n    if (source === undefined) {\n      console.warn('Cannot move record. No source specified.')\n      return\n    }\n\n    if (target === undefined) {\n      console.warn('Cannot move record. No target specified.')\n      return\n    }\n\n    source = this.getRecordIndex(source)\n    target = this.getRecordIndex(target)\n\n    // If the positins haven't actually changed, stop processing.\n    if (source === target) {\n      return\n    }\n\n    this._data.splice(target, 0, this._data.splice(source, 1)[0])\n\n    if (!suppressEvent) {\n      this.emit('record.move', {\n        oldIndex: source,\n        newIndex: target,\n        record: this._data[target]\n      })\n    }\n\n    this.reindex()\n  }\n\n  /**\n   * @method getRecordIndex\n   * Returns the index of a record using sanitize input.\n   * @param  {NGN.DATA.Model|number|String} value\n   * The record or the index of a record within the store.\n   * This can also be the unique ID of a record.\n   * @return {NGN.DATA.Model}\n   * Returns the model or `null`\n   */\n  getRecordIndex (value) {\n    if (value === undefined) {\n      console.warn('No argument passed to getRecordIndex().')\n      return null\n    }\n\n    if (typeof value === 'number') {\n      if (value < 0 || value >= this._data.length) {\n        console.warn('%c' + value + '%c out of bounds.', NGN.css, '')\n        return null\n      }\n\n      return value\n    } else if (typeof value === 'string') {\n      let id = value\n\n      value = this.find(id)\n\n      if (!value) {\n        console.warn('%c' + id + '%c does not exist or cannot be found in the store.', NGN.css, '')\n        return null\n      }\n    }\n\n    return this.indexOf(value)\n  }\n\n  /**\n   * @method reindex\n   * Reindex the entire record set. This can be expensive operation.\n   * Use with caution.\n   * @private\n   */\n  reindex () {\n    this.clearIndices()\n    this._data.forEach((record, index) => {\n      this.applyIndices(record, index)\n    })\n  }\n}\n\n/**\n * indexes\n * An index consists of an object whose key is name of the\n * data field being indexed. The value is an array of record values\n * and their corresponding index numbers. For example:\n *\n * ```js\n * {\n *   \"lastname\": [[\"Butler\", 0, 1, 3], [\"Doe\", 2, 4]]\n * }\n * ```\n * The above example indicates the store has two unique `lastname`\n * values, \"Butler\" and \"Doe\". Records containing a `lastname` of\n * \"Butler\" exist in the record store as the first, 2nd, and 4th\n * records. Records with the last name \"Doe\" are 3rd and 5th.\n * Remember indexes are zero based since records are stored as an\n * array.\n */\n\nNGN.DATA.Store = Store\n","'use strict'\n\n/**\n * @class NGN.DATA.Proxy\n * Provides a gateway to remote services such as HTTP and\n * websocket endpoints. This can be used directly to create\n * custom proxies. However; NGN.DATA.HttpProxy and NGN.DATA.WebSocketProxy\n * are also available for use.\n */\nclass Proxy extends NGN.EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    if (!config.store) {\n      throw new Error('NGN.DATA.Proxy requires a NGN.DATA.Store.')\n    }\n\n    super()\n\n    config.store.proxy = this\n\n    Object.defineProperties(this, {\n      /**\n       * @configproperty {NGN.DATA.Store} store (required)\n       * THe store for data being proxied.\n       */\n      store: NGN.const(config.store),\n\n      /**\n       * @configproperty {string} [url=http://localhost\n       * The root URL for making network requests (HTTP/WS/TLS).\n       */\n      url: NGN.public(config.url || 'http://localhost'),\n\n      /**\n       * @config {string} username\n       * If using basic authentication, provide this as the username.\n       */\n      username: NGN.public(config.username || null),\n\n      /**\n       * @config {string} password\n       * If using basic authentication, provide this as the password.\n       */\n      password: NGN.public(config.password || null),\n\n      /**\n       * @config {string} token\n       * If using an access token, provide this as the value. This\n       * will override basic authentication (#username and #password\n       * are ignored). This sets an `Authorization: Bearer <token>`\n       * HTTP header.\n       */\n      token: NGN.public(config.token || null)\n    })\n  }\n\n  /**\n   * @property actions\n   * A list of the record changes that have occurred.\n   * @returns {object}\n   * An object is returned with 3 keys representative of the\n   * action taken:\n   *\n   * ```js\n   * {\n   *   create: [NGN.DATA.Model, NGN.DATA.Model],\n   *   update: [NGN.DATA.Model],\n   *   delete: []\n   * }\n   * ```\n   *\n   * The object above indicates two records have been created\n   * while one record was modified and no records were deleted.\n   * **NOTICE:** If you add or load a JSON object to the store\n   * (as opposed to adding an instance of NGN.DATA.Model), the\n   * raw object will be returned. It is also impossible for the\n   * data store/proxy to determine if these have changed since\n   * the NGN.DATA.Model is responsible for tracking changes to\n   * data objects.\n   * @private\n   */\n  get actions () {\n    const me = this\n    return {\n      create: this.store._created,\n      update: this.store.records.filter(function (record) {\n        if (me.store._created.indexOf(record) < 0 && me.store._deleted.indexOf(record) < 0) {\n          return false\n        }\n        return record.modified\n      }).map(function (record) {\n        return record\n      }),\n      delete: this.store._deleted\n    }\n  }\n\n  save () {\n    console.warn('Save should be overridden by a proxy implementation class.')\n  }\n\n  fetch () {\n    console.warn('Fetch should be overridden by a proxy implementation class.')\n  }\n}\n\nObject.defineProperty(NGN.DATA, 'Proxy', NGN.const(Proxy))\n"],"sourceRoot":"/source/"}