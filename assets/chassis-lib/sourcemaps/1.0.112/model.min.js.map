{"version":3,"sources":["model.js","model.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Model","_NGN$EventEmitter","config","this","_this","getPrototypeOf","me","idAttribute","NGN","privateconst","fields","id","required","type","String","default","joins","relationships","virtuals","validators","validation","coalesce","isNew","isDestroyed","oid","autoid","benchmark","expiration","expirationTimeout","hasExpired","ignoreTTL","createDate","Date","now","setUnmodified","checksum","changelog","allowInvalidSave","disableDataValidation","invalidDataAttributes","initialDataAttributes","_nativeValidators","min","minimum","trim","parse","max","maximum","enum","valid","indexOf","field","hasOwnProperty","_dataMap","dataMap","_reverseDataMap","raw","rawjoins","_store","allfields","datafields","concat","virtualdatafields","filter","a","Error","join","keys","forEach","name","addField","v","get","apply","addRelationshipField","events","BUS","eventName","on","args","slice","arguments","push","unshift","emit","expires","duration","expired","clearTimeout","property","validator","console","warn","css","Array","isArray","test","attribute","attr","validateDataType","validate","fieldType","expectedType","fieldname","_obj","rtn","nonEnumerableProperties","substr","undefined","enumerableProperties","dsc","getOwnPropertyDescriptor","set","refs","toJSON","r","data","fieldcfg","suppressEvents","cfg","toLowerCase","source","stack","pop","path","e","charAt","toUpperCase","eval","DATA","util","GUID","old","c","action","new","addValidator","pattern","val","_source","fn","entityType","Store","model","storeCfg","applyStoreMonitor","applyModelMonitor","delta","payload","_this2","record","splice","back","reverse","change","removeRelationshipField","removeField","reverseMap","load","_this3","currentDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","getTime","expire","waitPeriod","setTimeout","JSON","stringify","_this4","_ret2","rmap","_this5","d","serialize","EventEmitter","ModelLoader","Entity","nodelike","module","exports"],"mappings":";;;;AAAA,YCoBA,SAASA,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAEhH,QAASC,4BAA2BC,EAAMC,GAAQ,IAAKD,EAAQ,KAAM,IAAIE,gBAAe,4DAAgE,QAAOD,GAAyB,gBAATA,IAAqC,kBAATA,GAA8BD,EAAPC,EAElO,QAASE,WAAUC,EAAUC,GAAc,GAA0B,kBAAfA,IAA4C,OAAfA,EAAuB,KAAM,IAAIP,WAAU,iEAAoEO,GAAeD,GAASE,UAAYC,OAAOC,OAAOH,GAAcA,EAAWC,WAAaG,aAAeC,MAAON,EAAUO,YAAY,EAAOC,UAAU,EAAMC,cAAc,KAAeR,IAAYE,OAAOO,eAAiBP,OAAOO,eAAeV,EAAUC,GAAcD,EAASW,UAAYV,GARje,GAAIW,SAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIV,cAAgBQ,OAAS,eAAkBE,IAEtOC,aAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWf,WAAae,EAAWf,aAAc,EAAOe,EAAWb,cAAe,EAAU,SAAWa,KAAYA,EAAWd,UAAW,GAAML,OAAOoB,eAAeL,EAAQI,EAAWE,IAAKF,IAAiB,MAAO,UAAU7B,EAAagC,EAAYC,GAAiJ,MAA9HD,IAAYR,EAAiBxB,EAAYS,UAAWuB,GAAiBC,GAAaT,EAAiBxB,EAAaiC,GAAqBjC,MDFhiBkC,MCUY,SAAUC,mBDTtB,QAAAD,OAAAE,GAAAtC,gBAAAuC,KAAAH,OACAE,EAAAA,KADA,IAAAE,GAAApC,2BAAAmC,KAAA3B,OAAA6B,eAAAL,OAAA9B,KAAAiC,OAKAG,EAAAF,CAEA5B,QAAAc,iBAAAc,GAOAG,YAAAC,IAAAC,aAAAP,EAAAK,aAAA,MAqBAG,OAAAF,IAAAA,WAAAN,EAAAQ,SAEAC,IACAC,UAAA,EACAC,KAAAC,OACAC,UAAAb,EAAAS,IAAA,QAoCAK,MAAAR,IAAAA,WAAAN,EAAAe,mBA0BAC,SAAAV,IAAAA,WAAAN,EAAAgB,cAOAC,WAAAX,IAAAA,eAMAY,WAAAZ,IAAAA,UAAAA,IAAAa,SAAAnB,EAAAkB,YAAA,IAQAE,MAAAd,IAAAA,YAAA,GAQAe,YAAAf,IAAAA,YAAA,GAQAgB,IAAAhB,IAAAA,WAAAN,EAAAE,EAAAG,cAAA,MAYAkB,OAAAjB,IAAAA,UAAAA,IAAAa,SAAAnB,EAAAuB,QAAA,IAEAC,UAAAlB,IAAAA,WAAA,MAeAmB,WAAAnB,IAAAA,WAAA,MAGAoB,kBAAApB,IAAAA,WAAA,MAGAqB,WAAArB,IAAAA,YAAA,GAGAsB,UAAAtB,IAAAA,YAAA,GAQAuB,WAAAvB,IAAAC,aAAAuB,KAAAC,OAWAC,cAAA1B,IAAAC,aAAA,WACAN,KAAAuB,UAAAvB,KAAAgC,SACAhC,KAAAiC,eAQAC,iBAAA7B,IAAAA,WAAAA,IAAAa,SAAAnB,EAAAmC,kBAAA,IAMAC,sBAAA9B,IAAAA,WAAAA,IAAAa,SAAAnB,EAAAoC,uBAAA,IAEAC,sBAAA/B,IAAAA,eAEAgC,sBAAAhC,IAAAA,eASA4B,UAAA5B,IAAAA,eAEAiC,kBAAAjC,IAAAC,cACAiC,IAAA,SAAAC,EAAAhE,GACA,MAAA,UAAA6B,IAAAA,UAAA7B,GACAA,EAAAe,QAAAiD,EAGA,WAAAnC,IAAAA,UAAA7B,GACAA,GAAAgE,EAGA,WAAAnC,IAAAA,UAAA7B,GACAA,EAAAiE,OAAAlD,QAAAiD,EAGA,SAAAnC,IAAAA,UAAA7B,IACAA,EAAAkE,SAAAF,EAAAE,SAMAC,IAAA,SAAAC,EAAApE,GACA,MAAA,UAAA6B,IAAAA,UAAA7B,GACAA,EAAAe,QAAAqD,EAGA,WAAAvC,IAAAA,UAAA7B,GACAA,GAAAoE,EAGA,WAAAvC,IAAAA,UAAA7B,GACAA,EAAAiE,OAAAlD,QAAAqD,EAGA,SAAAvC,IAAAA,UAAA7B,IACAA,EAAAkE,SAAAE,EAAAF,SAMAG,OAAA,SAAAC,EAAAtE,GACA,MAAAsE,GAAAC,QAAAvE,IAAA,GAGAiC,SAAA,SAAAuC,EAAAxE,GACA,MAAA2B,GAAA8C,eAAAD,IAAA,OAAA7C,EAAA3B,MAuBA0E,SAAA7C,IAAAA,WAAAN,EAAAoD,SAAA,MACAC,gBAAA/C,IAAAA,UAAA,MAOAgD,IAAAhD,IAAAA,eAOAiD,SAAAjD,IAAAA,eAEAkD,OAAAlD,IAAAA,WAAA,OAIA,IAAAmD,GAAAvD,EAAAwD,WAAAC,OAAAzD,EAAA0D,mBAAAD,OAAAzD,EAAAa,eAAA8C,OAAA,SAAAlE,EAAAJ,EAAAuE,GACA,MAAAA,GAAAd,QAAArD,KAAAJ,GAGA,IAAAkE,EAAAjE,OAAA,EACA,KAAA,IAAAuE,OAAA,gCAAAN,EAAAO,KAAA,MAAA,uFAIA9D,GAAAM,OAAA0C,eAAA,QACAlD,EAAAQ,OAAAC,IACAC,UAAA,EACAC,KAAAC,OACAC,UAAAb,EAAAS,IAAA,OAKAnC,OAAA2F,KAAA/D,EAAAM,QAAA0D,QAAA,SAAAjB,GACA,WAAAlE,QAAAqB,EAAAI,OAAAyC,KAAA,OAAA7C,EAAAI,OAAAyC,KACA7C,EAAAI,OAAAyC,IACAvC,UAAA,EACAC,KAAAP,EAAAI,OAAAyC,GACApC,UAAA,KACAsD,KAAAlB,IAGA7C,EAAAgE,SAAAnB,GAAA,KAIA3E,OAAA2F,KAAA/D,EAAAc,UAAAkD,QAAA,SAAAG,GACA/F,OAAAoB,eAAAU,EAAAiE,EAAA/D,IAAAgE,IAAA,WACA,MAAAlE,GAAAY,SAAAqD,GAAAE,MAAAnE,QAKA9B,OAAA2F,KAAA/D,EAAAY,OAAAoD,QAAA,SAAAjB,GACA7C,EAAAoE,qBAAAvB,EAAA7C,EAAAU,MAAAmC,IAAA,IAGA,IAAAwB,IACA,eACA,eACA,eACA,gBACA,gBACA,mBACA,sBACA,sBACA,UAhXA,OAmXAnE,KAAAoE,KACAD,EAAAP,QAAA,SAAAS,GACAvE,EAAAwE,GAAAD,EAAA,WACA,GAAAE,GAAAvE,IAAAwE,MAAAC,UACAF,GAAAG,KAAA5E,GACAyE,EAAAI,QAAAN,GACArE,IAAAoE,IAAAQ,KAAAX,MAAAjE,IAAAoE,IAAAG,OAMA7E,EAAAkD,eAAA,aACAhD,EAAAiF,QAAAnF,EAAAmF,SAhYAjF,ECqgDE,MA3/CAhC,WAAU4B,MAAOC,mBA6XjBZ,aAAaW,QACXH,IAAK,SAWLlB,MAAO,SD4OX2G,GACA,IAAAnF,KAAAoF,QAIA,MAAAD,QACAnF,KAAAkF,QAAAC,QAIAnF,KAAA2B,YAKA3B,KAAA0B,YAAA,EAEA2D,aAAArF,KAAAyB,mBAEAzB,KAAAiF,KAAA,UAAAjF,WCnOIN,IAAK,oBACLlB,MAAO,WD0OXwB,KAAAkF,cClNIxF,IAAK,eACLlB,MAAO,SDsOX8G,EAAAC,GACA,IAAAvF,KAAAiD,eAAAqC,GAEA,WADAE,SAAAC,KAAA,sCAAAH,EAAA,mCAAAtF,KAAAU,KAAA,MAAAL,IAAAqF,IAAA,GAAArF,IAAAqF,IAAA,GAIA,QAAA,mBAAAH,GAAA,YAAAzG,QAAAyG,IACA,IAAA,WACAvF,KAAAgB,WAAAsE,GAAAtF,KAAAgB,WAAAsE,OACAtF,KAAAgB,WAAAsE,GAAAP,KAAAQ,GACAvF,KAAAiF,KAAA,gBAAAK,EACA,MACA,KAAA,SACAK,MAAAC,QAAAL,IACAvF,KAAAgB,WAAAsE,GAAAtF,KAAAgB,WAAAsE,OACAtF,KAAAgB,WAAAsE,GAAAP,KAAA,SAAAvG,GACA,MAAA+G,GAAAxC,QAAAvE,IAAA,IAEAwB,KAAAiF,KAAA,gBAAAK,IACAC,EAAAM,MACA7F,KAAAgB,WAAAsE,GAAAtF,KAAAgB,WAAAsE,OACAtF,KAAAgB,WAAAsE,GAAAP,KAAA,SAAAvG,GACA,MAAA+G,GAAAM,KAAArH,KAEAwB,KAAAiF,KAAA,gBAAAK,IAEAE,QAAAC,KAAA,uCAAAH,EAAA,2CAAAjF,IAAAqF,IAAA,GAEA,MACA,KAAA,SACA,IAAA,SACA,IAAA,OACA1F,KAAAgB,WAAAsE,GAAAtF,KAAAgB,WAAAsE,OACAtF,KAAAgB,WAAAsE,GAAAP,KAAA,SAAAvG,GACA,MAAAA,KAAA+G,IAEAvF,KAAAiF,KAAA,gBAAAK,EACA,MACA,SACAE,QAAAC,KAAA,sCAAAH,EAAA,2CAAAjF,IAAAqF,IAAA,QCxNIhG,IAAK,kBACLlB,MAAO,SDkOXsH,GACA9F,KAAAgB,WAAAiC,eAAA6C,WACA9F,MAAAgB,WAAA8E,GACA9F,KAAAiF,KAAA,mBAAAa,OCnNIpG,IAAK,WACLlB,MAAO,SD+NXsH,GACA,GAAA3F,GAAAH,IAGA,IAAA8F,EAAA,CACA,GAAA9F,KAAAgB,WAAAiC,eAAA6C,GAAA,CACA,IAAA,GAAAxG,GAAA,EAAAA,EAAAU,KAAAgB,WAAA8E,GAAAvG,OAAAD,IAAA,CACA,IAAAa,EAAAa,WAAA8E,GAAAxG,GAAAa,EAAA2F,IAEA,MADA3F,GAAAiC,sBAAAW,QAAA+C,GAAA,GAAA3F,EAAAiC,sBAAA2C,KAAAe,IACA,CAEA3F,GAAAiC,sBAAAjC,EAAAiC,sBAAAwB,OAAA,SAAAmC,GACA,MAAAD,KAAAC,IAKA,IAAA/F,KAAAgG,iBAAAF,GAEA,MADA9F,MAAAoC,sBAAA2C,KAAAe,IACA,EAIA,OAAA,EAIA9F,KAAAyD,WAAAQ,QAAA,SAAAjB,GACA7C,EAAA8F,SAAAjD,QCjNItD,IAAK,mBACLlB,MAAO,SD4NXwE,GACA,GAAAkD,GAAA7F,IAAAA,UAAAL,KAAAgD,IACAmD,EAAA9F,IAAAA,UAAAL,KAAAO,OAAAyC,GAAAtC,KAEA,OAAA,SAAAwF,EACAA,IAAAC,EAGA,OAAAnG,KAAAgD,KAAAhD,KAAAO,OAAAyC,GAAAvC,aACAT,KAAAsB,QAAA0B,IAAAhD,KAAAI,gBC1MIV,IAAK,uBACLlB,MAAO,SDyNX4H,GACA,MAAApG,MAAAa,MAAAuF,MC7MI1G,IAAK,kBACLlB,MAAO,SDsNX4H,GACA,MAAApG,MAAAa,MAAAoC,eAAAmD,MC1MI1G,IAAK,eACLlB,MAAO,SDmNX4H,GACA,MAAApG,MAAAO,OAAA6F,MCvMI1G,IAAK,eACLlB,MAAO,SDgNX4H,GACA,MAAApG,MAAAO,OAAA0C,eAAAmD,MC7LI1G,IAAK,YACLlB,MAAO,SD6MXS,GACA,GAAAoH,GAAApH,GAAAe,KAAAqD,IACAiD,IAEA,KAAA,GAAA5G,KAAA2G,GAEA,GADAA,EAAAE,wBAAAF,EAAAE,yBAAA,GACAvG,KAAAO,OAAA0C,eAAAvD,KACAA,EAAA,OAAAA,EAAAM,KAAAI,YAAAV,EACA2G,EAAApD,eAAAvD,IAAA2G,EAAAE,wBAAAxD,QAAArD,GAAA,GAAA,cAAAmG,KAAAnG,EAAA8G,OAAA,EAAA,KAAAC,SAAAJ,EAAA3G,IAAA2G,EAAAK,qBAAA3D,QAAArD,IAAA,GAAA,CACA,GAAAiH,GAAAtI,OAAAuI,yBAAAP,EAAA3G,EACA,KAAAiH,EAAAE,IAEA,OAAA/H,QAAA6H,EAAAnI,QACA,IAAA,WAEA,SAAAmI,EAAAnI,MAAA0F,KACAoC,EAAA5G,GAAA2G,EAAA3G,GAAAoH,KAAAC,SACA,WAAAJ,EAAAnI,MAAA0F,OACAoC,EAAA5G,GAAAiH,EAAAnI,QAEA,MACA,KAAA,SAEA6H,EAAA3G,YAAAiG,SAAAA,MAAAC,QAAAS,EAAA3G,MACA2G,EAAA3G,GAAA2G,EAAA3G,GAAAmF,MAAA,IAGAyB,EAAA5G,GAAA2G,EAAA3G,EACA,MACA,SACA4G,EAAA5G,GAAA2G,EAAA3G,IAQA,GAAAS,GAAAH,IAKA,OAJAA,MAAAc,cAAAmD,QAAA,SAAA+C,GACAV,EAAAU,GAAA7G,EAAAmD,SAAA0D,GAAAC,OAGAX,KC9LI5G,IAAK,WACLlB,MAAO,QAAS2F,UD0MpBnB,MAAAkE,SAAAC,gBACA,iBAAAD,YACAC,eAAAD,SACAA,SAAA,MAEAC,eAAAV,SAAAU,gBAAAA,cACA,IAAAhH,IAAAH,KACAoH,IAAA,IACA,IAAA,OAAApE,MAAAqE,cAAA,CACA,GAAA,YAAA,mBAAArE,OAAA,YAAAlE,QAAAkE,QAAA,CACA,IAAAA,MAAAkB,KACA,KAAA,IAAAJ,OAAA,kGAEAsD,KAAApE,MACAA,MAAAoE,IAAAlD,WACAkD,KAAAlD,KAGA,GAAAuC,SAAAtG,GAAA6C,OAAA,CACA,IACA,GAAAsE,QAAAjH,IAAAkH,MAAAC,KACAhC,SAAAC,KAAA,KAAAzC,MAAA,8CAAAsE,OAAAG,KAAA,6CAAApH,IAAAqF,IAAA,GAAArF,IAAAqF,IAAA,IACA,MAAAgC,GACAlC,QAAAC,KAAA,KAAAzC,MAAA,+EAAA3C,IAAAqF,IAAA,GAAArF,IAAAqF,IAAA,UAEAvF,IAAA6C,OAOA,GAHA7C,GAAAI,OAAAyC,OAAAoE,KAAAjH,GAAAI,OAAAyC,WACA7C,GAAAI,OAAAyC,OAAAvC,SAAAJ,IAAAa,SAAAf,GAAAI,OAAAyC,OAAAvC,UAAA,IAEAN,GAAAI,OAAAyC,OAAAC,eAAA,SACA9C,GAAAI,OAAAyC,OAAAC,eAAA,WAAA,CACA,GAAAvC,MAAAL,IAAAA,UAAAF,GAAAI,OAAAyC,OAAA7C,WACAO,MAAAA,KAAAiH,OAAA,GAAAC,cAAAlH,KAAAmE,MAAA,GACA1E,GAAAI,OAAAyC,OAAAtC,KAAAmH,KAAAnH,MAqCA,GAlCAP,GAAAI,OAAAyC,OAAAtC,KAAAL,IAAAa,SAAAf,GAAAI,OAAAyC,OAAAtC,KAAAC,QACAqC,QAAA7C,GAAAC,aAAAD,GAAAmB,UAAA,GACAnB,GAAAI,OAAAyC,OAAAtC,KAAAC,OACAR,GAAAI,OAAAyC,OAAA,WAAA3C,IAAAyH,KAAAC,KAAAC,QAEA7H,GAAAI,OAAAyC,OAAA,WAAA7C,GAAAI,OAAAyC,OAAA,YAAA,KAEA7C,GAAAkD,IAAAL,OAAA7C,GAAAI,OAAAyC,OAAA,WACA7C,GAAA6C,OAAA7C,GAAAkD,IAAAL,OAEA3E,OAAAoB,eAAAU,GAAA6C,OACAqB,IAAA,WACA,MAAAlE,IAAAkD,IAAAL,QAEA6D,IAAA,SAAArI,GACA,GAAAyJ,GAAA9H,GAAAkD,IAAAL,MACA7C,IAAAkD,IAAAL,OAAAxE,CACA,IAAA0J,IACAC,OAAA,SACAnF,MAAAA,MACAiF,IAAAA,EACAG,MAAAjI,GAAAkD,IAAAL,OAEAhD,MAAAiC,UAAA8C,KAAAmD,GACAlI,KAAAiF,KAAA,eAAAiD,GACAlI,KAAAiF,KAAA,gBAAAjC,MAAAkF,GACA/H,GAAA8F,SAAAjD,QACA7C,GAAA8E,KAAA,iBACAjC,MAAAA,YAMAmE,eAAA,CACA,GAAAe,IACAC,OAAA,SACAnF,MAAAA,MAEAhD,MAAAiC,UAAA8C,KAAAmD,GACAlI,KAAAiF,KAAA,eAAAiD,GAIA,GAAA/H,GAAAI,OAAA0C,eAAAD,SACA7C,GAAAI,OAAAyC,OAAAC,eAAA,YACA9C,GAAAkI,aAAArF,MAAA7C,GAAAI,OAAAyC,OAAAsF,UAEA,MAAA,MAAA,QAAArE,QAAA,SAAAG,GACAjE,GAAAI,OAAAyC,OAAAC,eAAAmB,IACAjE,GAAAkI,aAAArF,MAAA,SAAAuF,GACA,MAAApI,IAAAmC,kBAAA8B,GAAAjE,GAAAI,OAAAyC,OAAAoB,GAAAmE,OAIApI,GAAAI,OAAAyC,OAAAC,eAAA,aACA9C,GAAAI,OAAAyC,OAAAvC,UACAN,GAAAkI,aAAArF,MAAA,SAAAuF,GACA,MAAApI,IAAAmC,kBAAA7B,SAAAuC,MAAAuF,KAIApI,GAAAI,OAAAyC,OAAAC,eAAA,aACA,GAAA,kBAAA9C,IAAAI,OAAAyC,OACA7C,GAAAkI,aAAArF,MAAA,SAAAuF,GACA,MAAApI,IAAAI,OAAAyC,OAAAuF,SAEA,CACA,GAAAC,SAAAnI,IAAAkH,MAAAC,KACAhC,SAAAC,KAAA,4CAAA+C,QAAAf,KAAA,sEAAApH,IAAAqF,IAAA,SAIA,QAAAvF,GAAAK,IAAAL,GAAAmB,SACAnB,GAAAK,GAAAH,IAAAyH,KAAAC,KAAAC,WC3LItI,IAAK,aACLlB,MAAO,SDuMX0F,EAAAuE,GACA,GAAAtI,GAAAH,IACA3B,QAAAoB,eAAAO,KAAAkE,GACAG,IAAA,WACA,MAAAoE,GAAAnE,MAAAnE,SCrLIT,IAAK,uBACLlB,MAAO,SDoMX0F,EAAAkD,EAAAD,GAGA,GAFAA,EAAAV,SAAAU,GAAAA,EAEAnH,KAAAsD,SAAAL,eAAAiB,IAAAlE,KAAAO,OAAA0C,eAAAiB,IAAAlE,KAAAiD,eAAAiB,GACA,KAAA,IAAAJ,OAAAI,EAAA,0DASA,KANA,kBAAAkD,IAAA,YAAA,mBAAAA,GAAA,YAAAtI,QAAAsI,MAAAA,EAAAnE,eAAA,WACAmE,GACA1G,KAAA0G,KAIAA,EAAA1G,KACA,KAAA,IAAAoD,OAAA,6FAGAsD,GAAA3G,SAAAJ,IAAAa,SAAAkG,EAAA3G,UAAA,GACA2G,EAAAA,WAAAA,EAAAA,YAAA,IAEA,IAAAjH,GAAAH,KACA0I,EAAA,OACA,IAAAtB,EAAA1G,eAAAL,KAAAyH,KAAAa,MACAD,EAAA,YACA,IAAA,UAAArI,IAAAA,UAAA+G,EAAA1G,MAAA,CACA,GAAA,IAAA0G,EAAA1G,KAAAnB,OACA,KAAA,IAAAuE,OAAAI,EAAA,uDAEAwE,GAAA,iBACA,WAAA5J,QAAAsI,EAAA1G,OACA0G,EAAA1G,KAAAkI,QACAF,EAAA,QAIA,IAAA,UAAAA,EAAA,CACA,GAAAG,KACA,IAAAzB,EAAA1G,eAAAL,KAAAyH,KAAAa,MACA3I,KAAAsD,SAAAY,GAAAkD,EAAA1G,KACAmI,EAAA,SACA,CAAA,IAAAzB,EAAA1G,KAAAkI,MAGA,KAAA,IAAA9E,OAAA,+DAFA+E,GAAAzB,EAAA1G,KAKA,OAAAmI,IACA7I,KAAAsD,SAAAY,GAAA,GAAA7D,KAAAyH,KAAAa,MAAAE,IAEA7I,KAAA8I,kBAAA5E,OACA,IAAA,eAAAwE,EACA1I,KAAAsD,SAAAY,GAAA,GAAA7D,KAAAyH,KAAAa,OACAC,MAAAxB,EAAA1G,KAAA,KAEAV,KAAA8I,kBAAA5E,OACA,IAAAkD,EAAA1G,KAAAuG,KAGA,CAAA,IAAAG,EAAA1G,KAAAuG,KAIA,KAAA,IAAAnD,OAAA,+DAHA9D,MAAAsD,SAAAY,GAAAkD,EAAA1G,KACAV,KAAA8I,kBAAA5E,OAJAlE,MAAAsD,SAAAY,GAAA,OAAAkD,EAAAA,WAAA,GAAAA,GAAA1G,KAAA0G,EAAAA,YAAA,GAAAA,GAAA1G,KACAV,KAAA+I,kBAAA7E,EAeA,IAPA7F,OAAAoB,eAAAO,KAAAkE,GACAzF,YAAA,EACA4F,IAAA,WACA,MAAAlE,GAAAmD,SAAAY,OAIAiD,EAAA,CACA,GAAAe,IACAC,OAAA,SACAnF,MAAAkB,EAEAlE,MAAAiC,UAAA8C,KAAAmD,GACAlI,KAAAiF,KAAA,sBAAAiD,OCvLIxI,IAAK,oBACLlB,MAAO,SDiMX0F,GACA,GAAA0E,GAAA5I,KAAAsD,SAAAY,GACA/D,EAAAH,IAEA4I,GAAAjE,GAAA,eAAA,SAAAqE,GACA,GAAAC,IACAd,OAAA,SACAnF,MAAAkB,EAAA,IAAA8E,EAAAhG,MACAiF,IAAAe,EAAAf,IACAG,MAAAY,EAAAA,OACAjF,MAAA,EAGA5D,GAAA8E,KAAA,eAAAgE,GACA9I,EAAA8E,KAAA,gBAAAf,EAAA,IAAA8E,EAAAhG,MAAAiG,KAGAL,EAAAjE,GAAA,eAAA,SAAAqE,GACA,GAAAC,IACAd,OAAA,SACAnF,MAAAkB,EAAA,IAAA8E,EAAAhG,MACAiF,IAAA,KACAG,MAAA,KACArE,MAAA,EAGA5D,GAAA8E,KAAA,eAAAgE,GACA9I,EAAA8E,KAAA,gBAAAf,EAAA,IAAA8E,EAAAhG,MAAAiG,KAGAL,EAAAjE,GAAA,eAAA,SAAAqE,GACA,GAAAC,IACAd,OAAA,SACAnF,MAAAkB,EAAA,IAAA8E,EAAAhG,MACAiF,IAAAe,EAAAxK,MACA4J,MAAA,KACArE,MAAA,EAGA5D,GAAA8E,KAAA,eAAAgE,GACA9I,EAAA8E,KAAA,gBAAAf,EAAA,IAAA8E,EAAAhG,MAAAiG,QCpLIvJ,IAAK,oBACLlB,MAAO,SD8LX0F,GAAA,GAAAgF,GAAAlJ,IACAA,MAAAsD,SAAAL,eAAAiB,IAIAlE,KAAAsD,SAAAY,GAAAjB,eAAA,WAAA,WACA,GAAA9C,GAAA+I,CAEAA,GAAA5F,SAAAY,GAAAS,GAAA,gBAAA,SAAAwE,GACA,GAAAlB,GAAA9H,EAAA+D,GAAA+C,IACAgB,GAAAT,KAEA,IAAAU,IACAC,OAAA,SACAnF,MAAAkB,EACAH,MAAA,EACAkE,IAAAA,EACAG,MAAAjI,EAAA+D,GAAA+C,KAGA9G,GAAA8E,KAAA,eAAAiD,GACA/H,EAAA8E,KAAA,gBAAAf,EAAAgE,KAGAgB,EAAA5F,SAAAY,GAAAS,GAAA,gBAAA,SAAAwE,EAAAH,GACA,GAAAA,EAAA,CAIA,GAAAd,IACAC,OAAA,SACAnF,MAAAkB,EAAA,IAAA8E,EAAAhG,MACAe,MAAA,EACAkE,IAAAe,EAAAf,IACAG,MAAAY,EAAAA,OAGA7I,GAAA8E,KAAA,eAAAiD,GACA/H,EAAA8E,KAAA,gBAAAf,EAAA,IAAA8E,EAAAhG,MAAAkF,MAGAgB,EAAA5F,SAAAY,GAAAS,GAAA,gBAAA,SAAAwE,GACA,GAAAlB,GAAA9H,EAAA+D,GAAA+C,IACAgB,GAAAlD,KAAAoE,EAAAlC,KAEA,IAAAiB,IACAC,OAAA,SACAnF,MAAAkB,EACAH,MAAA,EACAkE,IAAAA,EACAG,MAAAjI,EAAA+D,GAAA+C,KAGA9G,GAAA8E,KAAA,eAAAiD,GACA/H,EAAA8E,KAAA,gBAAAf,EAAAgE,WC7KIxI,IAAK,cACLlB,MAAO,SDuLX0F,GACA,GAAAlE,KAAAqD,IAAAJ,eAAAiB,GAAA,CACA,GAAAqE,GAAAvI,KAAAqD,IAAAa,SACAlE,MAAAkE,SACAlE,MAAAO,OAAA2D,SACAlE,MAAAqD,IAAAa,GACAlE,KAAAoC,sBAAAW,QAAAmB,IAAA,GACAlE,KAAAoC,sBAAAgH,OAAApJ,KAAAoC,sBAAAW,QAAAmB,GAAA,EAEA,IAAAgE,IACAC,OAAA,SACAnF,MAAAkB,EACA1F,MAAA+J,EAEAvI,MAAAiF,KAAA,eAAAiD,GACAlI,KAAAiC,UAAA8C,KAAAmD,OC3KIxI,IAAK,gBACLlB,MAAO,SDoLX0F,SACAlE,MAAAkE,MCvKIxE,IAAK,0BACLlB,MAAO,SDiLX0F,EAAAiD,GAEA,GADAA,EAAAV,SAAAU,GAAAA,EACAnH,KAAAa,MAAAoC,eAAAiB,GAAA,CACA,GAAAqE,GAAAvI,KAAAsD,SAAAY,EAIA,UAHAlE,MAAAsD,SAAAY,SACAlE,MAAAkE,SACAlE,MAAAa,MAAAqD,IACAiD,EAAA,CACA,GAAAe,IACAC,OAAA,SACAnF,MAAAkB,EACA+D,IAAAM,EACAxE,MAAA,EAEA/D,MAAAiC,UAAA8C,KAAAmD,GACAlI,KAAAiF,KAAA,sBAAAiD,QChKIxI,IAAK,OACLlB,MAAO,SD8KX6K,GACAA,EAAAA,GAAA,CACA,IAAApB,GAAAjI,KAAAiC,UAAAmH,OAAApJ,KAAAiC,UAAA1C,OAAA8J,EAAAA,GACAlJ,EAAAH,IAEAiI,GAAAqB,UAAArF,QAAA,SAAAsF,GACA,GAAA,iBAAAA,GAAAxF,MAAAwF,EAAAxF,KAcA,OAAAwF,EAAApB,QACA,IAAA,SACAhI,EAAAqJ,wBAAAD,EAAAvG,MACA,MACA,KAAA,SACA7C,EAAAoE,qBAAAgF,EAAAvG,OACA7C,EAAAoJ,EAAAvG,OAAAuG,EAAAtB,QAnBA,QAAAsB,EAAApB,QACA,IAAA,SACAhI,EAAAoJ,EAAAvG,OAAAuG,EAAAtB,GACA,MACA,KAAA,SACA9H,EAAAsJ,YAAAF,EAAAvG,MACA,MACA,KAAA,SACA7C,EAAAgE,SAAAoF,EAAAvG,OACA7C,EAAAoJ,EAAAvG,OAAA7C,EAAA8H,UCpJIvI,IAAK,OACLlB,MAAO,SD2KXyI,GACAA,EAAAA,KAGA,IAAA9G,GAAAH,IACA,QAAAA,KAAAkD,UACA7E,OAAA2F,KAAAhE,KAAA0J,YAAAzF,QAAA,SAAAvE,GACAuH,EAAAhE,eAAAvD,KACAuH,EAAA9G,EAAAuJ,WAAAhK,IAAAuH,EAAAvH,SACAuH,GAAAvH,MAMArB,OAAA2F,KAAAiD,GAAAhD,QAAA,SAAAvE,GACA,GAAAS,EAAAI,OAAA0C,eAAAvD,GACAS,EAAAkD,IAAAJ,eAAAvD,GACAS,EAAAkD,IAAA3D,GAAAuH,EAAAvH,GACAA,IAAAS,EAAAC,cACAD,EAAAK,GAAAyG,EAAAvH,QAEA,IAAAS,EAAAU,MAAAoC,eAAAvD,GAIAS,EAAAmD,SAAA5D,GAAAiK,KAAA1C,EAAAvH,QAEA,KACA,GAAA4H,GAAAjH,IAAAkH,MAAAC,KACAhC,SAAAC,KAAA,KAAA/F,EAAA,qBAAA4H,EAAAG,KAAA,sDAAApH,IAAAqF,IAAA,GAAArF,IAAAqF,IAAA,IACA,MAAAgC,GACAlC,QAAAC,KAAA,KAAA/F,EAAA,gEAAAW,IAAAqF,IAAA,OAKA1F,KAAA+B,mBCxKIrC,IAAK,UACL2E,IAAK,WDh2BT,MAAArE,MAAAwB,YCm2BIqF,IAAK,SDh2BTrI,GAAA,GAAAoL,GAAA5J,IAEA,IAAA,SAAAK,IAAAA,UAAA7B,IAAA,WAAA6B,IAAAA,UAAA7B,GAAA,CAeA,GAHA6G,aAAArF,KAAAyB,mBAGA,WAAApB,IAAAA,UAAA7B,GAAA,CACA,GAAAA,EAAA,EAEA,YADAwB,KAAA2B,WAAA,EAIA,IAAAkI,GAAA,GAAAhI,KAEArD,GAAA,GAAAqD,MACAgI,EAAAC,cACAD,EAAAE,WACAF,EAAAG,UACAH,EAAAI,WACAJ,EAAAK,aACAL,EAAAM,aACAN,EAAAO,kBAAA5L,GAYA,GANAwB,KAAA2B,WAAA,EAGA3B,KAAAwB,WAAAhD,EAGAqD,KAAAC,OAAA9B,KAAAwB,WAAA6I,UAEA,WADArK,MAAAsK,QAIAtK,MAAA0B,YAAA,CAGA,IAAA6I,GAAAvK,KAAAwB,WAAA6I,UAAAxI,KAAAC,KACA9B,MAAAyB,kBAAA+I,WAAA,WACAZ,EAAAU,UACAC,OApDA,KACA,GAAAjD,GAAAjH,IAAAkH,MAAAC,KACAhC,SAAAC,KAAA,oCAAA6B,EAAAG,KAAA,oDAAApH,IAAAqF,IAAA,IACA,MAAAgC,GACAlC,QAAAC,KAAA,kFCm5BI/F,IAAK,UACL2E,IAAK,WD51BT,OAAArE,KAAA2B,WAIA3B,KAAA0B,cCu2BIhC,IAAK,WACL2E,IAAK,WD/1BT,MAAArE,MAAAgC,WAAAhC,KAAAuB,aC02BI7B,IAAK,KACL2E,IAAK,WDl2BT,MAAArE,MAAAqB,KCq2BIwF,IAAK,SDl2BTrI,GACAwB,KAAAqB,IAAA7C,KC42BIkB,IAAK,WACL2E,IAAK,WDp2BT,MAAAhE,KAAAyH,KAAAC,KAAA/F,SAAAyI,KAAAC,UAAA1K,KAAAiH,UC+2BIvH,IAAK,UACL2E,IAAK,WDv2BT,MAAArE,MAAAkD,UC02BI2D,IAAK,SDv2BTrI,GACAwB,KAAAkD,SAAA1E,EACAwB,KAAAoD,gBAAA,QCk3BI1D,IAAK,YACL2E,IAAK,WDz2BT,MAAArE,MAAAuD,UCm3BI7D,IAAK,QACL2E,IAAK,WD32BT,MADArE,MAAAiG,WACA,IAAAjG,KAAAoC,sBAAA7C,UCu3BIG,IAAK,aACL2E,IAAK,WD/2BT,MAAAhG,QAAA2F,KAAAhE,KAAAO,WC03BIb,IAAK,gBACL2E,IAAK,WDl3BT,MAAAhG,QAAA2F,KAAAhE,KAAAa,UC63BInB,IAAK,oBACL2E,IAAK,WDr3BT,MAAAhG,QAAA2F,KAAAhE,KAAAe,aCg5BIrB,IAAK,aACL2E,IAAK,WDz3BT,GAAAsG,GAAA3K,IACA,IAAA,OAAAA,KAAAmD,QAAA,CAAA,GAAAyH,GAAA,WACA,GAAA,OAAAD,EAAAvH,gBACA,OAAAgB,EAAAuG,EAAAvH,gBAEA,IAAAyH,MACA1K,EAAAwK,CAKA,OAJAtM,QAAA2F,KAAA2G,EAAAzH,UAAAe,QAAA,SAAA8B,GACA8E,EAAA1K,EAAA+C,SAAA6C,IAAAA,IAEA4E,EAAAvH,gBAAAyH,GACAzG,EAAAyG,KAVA,IAAA,YAAA,mBAAAD,GAAA,YAAA9L,QAAA8L,IAAA,MAAAA,GAAAxG,EAYA,MAAA,SC84BI1E,IAAK,OACL2E,IAAK,WDt4BT,GAAAyG,GAAA9K,KACA+K,EAAA/K,KAAAgL,WAmBA,QAlBAD,EAAA9H,eAAAjD,KAAAI,cAAAJ,KAAAsB,SACAyJ,EAAA/K,KAAAI,aAAAJ,KAAAA,KAAAI,cAEAJ,KAAAmD,UAAA,WACA,GAAAhD,GAAA2K,CAEAzM,QAAA2F,KAAA8G,EAAA3H,SAAAc,QAAA,SAAAvE,GAEAqL,EAAA9H,eAAAvD,KACAqL,EAAArL,YAAAW,KAAAyH,KAAAjI,MACAkL,EAAA5K,EAAAgD,QAAAzD,IAAAqL,EAAArL,GAAAuH,KAEA8D,EAAA5K,EAAAgD,QAAAzD,IAAAqL,EAAArL,SAEAqL,GAAArL,SAIAqL,KCu5BIrL,IAAK,UACL2E,IAAK,WD54BT,MAAArE,MAAAiC,UAAAqH,cCi5BSzJ,ODtgDTQ,IAAA4K,aAi5CA5K,KAAAyH,KAAAzH,IAAAyH,SAKAzJ,OAAAc,iBAAAkB,IAAAyH,MACAjI,MAAAQ,IAAAA,UAAA,SAAA+G,GACA,GAAA8D,GAAA,SAAAjE,GACA,GAAA2B,GAAA,GAAA/I,OAAAuH,EAIA,OAHAH,IACA2B,EAAAe,KAAA1C,GAEA2B,EAGA,OAAAsC,KAGAC,OAAA9K,IAAAA,WAAAR,SAGAQ,IAAA+K,WACAC,OAAAC,QAAAjL,IAAAyH","file":"model.min.js","sourcesContent":["'use strict'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nclass Model extends NGN.EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields ||\n        {\n          id: {\n            required: true,\n            type: String,\n            'default': config.id || null\n          }\n        }\n      ),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @cfgproperty {Date|Number} [expires]\n       * When this is set to a date/time, the model record will be marked\n       * as expired at the specified time/date. If a number is specified\n       * (milliseconds), the record will be marked as expired after the\n       * specified time period has elapsed. When a record/model is marked as\n       * \"expired\", it triggers the `expired` event. By default, expired\n       * records/models within an NGN.DATA.Store will be removed from the store.\n       *\n       * Setting this to any value less than `0` disables expiration.\n       * @fires expired\n       * Triggered when the model/record expires.\n       */\n      expiration: NGN.private(null),\n\n      // Used to hold a setTimeout method for expiration events.\n      expirationTimeout: NGN.private(null),\n\n      // Placeholder expiration flag.\n      hasExpired: NGN.private(false),\n\n      // Used to prevent expiration of a record.\n      ignoreTTL: NGN.private(false),\n\n      /**\n       * @property {Number} created\n       * The date/time when the model is created. This is represented as\n       * the number of milliseconds since the epoch (Jan 1, 1970, 00:00:00 UTC).\n       * @private\n       */\n      createDate: NGN.privateconst(Date.now()),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum\n        this.changelog = []\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function (minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse()\n          }\n\n          return false\n        },\n\n        max: function (maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse()\n          }\n\n          return false\n        },\n\n        enum: function (valid, value) {\n          return valid.indexOf(value) >= 0\n        },\n\n        required: function (field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    })\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    let allfields = this.datafields.concat(this.virtualdatafields).concat(this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i\n    })\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.')\n    }\n\n    // Make sure an ID reference is available.\n    if (!this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      }\n    }\n\n    // Add fields\n    Object.keys(this.fields).forEach(function (field) {\n      if (typeof me.fields[field] !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        }\n      }\n      me.addField(field, true)\n    })\n\n    // Add virtuals\n    Object.keys(this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me)\n      }))\n    })\n\n    // Add relationships\n    Object.keys(this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true)\n    })\n\n    let events = [\n      'field.update',\n      'field.create',\n      'field.remove',\n      'field.invalid',\n      'validator.add',\n      'validator.remove',\n      'relationship.create',\n      'relationship.remove',\n      'expired'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.push(me)\n          args.unshift(eventName)\n          NGN.BUS.emit.apply(NGN.BUS, args)\n        })\n      })\n    }\n\n    // If an expiration is defined, set it.\n    if (config.hasOwnProperty('expires')) {\n      this.expires = config.expires\n    }\n  }\n\n  get expires () {\n    return this.expiration\n  }\n\n  set expires (value) {\n    // Validate data type\n    if (NGN.typeof(value) !== 'date' && NGN.typeof(value) !== 'number') {\n      try {\n        const source = NGN.stack.pop()\n        console.warn('Expiration could not be set at %c' + source.path + '%c (Invalid data type. Must be a Date or number).', NGN.css, '')\n      } catch (e) {\n        console.warn('Expiration could not be set (Invalid data type. Must be a Date or number).')\n      }\n\n      return\n    }\n\n    // Clear existing expiration timer if it is already set.\n    clearTimeout(this.expirationTimeout)\n\n    // If the new value is a number, convert to a date.\n    if (NGN.typeof(value) === 'number') {\n      if (value < 0) {\n        this.ignoreTTL = true\n        return\n      }\n\n      const currentDate = new Date()\n\n      value = new Date (\n        currentDate.getFullYear(),\n        currentDate.getMonth(),\n        currentDate.getDate(),\n        currentDate.getHours(),\n        currentDate.getMinutes(),\n        currentDate.getSeconds(),\n        currentDate.getMilliseconds() + value\n      )\n    }\n\n    // If the process has reached this far, expiration\n    // actions should be enabled.\n    this.ignoreTTL = false\n\n    // Set the new expiration time period\n    this.expiration = value\n\n    // If the record is already expired, immediately trigger the expiration.\n    if (Date.now() >= this.expiration.getTime()) {\n      this.expire()\n      return\n    }\n\n    this.hasExpired = false\n\n    // If the expiration is in the future, set a timer to expire.\n    let waitPeriod = this.expiration.getTime() - Date.now()\n    this.expirationTimeout = setTimeout(() => {\n      this.expire()\n    }, waitPeriod)\n  }\n\n  /**\n   * @property {boolean} expired\n   * Indicates the record/model is expired.\n   */\n  get expired () {\n    if (this.ignoreTTL) {\n      return false\n    }\n\n    return this.hasExpired\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n  get modified () {\n    return this.checksum !== this.benchmark\n  }\n\n  /**\n   * @cfgproperty {String/Number/Date} [id=null]\n   * The unique ID of the model object. If #idAttribute is defined,\n   * this will get/set the #idAttribute value.\n   */\n  get id () {\n    return this.oid\n  }\n\n  set id (value) {\n    this.oid = value\n  }\n\n  /**\n   * @property checksum\n   * The unique checksum of the record (i.e. a record fingerprint).\n   * This will change as the data changes.\n   */\n  get checksum () {\n    return NGN.DATA.util.checksum(JSON.stringify(this.data))\n  }\n\n  /**\n   * @property {Object} dataMap\n   * The current data map.\n   * @private\n   */\n  get dataMap () {\n    return this._dataMap\n  }\n\n  set dataMap (value) {\n    this._dataMap = value\n    this._reverseDataMap = null\n  }\n\n  /**\n   * @property {NGN.DATA.Store} store\n   * If a store is associated with the model, this will\n   * provide a reference to it. If there is no store, this\n   * will return `null`.\n   */\n  get datastore () {\n    return this._store\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the record is valid.\n   */\n  get valid () {\n    this.validate()\n    return this.invalidDataAttributes.length === 0\n  }\n\n  /**\n   * @property datafields\n   * Provides an array of data fields associated with the model.\n   * @returns {String[]}\n   */\n  get datafields () {\n    return Object.keys(this.fields)\n  }\n\n  /**\n   * @property reslationships\n   * Provides an array of join fields associated with the model.\n   * @returns {String[]}\n   */\n  get relationships () {\n    return Object.keys(this.joins)\n  }\n\n  /**\n   * @property virtualdatafields\n   * Provides an array of virtual data fields associated with the model.\n   * @returns {String[]}\n   */\n  get virtualdatafields () {\n    return Object.keys(this.virtuals)\n  }\n\n  /**\n   * @property {object} reverseMap\n   * Reverses the data map. For example, if the original #dataMap\n   * looks like:\n   *\n   * ```js\n   * {\n   *    firstname: 'gn',\n   *    lastname: 'sn\n   * }\n   * ```\n   *\n   * The reverse map will look like:\n   *\n   * ```js\n   * {\n   *    gn: 'firstname',\n   *    sn: 'lastname\n   * }\n   * ```\n   */\n  get reverseMap () {\n    if (this.dataMap !== null) {\n      if (this._reverseDataMap !== null) {\n        return this._reverseDataMap\n      }\n      let rmap = {}\n      const me = this\n      Object.keys(this._dataMap).forEach(function (attr) {\n        rmap[me._dataMap[attr]] = attr\n      })\n      this._reverseDataMap = rmap\n      return rmap\n    }\n    return null\n  }\n\n  /**\n    * @property data\n    * Creates a JSON representation of the data entity. This is\n    * a record that can be persisted to a database or other data store.\n    * @readonly.\n    */\n  get data () {\n    let d = this.serialize()\n    if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n      d[this.idAttribute] = this[this.idAttribute]\n    }\n    if (this.dataMap) {\n      const me = this\n      // Loop through the map keys\n      Object.keys(this.dataMap).forEach(function (key) {\n        // If the node contains key, make the mapping\n        if (d.hasOwnProperty(key)) {\n          if (d[key] instanceof NGN.DATA.Model) {\n            d[me.dataMap[key]] = d[key].data\n          } else {\n            d[me.dataMap[key]] = d[key]\n          }\n          delete d[key]\n        }\n      })\n    }\n    return d\n  }\n\n  /**\n   * @property history\n   * The history of the entity (i.e. changelog).The history\n   * is shown from most recent to oldest change. Keep in mind that\n   * some actions, such as adding new custom fields on the fly, may\n   * be triggered before other updates.\n   * @returns {array}\n   */\n  get history () {\n    return this.changelog.reverse()\n  }\n\n  /**\n   * @method expire\n   * Forcibly expire the model/record.\n   * @param {Date|Number} [duration]\n   * Optionally provide a new expiration time. This is an alternative\n   * way of setting #expires. If no value is specified, the record\n   * will immediately be marked as `expired`.\n   */\n  expire (duration) {\n    if (this.expired) {\n      return\n    }\n\n    if (duration) {\n      this.expires = duration\n      return\n    }\n\n    if (this.ignoreTTL) {\n      return\n    }\n\n    // Force expiration.\n    this.hasExpired = true\n\n    clearTimeout(this.expirationTimeout)\n\n    this.emit('expired', this)\n  }\n\n  /**\n   * @method disableExpiration\n   * Do not expire this model/record.\n   */\n  disableExpiration () {\n    this.expires = -1\n  }\n\n  /**\n    * @method addValidator\n    * Add or update a validation rule for a specific model property.\n    * @param {String} field\n    * The data field to test.\n    * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n    * The validation used to test the property value. This should return\n    * `true` when the data is valid and `false` when it is not.\n    *\n    * * When this is a _function_, the value is passed to it as an argument.\n    * * When this is a _String_, the value is compared for an exact match (case sensitive)\n    * * When this is a _Number_, the value is compared for equality.\n    * * When this is a _Date_, the value is compared for exact equality.\n    * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n    * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n    * * When this is _an array of dates_, the value is compared to each date for equality.\n    * @fires validator.add\n    */\n  addValidator (property, validator) {\n    if (!this.hasOwnProperty(property)) {\n      console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '')\n      return\n    }\n\n    switch (typeof validator) {\n      case 'function':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(validator)\n        this.emit('validator.add', property)\n        break\n      case 'object':\n        if (Array.isArray(validator)) {\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.indexOf(value) >= 0\n          })\n          this.emit('validator.add', property)\n        } else if (validator.test) { // RegExp\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.test(value)\n          })\n          this.emit('validator.add', property)\n        } else {\n          console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n        }\n        break\n      case 'string':\n      case 'number':\n      case 'date':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(function (value) {\n          return value === validator\n        })\n        this.emit('validator.add', property)\n        break\n      default:\n        console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n    }\n  }\n\n  /**\n    * @method removeValidator\n    * Remove a data validator from the object.\n    * @param {String} attribute\n    * The name of the attribute to remove from the validators.\n    * @fires validator.remove\n    */\n  removeValidator (attribute) {\n    if (this.validators.hasOwnProperty(attribute)) {\n      delete this.validators[attribute]\n      this.emit('validator.remove', attribute)\n    }\n  }\n\n  /**\n    * @method validate\n    * Validate one or all attributes of the data.\n    * @param {String} [attribute=null]\n    * Validate a specific attribute. By default, all attributes are tested.\n    * @private\n    * @returns {Boolean}\n    * Returns true or false based on the validity of data.\n    */\n  validate (attribute) {\n    const me = this\n\n    // Single Attribute Validation\n    if (attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        for (let i = 0; i < this.validators[attribute].length; i++) {\n          if (!me.validators[attribute][i](me[attribute])) {\n            me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute)\n            return false\n          } else {\n            me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n              return attribute !== attr\n            })\n          }\n        }\n\n        if (!this.validateDataType(attribute)) {\n          this.invalidDataAttributes.push(attribute)\n          return false\n        }\n      }\n\n      return true\n    }\n\n    // Validate data type of each attribute\n    this.datafields.forEach(function (field) {\n      me.validate(field)\n    })\n  }\n\n  /**\n   * @method validateDataType\n   * Indicates the data types match.\n   * @param {string} fieldname\n   * Name of the field whose data should be validated.\n   * @private\n   * @return {boolean}\n   */\n  validateDataType (field) {\n    const fieldType = NGN.typeof(this[field])\n    const expectedType = NGN.typeof(this.fields[field].type)\n\n    if (fieldType !== 'null') {\n      return fieldType === expectedType\n    }\n\n    if (this[field] === null && this.fields[field].required) {\n      if (this.autoid && field === this.idAttribute) {\n        return true\n      }\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * @method getRelationshipField\n   * Provides specific detail/configuration about a join/relationship.\n   * @param {String} fieldname\n   * The name of the field.\n   * @returns {Object}\n   */\n  getRelationshipField (fieldname) {\n    return this.joins[fieldname]\n  }\n\n  /**\n   * @method hasRelationship\n   * Indicates a data join exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasRelationship (fieldname) {\n    return this.joins.hasOwnProperty(fieldname)\n  }\n\n  /**\n     * @method getDataField\n     * Provides specific detail/configuration about a field.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Object}\n     */\n  getDataField (fieldname) {\n    return this.fields[fieldname]\n  }\n\n  /**\n   * @method hasDataField\n   * Indicates a data field exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasDataField (fieldname) {\n    return this.fields.hasOwnProperty(fieldname)\n  }\n\n  /**\n    * @method serialize\n    * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n    * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n    *\n    * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n    * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n    *\n    * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n    * The model itself can be returned using #getXRef.\n    * @param {Object} [obj]\n    * Defaults to this object.\n    * @protected\n    */\n  serialize (obj) {\n    let _obj = obj || this.raw\n    let rtn = {}\n\n    for (let key in _obj) {\n      _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || ''\n      if (this.fields.hasOwnProperty(key)) {\n        key = key === 'id' ? this.idAttribute : key\n        if ((_obj.hasOwnProperty(key) && (_obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)))) || (_obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0)) {\n          let dsc = Object.getOwnPropertyDescriptor(_obj, key)\n          if (!dsc.set) {\n            // Handle everything else\n            switch (typeof dsc.value) {\n              case 'function':\n                // Support date & regex proxies\n                if (dsc.value.name === 'Date') {\n                  rtn[key] = _obj[key].refs.toJSON()\n                } else if (dsc.value.name === 'RegExp') {\n                  rtn[key] = dsc.value()\n                }\n                break\n              case 'object':\n                // Support array proxies\n                if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                  _obj[key] = _obj[key].slice(0)\n                }\n\n                rtn[key] = _obj[key]\n                break\n              default:\n                rtn[key] = _obj[key]\n                break\n            }\n          }\n        }\n      }\n    }\n\n    const me = this\n    this.relationships.forEach(function (r) {\n      rtn[r] = me.rawjoins[r].data\n    })\n\n    return rtn\n  }\n\n  /**\n   * @method addField\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {object} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (field, fieldcfg, suppressEvents) {\n    if (typeof fieldcfg === 'boolean') {\n      suppressEvents = fieldcfg\n      fieldcfg = null\n    }\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    const me = this\n    let cfg = null\n    if (field.toLowerCase() !== 'id') {\n      if (typeof field === 'object') {\n        if (!field.name) {\n          throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.')\n        }\n        cfg = field\n        field = cfg.name\n        delete cfg.name\n      }\n\n      if (me[field] !== undefined) {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '')\n        }\n        delete me[field]\n      }\n\n      // Create the data field as an object attribute & getter/setter\n      me.fields[field] = cfg || me.fields[field] || {}\n      me.fields[field].required = NGN.coalesce(me.fields[field].required, false)\n\n      if (!me.fields[field].hasOwnProperty('type')) {\n        if (me.fields[field].hasOwnProperty('default')) {\n          let type = NGN.typeof(me.fields[field].default)\n          type = type.charAt(0).toUpperCase() + type.slice(1)\n          me.fields[field].type = eval(type)\n        }\n      }\n      me.fields[field].type = NGN.coalesce(me.fields[field].type, String)\n      if (field === me.idAttribute && me.autoid === true) {\n        me.fields[field].type = String\n        me.fields[field]['default'] = NGN.DATA.util.GUID()\n      } else {\n        me.fields[field]['default'] = me.fields[field]['default'] || null\n      }\n      me.raw[field] = me.fields[field]['default']\n      me[field] = me.raw[field]\n\n      Object.defineProperty(me, field, {\n        get: function () {\n          return me.raw[field]\n        },\n        set: function (value) {\n          let old = me.raw[field]\n          me.raw[field] = value\n          let c = {\n            action: 'update',\n            field: field,\n            old: old,\n            new: me.raw[field]\n          }\n          this.changelog.push(c)\n          this.emit('field.update', c)\n          this.emit('field.update.' + field, c)\n          if (!me.validate(field)) {\n            me.emit('field.invalid', {\n              field: field\n            })\n          }\n        }\n      })\n\n      if (!suppressEvents) {\n        let c = {\n          action: 'create',\n          field: field\n        }\n        this.changelog.push(c)\n        this.emit('field.create', c)\n      }\n\n      // Add field validators\n      if (me.fields.hasOwnProperty(field)) {\n        if (me.fields[field].hasOwnProperty('pattern')) {\n          me.addValidator(field, me.fields[field].pattern)\n        }\n        ['min', 'max', 'enum'].forEach(function (v) {\n          if (me.fields[field].hasOwnProperty(v)) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators[v](me.fields[field][v], val)\n            })\n          }\n        })\n        if (me.fields[field].hasOwnProperty('required')) {\n          if (me.fields[field].required) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators.required(field, val)\n            })\n          }\n        }\n        if (me.fields[field].hasOwnProperty('validate')) {\n          if (typeof me.fields[field] === 'function') {\n            me.addValidator(field, function (val) {\n              return me.fields[field](val)\n            })\n          } else {\n            const source = NGN.stack.pop()\n            console.warn('Invalid custom validation function (in %c' + source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '')\n          }\n        }\n      }\n    } else if (me.id === null && me.autoid) {\n      me.id = NGN.DATA.util.GUID()\n    }\n  }\n\n  /**\n   * @method addVirtual\n   * Add a virtual field dynamically.\n   * @param {string} name\n   * The name of the attribute to add.\n   * @param {function} handler\n   * The synchronous method (or generator) that produces\n   * the desired output.\n   */\n  addVirtual (name, fn) {\n    const me = this\n    Object.defineProperty(this, name, {\n      get: function () {\n        return fn.apply(me)\n      }\n    })\n  }\n\n  /**\n   * @method addRelationshipField\n   * Join another model dynamically.\n   * @param {string} name\n   * The name of the field to add.\n   * @param {Object|NGN.DATA.Model} config\n   * The configuration or data model type. This follows the same syntax\n   * defined in the #joins attribute.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addRelationshipField (name, cfg, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n\n    if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n      throw new Error(name + ' already exists. It cannot be added to the model again.')\n    }\n\n    if (typeof cfg === 'function' || typeof cfg === 'object' && !cfg.hasOwnProperty('type')) {\n      cfg = {\n        type: cfg\n      }\n    }\n\n    if (!cfg.type) {\n      throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.')\n    }\n\n    cfg.required = NGN.coalesce(cfg.required, true)\n    cfg.default = cfg.default || null\n\n    const me = this\n    let entityType = 'model'\n    if (cfg.type instanceof NGN.DATA.Store) {\n      entityType = 'store'\n    } else if (NGN.typeof(cfg.type) === 'array') {\n      if (cfg.type.length === 0) {\n        throw new Error(name + ' cannot be an empty store. A model must be provided.')\n      }\n      entityType = 'collection'\n    } else if (typeof cfg.type === 'object') {\n      if (cfg.type.model) {\n        entityType = 'store'\n      }\n    }\n\n    if (entityType === 'store') {\n      let storeCfg = {}\n      if (cfg.type instanceof NGN.DATA.Store) {\n        this.rawjoins[name] = cfg.type\n        storeCfg = null\n      } else if (cfg.type.model) {\n        storeCfg = cfg.type\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.')\n      }\n\n      if (storeCfg !== null) {\n        this.rawjoins[name] = new NGN.DATA.Store(storeCfg)\n      }\n      this.applyStoreMonitor(name)\n    } else if (entityType === 'collection') {\n      this.rawjoins[name] = new NGN.DATA.Store({\n        model: cfg.type[0]\n      })\n      this.applyStoreMonitor(name)\n    } else if (!cfg.type.data) {\n      this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type()  // eslint-disable-line new-cap\n      this.applyModelMonitor(name)\n    } else if (cfg.type.data) {\n      this.rawjoins[name] = cfg.type\n      this.applyStoreMonitor(name)\n    } else {\n      throw new Error('Nested store configuration is invalid or was not recognized.')\n    }\n\n    Object.defineProperty(this, name, {\n      enumerable: true,\n      get: function () {\n        return me.rawjoins[name]\n      }\n    })\n\n    if (!suppressEvents) {\n      let c = {\n        action: 'create',\n        field: name\n      }\n      this.changelog.push(c)\n      this.emit('relationship.create', c)\n    }\n  }\n\n  /**\n   * @method applyModelMonitor\n   * Applies event handlers for bubbling model events.\n   * @param {string} field\n   * The relationship field name.\n   * @private\n   */\n  applyModelMonitor (name) {\n    const model = this.rawjoins[name]\n    const me = this\n\n    model.on('field.update', function (delta) {\n      let payload = {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.old,\n        new: delta.new,\n        join: true\n      }\n\n      me.emit('field.update', payload)\n      me.emit('field.update.' + name + '.' + delta.field, payload)\n    })\n\n    model.on('field.create', function (delta) {\n      let payload = {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: null,\n        new: null,\n        join: true\n      }\n\n      me.emit('field.update', payload)\n      me.emit('field.update.' + name + '.' + delta.field, payload)\n    })\n\n    model.on('field.remove', function (delta) {\n      let payload = {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.value,\n        new: null,\n        join: true\n      }\n\n      me.emit('field.update', payload)\n      me.emit('field.update.' + name + '.' + delta.field, payload)\n    })\n  }\n\n  /**\n   * @method applyStoreMonitor\n   * Applies event handlers for store data.\n   * @param {string} name\n   * Name of the raw join.\n   * @private\n   */\n  applyStoreMonitor (name) {\n    if (!this.rawjoins.hasOwnProperty(name)) {\n      return\n    }\n\n    if (this.rawjoins[name].hasOwnProperty('proxy')) {\n      const me = this\n\n      this.rawjoins[name].on('record.create', function (record) {\n        let old = me[name].data\n        old.pop()\n\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n\n        me.emit('field.update', c)\n        me.emit('field.update.' + name, c)\n      })\n\n      this.rawjoins[name].on('record.update', function (record, delta) {\n        if (!delta) {\n          return\n        }\n\n        let c = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          join: true,\n          old: delta.old,\n          new: delta.new\n        }\n\n        me.emit('field.update', c)\n        me.emit('field.update.' + name + '.' + delta.field, c)\n      })\n\n      this.rawjoins[name].on('record.delete', function (record) {\n        let old = me[name].data\n        old.push(record.data)\n\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n\n        me.emit('field.update', c)\n        me.emit('field.update.' + name, c)\n      })\n    }\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   */\n  removeField (name) {\n    if (this.raw.hasOwnProperty(name)) {\n      let val = this.raw[name]\n      delete this[name]\n      delete this.fields[name] // eslint-disable-line no-undef\n      delete this.raw[name] // eslint-disable-line no-undef\n      if (this.invalidDataAttributes.indexOf(name) >= 0) {\n        this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1)\n      }\n      let c = {\n        action: 'delete',\n        field: name,\n        value: val\n      }\n      this.emit('field.remove', c)\n      this.changelog.push(c)\n    }\n  }\n\n  /**\n   * @method removeVirtual\n   * Remove a virtual field.\n   * @param {string} name\n   * Name of the field.\n   */\n  removeVirtual (name) {\n    delete this[name]\n  }\n\n  /**\n   * @method removeRelationshipField\n   * Remove an existing join dynamically.\n   * @param {string} name\n   * The name of the relationship field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  removeRelationshipField (name, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    if (this.joins.hasOwnProperty(name)) {\n      let val = this.rawjoins[name]\n      delete this.rawjoins[name]\n      delete this[name]\n      delete this.joins[name]\n      if (!suppressEvents) {\n        let c = {\n          action: 'delete',\n          field: name,\n          old: val,\n          join: true\n        }\n        this.changelog.push(c)\n        this.emit('relationship.remove', c)\n      }\n    }\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog. It is possible to undo an undo (i.e. redo).\n   * This works with relationship creating/removing relationship fields,\n   * but not updates to the related model. To undo changes to a relationship\n   * field, the `undo()` method _of the related model_ must be called.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   */\n  undo (back) {\n    back = back || 1\n    let old = this.changelog.splice(this.changelog.length - back, back)\n    const me = this\n\n    old.reverse().forEach(function (change) {\n      if (!(typeof change.join === 'boolean' ? change.join : false)) {\n        switch (change.action) {\n          case 'update':\n            me[change.field] = change.old\n            break\n          case 'create':\n            me.removeField(change.field)\n            break\n          case 'delete':\n            me.addField(change.field)\n            me[change.field] = me.old\n            break\n        }\n      } else {\n        switch (change.action) {\n          case 'create':\n            me.removeRelationshipField(change.field)\n            break\n          case 'delete':\n            me.addRelationshipField(change.field)\n            me[change.field] = change.old\n            break\n        }\n      }\n    })\n  }\n\n  /**\n   * @method load\n   * Load a data record. This clears the #history. #modified\n   * will be set to `false`, as though the record has been untouched.\n   * @param {object} data\n   * The data to apply to the model.\n   */\n  load (data) {\n    data = data || {}\n\n    // Handle data maps\n    const me = this\n    if (this._dataMap !== null) {\n      Object.keys(this.reverseMap).forEach(function (key) {\n        if (data.hasOwnProperty(key)) {\n          data[me.reverseMap[key]] = data[key]\n          delete data[key]\n        }\n      })\n    }\n\n    // Loop through the keys and add data fields\n    Object.keys(data).forEach(function (key) {\n      if (me.fields.hasOwnProperty(key)) {\n        if (me.raw.hasOwnProperty(key)) {\n          me.raw[key] = data[key]\n        } else if (key === me.idAttribute) {\n          me.id = data[key]\n        }\n      } else if (me.joins.hasOwnProperty(key)) {\n        // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n        // tmp.load(data[key])\n        // me.rawjoin[key] = tmp\n        me.rawjoins[key].load(data[key])\n      } else {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + key + '%c specified as a data field but is not defined in the model.', NGN.css, '')\n        }\n      }\n    })\n\n    this.setUnmodified()\n  }\n}\n\nNGN.DATA = NGN.DATA || {}\n\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    const ModelLoader = function (data) {\n      let model = new Model(cfg)\n      if (data) {\n        model.load(data)\n      }\n      return model\n    }\n\n    return ModelLoader\n  }),\n\n  Entity: NGN.private(Model)\n})\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA\n}\n","'use strict';\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Model = function (_NGN$EventEmitter) {\n  _inherits(Model, _NGN$EventEmitter);\n\n  function Model(config) {\n    _classCallCheck(this, Model);\n\n    config = config || {};\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Model).call(this));\n\n    var me = _this;\n\n    Object.defineProperties(_this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields || {\n        id: {\n          required: true,\n          type: String,\n          'default': config.id || null\n        }\n      }),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[_this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @cfgproperty {Date|Number} [expires]\n       * When this is set to a date/time, the model record will be marked\n       * as expired at the specified time/date. If a number is specified\n       * (milliseconds), the record will be marked as expired after the\n       * specified time period has elapsed. When a record/model is marked as\n       * \"expired\", it triggers the `expired` event. By default, expired\n       * records/models within an NGN.DATA.Store will be removed from the store.\n       *\n       * Setting this to any value less than `0` disables expiration.\n       * @fires expired\n       * Triggered when the model/record expires.\n       */\n      expiration: NGN.private(null),\n\n      // Used to hold a setTimeout method for expiration events.\n      expirationTimeout: NGN.private(null),\n\n      // Placeholder expiration flag.\n      hasExpired: NGN.private(false),\n\n      // Used to prevent expiration of a record.\n      ignoreTTL: NGN.private(false),\n\n      /**\n       * @property {Number} created\n       * The date/time when the model is created. This is represented as\n       * the number of milliseconds since the epoch (Jan 1, 1970, 00:00:00 UTC).\n       * @private\n       */\n      createDate: NGN.privateconst(Date.now()),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum;\n        this.changelog = [];\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function min(minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse();\n          }\n\n          return false;\n        },\n\n        max: function max(maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse();\n          }\n\n          return false;\n        },\n\n        enum: function _enum(valid, value) {\n          return valid.indexOf(value) >= 0;\n        },\n\n        required: function required(field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null;\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    });\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    var allfields = _this.datafields.concat(_this.virtualdatafields).concat(_this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i;\n    });\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.');\n    }\n\n    // Make sure an ID reference is available.\n    if (!_this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      };\n    }\n\n    // Add fields\n    Object.keys(_this.fields).forEach(function (field) {\n      if (_typeof(me.fields[field]) !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        };\n      }\n      me.addField(field, true);\n    });\n\n    // Add virtuals\n    Object.keys(_this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me);\n      }));\n    });\n\n    // Add relationships\n    Object.keys(_this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true);\n    });\n\n    var events = ['field.update', 'field.create', 'field.remove', 'field.invalid', 'validator.add', 'validator.remove', 'relationship.create', 'relationship.remove', 'expired'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.push(me);\n          args.unshift(eventName);\n          NGN.BUS.emit.apply(NGN.BUS, args);\n        });\n      });\n    }\n\n    // If an expiration is defined, set it.\n    if (config.hasOwnProperty('expires')) {\n      _this.expires = config.expires;\n    }\n    return _this;\n  }\n\n  _createClass(Model, [{\n    key: 'expire',\n\n\n    /**\n     * @method expire\n     * Forcibly expire the model/record.\n     * @param {Date|Number} [duration]\n     * Optionally provide a new expiration time. This is an alternative\n     * way of setting #expires. If no value is specified, the record\n     * will immediately be marked as `expired`.\n     */\n    value: function expire(duration) {\n      if (this.expired) {\n        return;\n      }\n\n      if (duration) {\n        this.expires = duration;\n        return;\n      }\n\n      if (this.ignoreTTL) {\n        return;\n      }\n\n      // Force expiration.\n      this.hasExpired = true;\n\n      clearTimeout(this.expirationTimeout);\n\n      this.emit('expired', this);\n    }\n\n    /**\n     * @method disableExpiration\n     * Do not expire this model/record.\n     */\n\n  }, {\n    key: 'disableExpiration',\n    value: function disableExpiration() {\n      this.expires = -1;\n    }\n\n    /**\n      * @method addValidator\n      * Add or update a validation rule for a specific model property.\n      * @param {String} field\n      * The data field to test.\n      * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n      * The validation used to test the property value. This should return\n      * `true` when the data is valid and `false` when it is not.\n      *\n      * * When this is a _function_, the value is passed to it as an argument.\n      * * When this is a _String_, the value is compared for an exact match (case sensitive)\n      * * When this is a _Number_, the value is compared for equality.\n      * * When this is a _Date_, the value is compared for exact equality.\n      * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n      * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n      * * When this is _an array of dates_, the value is compared to each date for equality.\n      * @fires validator.add\n      */\n\n  }, {\n    key: 'addValidator',\n    value: function addValidator(property, validator) {\n      if (!this.hasOwnProperty(property)) {\n        console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '');\n        return;\n      }\n\n      switch (typeof validator === 'undefined' ? 'undefined' : _typeof(validator)) {\n        case 'function':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(validator);\n          this.emit('validator.add', property);\n          break;\n        case 'object':\n          if (Array.isArray(validator)) {\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.indexOf(value) >= 0;\n            });\n            this.emit('validator.add', property);\n          } else if (validator.test) {\n            // RegExp\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.test(value);\n            });\n            this.emit('validator.add', property);\n          } else {\n            console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n          }\n          break;\n        case 'string':\n        case 'number':\n        case 'date':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(function (value) {\n            return value === validator;\n          });\n          this.emit('validator.add', property);\n          break;\n        default:\n          console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n      }\n    }\n\n    /**\n      * @method removeValidator\n      * Remove a data validator from the object.\n      * @param {String} attribute\n      * The name of the attribute to remove from the validators.\n      * @fires validator.remove\n      */\n\n  }, {\n    key: 'removeValidator',\n    value: function removeValidator(attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        delete this.validators[attribute];\n        this.emit('validator.remove', attribute);\n      }\n    }\n\n    /**\n      * @method validate\n      * Validate one or all attributes of the data.\n      * @param {String} [attribute=null]\n      * Validate a specific attribute. By default, all attributes are tested.\n      * @private\n      * @returns {Boolean}\n      * Returns true or false based on the validity of data.\n      */\n\n  }, {\n    key: 'validate',\n    value: function validate(attribute) {\n      var me = this;\n\n      // Single Attribute Validation\n      if (attribute) {\n        if (this.validators.hasOwnProperty(attribute)) {\n          for (var i = 0; i < this.validators[attribute].length; i++) {\n            if (!me.validators[attribute][i](me[attribute])) {\n              me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute);\n              return false;\n            } else {\n              me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n                return attribute !== attr;\n              });\n            }\n          }\n\n          if (!this.validateDataType(attribute)) {\n            this.invalidDataAttributes.push(attribute);\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      // Validate data type of each attribute\n      this.datafields.forEach(function (field) {\n        me.validate(field);\n      });\n    }\n\n    /**\n     * @method validateDataType\n     * Indicates the data types match.\n     * @param {string} fieldname\n     * Name of the field whose data should be validated.\n     * @private\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'validateDataType',\n    value: function validateDataType(field) {\n      var fieldType = NGN.typeof(this[field]);\n      var expectedType = NGN.typeof(this.fields[field].type);\n\n      if (fieldType !== 'null') {\n        return fieldType === expectedType;\n      }\n\n      if (this[field] === null && this.fields[field].required) {\n        if (this.autoid && field === this.idAttribute) {\n          return true;\n        }\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * @method getRelationshipField\n     * Provides specific detail/configuration about a join/relationship.\n     * @param {String} fieldname\n     * The name of the field.\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'getRelationshipField',\n    value: function getRelationshipField(fieldname) {\n      return this.joins[fieldname];\n    }\n\n    /**\n     * @method hasRelationship\n     * Indicates a data join exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasRelationship',\n    value: function hasRelationship(fieldname) {\n      return this.joins.hasOwnProperty(fieldname);\n    }\n\n    /**\n       * @method getDataField\n       * Provides specific detail/configuration about a field.\n       * @param {String} fieldname\n       * The name of the data field.\n       * @returns {Object}\n       */\n\n  }, {\n    key: 'getDataField',\n    value: function getDataField(fieldname) {\n      return this.fields[fieldname];\n    }\n\n    /**\n     * @method hasDataField\n     * Indicates a data field exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasDataField',\n    value: function hasDataField(fieldname) {\n      return this.fields.hasOwnProperty(fieldname);\n    }\n\n    /**\n      * @method serialize\n      * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n      * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n      *\n      * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n      * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n      *\n      * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n      * The model itself can be returned using #getXRef.\n      * @param {Object} [obj]\n      * Defaults to this object.\n      * @protected\n      */\n\n  }, {\n    key: 'serialize',\n    value: function serialize(obj) {\n      var _obj = obj || this.raw;\n      var rtn = {};\n\n      for (var key in _obj) {\n        _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || '';\n        if (this.fields.hasOwnProperty(key)) {\n          key = key === 'id' ? this.idAttribute : key;\n          if (_obj.hasOwnProperty(key) && _obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)) || _obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0) {\n            var dsc = Object.getOwnPropertyDescriptor(_obj, key);\n            if (!dsc.set) {\n              // Handle everything else\n              switch (_typeof(dsc.value)) {\n                case 'function':\n                  // Support date & regex proxies\n                  if (dsc.value.name === 'Date') {\n                    rtn[key] = _obj[key].refs.toJSON();\n                  } else if (dsc.value.name === 'RegExp') {\n                    rtn[key] = dsc.value();\n                  }\n                  break;\n                case 'object':\n                  // Support array proxies\n                  if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                    _obj[key] = _obj[key].slice(0);\n                  }\n\n                  rtn[key] = _obj[key];\n                  break;\n                default:\n                  rtn[key] = _obj[key];\n                  break;\n              }\n            }\n          }\n        }\n      }\n\n      var me = this;\n      this.relationships.forEach(function (r) {\n        rtn[r] = me.rawjoins[r].data;\n      });\n\n      return rtn;\n    }\n\n    /**\n     * @method addField\n     * Add a data field after the initial model definition.\n     * @param {string} fieldname\n     * The name of the field.\n     * @param {object} [fieldConfiguration=null]\n     * The field configuration (see cfg#fields for syntax).\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addField',\n    value: function addField(field, fieldcfg, suppressEvents) {\n      if (typeof fieldcfg === 'boolean') {\n        suppressEvents = fieldcfg;\n        fieldcfg = null;\n      }\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      var me = this;\n      var cfg = null;\n      if (field.toLowerCase() !== 'id') {\n        if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object') {\n          if (!field.name) {\n            throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.');\n          }\n          cfg = field;\n          field = cfg.name;\n          delete cfg.name;\n        }\n\n        if (me[field] !== undefined) {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '');\n          }\n          delete me[field];\n        }\n\n        // Create the data field as an object attribute & getter/setter\n        me.fields[field] = cfg || me.fields[field] || {};\n        me.fields[field].required = NGN.coalesce(me.fields[field].required, false);\n\n        if (!me.fields[field].hasOwnProperty('type')) {\n          if (me.fields[field].hasOwnProperty('default')) {\n            var type = NGN.typeof(me.fields[field].default);\n            type = type.charAt(0).toUpperCase() + type.slice(1);\n            me.fields[field].type = eval(type);\n          }\n        }\n        me.fields[field].type = NGN.coalesce(me.fields[field].type, String);\n        if (field === me.idAttribute && me.autoid === true) {\n          me.fields[field].type = String;\n          me.fields[field]['default'] = NGN.DATA.util.GUID();\n        } else {\n          me.fields[field]['default'] = me.fields[field]['default'] || null;\n        }\n        me.raw[field] = me.fields[field]['default'];\n        me[field] = me.raw[field];\n\n        Object.defineProperty(me, field, {\n          get: function get() {\n            return me.raw[field];\n          },\n          set: function set(value) {\n            var old = me.raw[field];\n            me.raw[field] = value;\n            var c = {\n              action: 'update',\n              field: field,\n              old: old,\n              new: me.raw[field]\n            };\n            this.changelog.push(c);\n            this.emit('field.update', c);\n            this.emit('field.update.' + field, c);\n            if (!me.validate(field)) {\n              me.emit('field.invalid', {\n                field: field\n              });\n            }\n          }\n        });\n\n        if (!suppressEvents) {\n          var c = {\n            action: 'create',\n            field: field\n          };\n          this.changelog.push(c);\n          this.emit('field.create', c);\n        }\n\n        // Add field validators\n        if (me.fields.hasOwnProperty(field)) {\n          if (me.fields[field].hasOwnProperty('pattern')) {\n            me.addValidator(field, me.fields[field].pattern);\n          }\n          ['min', 'max', 'enum'].forEach(function (v) {\n            if (me.fields[field].hasOwnProperty(v)) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators[v](me.fields[field][v], val);\n              });\n            }\n          });\n          if (me.fields[field].hasOwnProperty('required')) {\n            if (me.fields[field].required) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators.required(field, val);\n              });\n            }\n          }\n          if (me.fields[field].hasOwnProperty('validate')) {\n            if (typeof me.fields[field] === 'function') {\n              me.addValidator(field, function (val) {\n                return me.fields[field](val);\n              });\n            } else {\n              var _source = NGN.stack.pop();\n              console.warn('Invalid custom validation function (in %c' + _source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '');\n            }\n          }\n        }\n      } else if (me.id === null && me.autoid) {\n        me.id = NGN.DATA.util.GUID();\n      }\n    }\n\n    /**\n     * @method addVirtual\n     * Add a virtual field dynamically.\n     * @param {string} name\n     * The name of the attribute to add.\n     * @param {function} handler\n     * The synchronous method (or generator) that produces\n     * the desired output.\n     */\n\n  }, {\n    key: 'addVirtual',\n    value: function addVirtual(name, fn) {\n      var me = this;\n      Object.defineProperty(this, name, {\n        get: function get() {\n          return fn.apply(me);\n        }\n      });\n    }\n\n    /**\n     * @method addRelationshipField\n     * Join another model dynamically.\n     * @param {string} name\n     * The name of the field to add.\n     * @param {Object|NGN.DATA.Model} config\n     * The configuration or data model type. This follows the same syntax\n     * defined in the #joins attribute.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addRelationshipField',\n    value: function addRelationshipField(name, cfg, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n\n      if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n        throw new Error(name + ' already exists. It cannot be added to the model again.');\n      }\n\n      if (typeof cfg === 'function' || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object' && !cfg.hasOwnProperty('type')) {\n        cfg = {\n          type: cfg\n        };\n      }\n\n      if (!cfg.type) {\n        throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.');\n      }\n\n      cfg.required = NGN.coalesce(cfg.required, true);\n      cfg.default = cfg.default || null;\n\n      var me = this;\n      var entityType = 'model';\n      if (cfg.type instanceof NGN.DATA.Store) {\n        entityType = 'store';\n      } else if (NGN.typeof(cfg.type) === 'array') {\n        if (cfg.type.length === 0) {\n          throw new Error(name + ' cannot be an empty store. A model must be provided.');\n        }\n        entityType = 'collection';\n      } else if (_typeof(cfg.type) === 'object') {\n        if (cfg.type.model) {\n          entityType = 'store';\n        }\n      }\n\n      if (entityType === 'store') {\n        var storeCfg = {};\n        if (cfg.type instanceof NGN.DATA.Store) {\n          this.rawjoins[name] = cfg.type;\n          storeCfg = null;\n        } else if (cfg.type.model) {\n          storeCfg = cfg.type;\n        } else {\n          throw new Error('Nested store configuration is invalid or was not recognized.');\n        }\n\n        if (storeCfg !== null) {\n          this.rawjoins[name] = new NGN.DATA.Store(storeCfg);\n        }\n        this.applyStoreMonitor(name);\n      } else if (entityType === 'collection') {\n        this.rawjoins[name] = new NGN.DATA.Store({\n          model: cfg.type[0]\n        });\n        this.applyStoreMonitor(name);\n      } else if (!cfg.type.data) {\n        this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type(); // eslint-disable-line new-cap\n        this.applyModelMonitor(name);\n      } else if (cfg.type.data) {\n        this.rawjoins[name] = cfg.type;\n        this.applyStoreMonitor(name);\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.');\n      }\n\n      Object.defineProperty(this, name, {\n        enumerable: true,\n        get: function get() {\n          return me.rawjoins[name];\n        }\n      });\n\n      if (!suppressEvents) {\n        var c = {\n          action: 'create',\n          field: name\n        };\n        this.changelog.push(c);\n        this.emit('relationship.create', c);\n      }\n    }\n\n    /**\n     * @method applyModelMonitor\n     * Applies event handlers for bubbling model events.\n     * @param {string} field\n     * The relationship field name.\n     * @private\n     */\n\n  }, {\n    key: 'applyModelMonitor',\n    value: function applyModelMonitor(name) {\n      var model = this.rawjoins[name];\n      var me = this;\n\n      model.on('field.update', function (delta) {\n        var payload = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.old,\n          new: delta.new,\n          join: true\n        };\n\n        me.emit('field.update', payload);\n        me.emit('field.update.' + name + '.' + delta.field, payload);\n      });\n\n      model.on('field.create', function (delta) {\n        var payload = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: null,\n          new: null,\n          join: true\n        };\n\n        me.emit('field.update', payload);\n        me.emit('field.update.' + name + '.' + delta.field, payload);\n      });\n\n      model.on('field.remove', function (delta) {\n        var payload = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.value,\n          new: null,\n          join: true\n        };\n\n        me.emit('field.update', payload);\n        me.emit('field.update.' + name + '.' + delta.field, payload);\n      });\n    }\n\n    /**\n     * @method applyStoreMonitor\n     * Applies event handlers for store data.\n     * @param {string} name\n     * Name of the raw join.\n     * @private\n     */\n\n  }, {\n    key: 'applyStoreMonitor',\n    value: function applyStoreMonitor(name) {\n      var _this2 = this;\n\n      if (!this.rawjoins.hasOwnProperty(name)) {\n        return;\n      }\n\n      if (this.rawjoins[name].hasOwnProperty('proxy')) {\n        (function () {\n          var me = _this2;\n\n          _this2.rawjoins[name].on('record.create', function (record) {\n            var old = me[name].data;\n            old.pop();\n\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n\n            me.emit('field.update', c);\n            me.emit('field.update.' + name, c);\n          });\n\n          _this2.rawjoins[name].on('record.update', function (record, delta) {\n            if (!delta) {\n              return;\n            }\n\n            var c = {\n              action: 'update',\n              field: name + '.' + delta.field,\n              join: true,\n              old: delta.old,\n              new: delta.new\n            };\n\n            me.emit('field.update', c);\n            me.emit('field.update.' + name + '.' + delta.field, c);\n          });\n\n          _this2.rawjoins[name].on('record.delete', function (record) {\n            var old = me[name].data;\n            old.push(record.data);\n\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n\n            me.emit('field.update', c);\n            me.emit('field.update.' + name, c);\n          });\n        })();\n      }\n    }\n\n    /**\n     * @method removeField\n     * Remove a field from the data model.\n     * @param {string} name\n     * Name of the field to remove.\n     */\n\n  }, {\n    key: 'removeField',\n    value: function removeField(name) {\n      if (this.raw.hasOwnProperty(name)) {\n        var val = this.raw[name];\n        delete this[name];\n        delete this.fields[name]; // eslint-disable-line no-undef\n        delete this.raw[name]; // eslint-disable-line no-undef\n        if (this.invalidDataAttributes.indexOf(name) >= 0) {\n          this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1);\n        }\n        var c = {\n          action: 'delete',\n          field: name,\n          value: val\n        };\n        this.emit('field.remove', c);\n        this.changelog.push(c);\n      }\n    }\n\n    /**\n     * @method removeVirtual\n     * Remove a virtual field.\n     * @param {string} name\n     * Name of the field.\n     */\n\n  }, {\n    key: 'removeVirtual',\n    value: function removeVirtual(name) {\n      delete this[name];\n    }\n\n    /**\n     * @method removeRelationshipField\n     * Remove an existing join dynamically.\n     * @param {string} name\n     * The name of the relationship field to remove.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'removeRelationshipField',\n    value: function removeRelationshipField(name, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      if (this.joins.hasOwnProperty(name)) {\n        var val = this.rawjoins[name];\n        delete this.rawjoins[name];\n        delete this[name];\n        delete this.joins[name];\n        if (!suppressEvents) {\n          var c = {\n            action: 'delete',\n            field: name,\n            old: val,\n            join: true\n          };\n          this.changelog.push(c);\n          this.emit('relationship.remove', c);\n        }\n      }\n    }\n\n    /**\n     * @method undo\n     * A rollback function to undo changes. This operation affects\n     * the changelog. It is possible to undo an undo (i.e. redo).\n     * This works with relationship creating/removing relationship fields,\n     * but not updates to the related model. To undo changes to a relationship\n     * field, the `undo()` method _of the related model_ must be called.\n     * @param {number} [OperationCount=1]\n     * The number of operations to \"undo\". Defaults to a single operation.\n     */\n\n  }, {\n    key: 'undo',\n    value: function undo(back) {\n      back = back || 1;\n      var old = this.changelog.splice(this.changelog.length - back, back);\n      var me = this;\n\n      old.reverse().forEach(function (change) {\n        if (!(typeof change.join === 'boolean' ? change.join : false)) {\n          switch (change.action) {\n            case 'update':\n              me[change.field] = change.old;\n              break;\n            case 'create':\n              me.removeField(change.field);\n              break;\n            case 'delete':\n              me.addField(change.field);\n              me[change.field] = me.old;\n              break;\n          }\n        } else {\n          switch (change.action) {\n            case 'create':\n              me.removeRelationshipField(change.field);\n              break;\n            case 'delete':\n              me.addRelationshipField(change.field);\n              me[change.field] = change.old;\n              break;\n          }\n        }\n      });\n    }\n\n    /**\n     * @method load\n     * Load a data record. This clears the #history. #modified\n     * will be set to `false`, as though the record has been untouched.\n     * @param {object} data\n     * The data to apply to the model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load(data) {\n      data = data || {};\n\n      // Handle data maps\n      var me = this;\n      if (this._dataMap !== null) {\n        Object.keys(this.reverseMap).forEach(function (key) {\n          if (data.hasOwnProperty(key)) {\n            data[me.reverseMap[key]] = data[key];\n            delete data[key];\n          }\n        });\n      }\n\n      // Loop through the keys and add data fields\n      Object.keys(data).forEach(function (key) {\n        if (me.fields.hasOwnProperty(key)) {\n          if (me.raw.hasOwnProperty(key)) {\n            me.raw[key] = data[key];\n          } else if (key === me.idAttribute) {\n            me.id = data[key];\n          }\n        } else if (me.joins.hasOwnProperty(key)) {\n          // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n          // tmp.load(data[key])\n          // me.rawjoin[key] = tmp\n          me.rawjoins[key].load(data[key]);\n        } else {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + key + '%c specified as a data field but is not defined in the model.', NGN.css, '');\n          }\n        }\n      });\n\n      this.setUnmodified();\n    }\n  }, {\n    key: 'expires',\n    get: function get() {\n      return this.expiration;\n    },\n    set: function set(value) {\n      var _this3 = this;\n\n      // Validate data type\n      if (NGN.typeof(value) !== 'date' && NGN.typeof(value) !== 'number') {\n        try {\n          var source = NGN.stack.pop();\n          console.warn('Expiration could not be set at %c' + source.path + '%c (Invalid data type. Must be a Date or number).', NGN.css, '');\n        } catch (e) {\n          console.warn('Expiration could not be set (Invalid data type. Must be a Date or number).');\n        }\n\n        return;\n      }\n\n      // Clear existing expiration timer if it is already set.\n      clearTimeout(this.expirationTimeout);\n\n      // If the new value is a number, convert to a date.\n      if (NGN.typeof(value) === 'number') {\n        if (value < 0) {\n          this.ignoreTTL = true;\n          return;\n        }\n\n        var currentDate = new Date();\n\n        value = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds() + value);\n      }\n\n      // If the process has reached this far, expiration\n      // actions should be enabled.\n      this.ignoreTTL = false;\n\n      // Set the new expiration time period\n      this.expiration = value;\n\n      // If the record is already expired, immediately trigger the expiration.\n      if (Date.now() >= this.expiration.getTime()) {\n        this.expire();\n        return;\n      }\n\n      this.hasExpired = false;\n\n      // If the expiration is in the future, set a timer to expire.\n      var waitPeriod = this.expiration.getTime() - Date.now();\n      this.expirationTimeout = setTimeout(function () {\n        _this3.expire();\n      }, waitPeriod);\n    }\n\n    /**\n     * @property {boolean} expired\n     * Indicates the record/model is expired.\n     */\n\n  }, {\n    key: 'expired',\n    get: function get() {\n      if (this.ignoreTTL) {\n        return false;\n      }\n\n      return this.hasExpired;\n    }\n\n    /**\n     * @property {Boolean}\n     * Indicates one or more data properties has changed.\n     * @readonly\n     */\n\n  }, {\n    key: 'modified',\n    get: function get() {\n      return this.checksum !== this.benchmark;\n    }\n\n    /**\n     * @cfgproperty {String/Number/Date} [id=null]\n     * The unique ID of the model object. If #idAttribute is defined,\n     * this will get/set the #idAttribute value.\n     */\n\n  }, {\n    key: 'id',\n    get: function get() {\n      return this.oid;\n    },\n    set: function set(value) {\n      this.oid = value;\n    }\n\n    /**\n     * @property checksum\n     * The unique checksum of the record (i.e. a record fingerprint).\n     * This will change as the data changes.\n     */\n\n  }, {\n    key: 'checksum',\n    get: function get() {\n      return NGN.DATA.util.checksum(JSON.stringify(this.data));\n    }\n\n    /**\n     * @property {Object} dataMap\n     * The current data map.\n     * @private\n     */\n\n  }, {\n    key: 'dataMap',\n    get: function get() {\n      return this._dataMap;\n    },\n    set: function set(value) {\n      this._dataMap = value;\n      this._reverseDataMap = null;\n    }\n\n    /**\n     * @property {NGN.DATA.Store} store\n     * If a store is associated with the model, this will\n     * provide a reference to it. If there is no store, this\n     * will return `null`.\n     */\n\n  }, {\n    key: 'datastore',\n    get: function get() {\n      return this._store;\n    }\n\n    /**\n     * @property {boolean} valid\n     * Indicates the record is valid.\n     */\n\n  }, {\n    key: 'valid',\n    get: function get() {\n      this.validate();\n      return this.invalidDataAttributes.length === 0;\n    }\n\n    /**\n     * @property datafields\n     * Provides an array of data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'datafields',\n    get: function get() {\n      return Object.keys(this.fields);\n    }\n\n    /**\n     * @property reslationships\n     * Provides an array of join fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'relationships',\n    get: function get() {\n      return Object.keys(this.joins);\n    }\n\n    /**\n     * @property virtualdatafields\n     * Provides an array of virtual data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'virtualdatafields',\n    get: function get() {\n      return Object.keys(this.virtuals);\n    }\n\n    /**\n     * @property {object} reverseMap\n     * Reverses the data map. For example, if the original #dataMap\n     * looks like:\n     *\n     * ```js\n     * {\n     *    firstname: 'gn',\n     *    lastname: 'sn\n     * }\n     * ```\n     *\n     * The reverse map will look like:\n     *\n     * ```js\n     * {\n     *    gn: 'firstname',\n     *    sn: 'lastname\n     * }\n     * ```\n     */\n\n  }, {\n    key: 'reverseMap',\n    get: function get() {\n      var _this4 = this;\n\n      if (this.dataMap !== null) {\n        var _ret2 = function () {\n          if (_this4._reverseDataMap !== null) {\n            return {\n              v: _this4._reverseDataMap\n            };\n          }\n          var rmap = {};\n          var me = _this4;\n          Object.keys(_this4._dataMap).forEach(function (attr) {\n            rmap[me._dataMap[attr]] = attr;\n          });\n          _this4._reverseDataMap = rmap;\n          return {\n            v: rmap\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      }\n      return null;\n    }\n\n    /**\n      * @property data\n      * Creates a JSON representation of the data entity. This is\n      * a record that can be persisted to a database or other data store.\n      * @readonly.\n      */\n\n  }, {\n    key: 'data',\n    get: function get() {\n      var _this5 = this;\n\n      var d = this.serialize();\n      if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n        d[this.idAttribute] = this[this.idAttribute];\n      }\n      if (this.dataMap) {\n        (function () {\n          var me = _this5;\n          // Loop through the map keys\n          Object.keys(_this5.dataMap).forEach(function (key) {\n            // If the node contains key, make the mapping\n            if (d.hasOwnProperty(key)) {\n              if (d[key] instanceof NGN.DATA.Model) {\n                d[me.dataMap[key]] = d[key].data;\n              } else {\n                d[me.dataMap[key]] = d[key];\n              }\n              delete d[key];\n            }\n          });\n        })();\n      }\n      return d;\n    }\n\n    /**\n     * @property history\n     * The history of the entity (i.e. changelog).The history\n     * is shown from most recent to oldest change. Keep in mind that\n     * some actions, such as adding new custom fields on the fly, may\n     * be triggered before other updates.\n     * @returns {array}\n     */\n\n  }, {\n    key: 'history',\n    get: function get() {\n      return this.changelog.reverse();\n    }\n  }]);\n\n  return Model;\n}(NGN.EventEmitter);\n\nNGN.DATA = NGN.DATA || {};\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    var ModelLoader = function ModelLoader(data) {\n      var model = new Model(cfg);\n      if (data) {\n        model.load(data);\n      }\n      return model;\n    };\n\n    return ModelLoader;\n  }),\n\n  Entity: NGN.private(Model)\n});\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA;\n}"],"sourceRoot":"/source/"}