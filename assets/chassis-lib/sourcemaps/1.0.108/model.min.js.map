{"version":3,"sources":["model.js","model.min.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","call","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","_typeof","Symbol","iterator","obj","_createClass","defineProperties","target","props","i","length","descriptor","defineProperty","key","protoProps","staticProps","Model","_NGN$EventEmitter","config","this","_this","getPrototypeOf","me","idAttribute","NGN","privateconst","fields","id","required","type","String","default","joins","relationships","virtuals","validators","validation","coalesce","isNew","isDestroyed","oid","autoid","benchmark","expiration","expirationTimeout","ignoreTTL","createDate","Date","now","setUnmodified","checksum","changelog","allowInvalidSave","disableDataValidation","invalidDataAttributes","initialDataAttributes","_nativeValidators","min","minimum","trim","parse","max","maximum","enum","valid","indexOf","field","hasOwnProperty","_dataMap","dataMap","_reverseDataMap","raw","rawjoins","_store","allfields","datafields","concat","virtualdatafields","filter","a","Error","join","keys","forEach","name","addField","v","get","apply","addRelationshipField","events","BUS","eventName","on","args","slice","arguments","push","unshift","emit","expires","duration","expired","clearTimeout","property","validator","console","warn","css","Array","isArray","test","attribute","attr","validateDataType","validate","fieldType","expectedType","fieldname","_obj","rtn","nonEnumerableProperties","substr","undefined","enumerableProperties","dsc","getOwnPropertyDescriptor","set","refs","toJSON","r","data","fieldcfg","suppressEvents","cfg","toLowerCase","source","stack","pop","path","e","charAt","toUpperCase","eval","DATA","util","GUID","old","c","action","new","addValidator","pattern","val","_source","fn","entityType","Store","model","storeCfg","applyStoreMonitor","applyModelMonitor","delta","_this2","record","splice","back","reverse","change","removeRelationshipField","removeField","reverseMap","load","_this3","currentDate","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","expire","waitPeriod","getTime","setTimeout","JSON","stringify","_this4","_ret2","rmap","_this5","d","serialize","EventEmitter","ModelLoader","Entity","nodelike","module","exports"],"mappings":"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","file":"model.min.js","sourcesContent":["'use strict'\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nclass Model extends NGN.EventEmitter {\n  constructor (config) {\n    config = config || {}\n\n    super()\n\n    const me = this\n\n    Object.defineProperties(this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields ||\n        {\n          id: {\n            required: true,\n            type: String,\n            'default': config.id || null\n          }\n        }\n      ),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @cfgproperty {Date|Number} [expires]\n       * When this is set to a date/time, the model record will be marked\n       * as expired at the specified time/date. If a number is specified\n       * (milliseconds), the record will be marked as expired after the\n       * specified time period has elapsed. When a record/model is marked as\n       * \"expired\", it triggers the `expired` event. By default, expired\n       * records/models within an NGN.DATA.Store will be removed from the store.\n       *\n       * Setting this to any value less than `0` disables expiration.\n       * @fires expired\n       * Triggered when the model/record expires.\n       */\n      expiration: NGN.private(null),\n\n      // Used to hold a setTimeout method for expiration events.\n      expirationTimeout: NGN.private(null),\n\n      // Used to prevent expiration of a record.\n      ignoreTTL: NGN.private(false),\n\n      /**\n       * @property {Number} created\n       * The date/time when the model is created. This is represented as\n       * the number of milliseconds since the epoch (Jan 1, 1970, 00:00:00 UTC).\n       * @private\n       */\n      createDate: NGN.privateconst(Date.now()),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum\n        this.changelog = []\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function (minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse()\n          }\n\n          return false\n        },\n\n        max: function (maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse()\n          }\n\n          return false\n        },\n\n        enum: function (valid, value) {\n          return valid.indexOf(value) >= 0\n        },\n\n        required: function (field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    })\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    let allfields = this.datafields.concat(this.virtualdatafields).concat(this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i\n    })\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.')\n    }\n\n    // Make sure an ID reference is available.\n    if (!this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      }\n    }\n\n    // Add fields\n    Object.keys(this.fields).forEach(function (field) {\n      if (typeof me.fields[field] !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        }\n      }\n      me.addField(field, true)\n    })\n\n    // Add virtuals\n    Object.keys(this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me)\n      }))\n    })\n\n    // Add relationships\n    Object.keys(this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true)\n    })\n\n    let events = [\n      'field.update',\n      'field.create',\n      'field.remove',\n      'field.invalid',\n      'validator.add',\n      'validator.remove',\n      'relationship.create',\n      'relationship.remove',\n      'expired'\n    ]\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          let args = NGN.slice(arguments)\n          args.push(me)\n          args.unshift(eventName)\n          NGN.BUS.emit.apply(NGN.BUS, args)\n        })\n      })\n    }\n\n    // If an expiration is defined, set it.\n    if (config.hasOwnProperty('expires')) {\n      this.expires = config.expires\n    }\n  }\n\n  get expires () {\n    return this.expiration\n  }\n\n  set expires (value) {\n    // Validate data type\n    if (NGN.typeof(value) !== 'date' && NGN.typeof(value) !== 'number') {\n      try {\n        const source = NGN.stack.pop()\n        console.warn('Expiration could not be set at %c' + source.path + '%c (Invalid data type. Must be a Date or number).', NGN.css, '')\n      } catch (e) {\n        console.warn('Expiration could not be set (Invalid data type. Must be a Date or number).')\n      }\n\n      return\n    }\n\n    // Clear existing expiration timer if it is already set.\n    clearTimeout(this.expirationTimeout)\n\n    // If the new value is a number, convert to a date.\n    if (NGN.typeof(value) === 'number') {\n      if (value < 0) {\n        this.ignoreTTL = true\n        return\n      }\n\n      const currentDate = new Date()\n\n      value = new Date (\n        currentDate.getFullYear(),\n        currentDate.getMonth(),\n        currentDate.getDate(),\n        currentDate.getHours(),\n        currentDate.getMinutes(),\n        currentDate.getSeconds(),\n        currentDate.getMilliseconds() + value\n      )\n    }\n\n    // If the process has reached this far, expiration\n    // actions should be enabled.\n    this.ignoreTTL = false\n\n    // Set the new expiration time period\n    this.expiration = value\n\n    // If the record is already expired, immediately trigger the expiration.\n    if (this.expired) {\n      this.expire()\n      return\n    }\n\n    // If the expiration is in the future, set a timer to expire.\n    let waitPeriod = this.expiration.getTime() - Date.now()\n    this.expirationTimeout = setTimeout(() => {\n      this.expire()\n    }, waitPeriod)\n  }\n\n  /**\n   * @property {boolean} expired\n   * Indicates the record/model is expired.\n   */\n  get expired () {\n    if (this.ignoreTTL) {\n      return false\n    }\n\n    return Date.now() >= this.expires.getTime()\n  }\n\n  /**\n   * @property {Boolean}\n   * Indicates one or more data properties has changed.\n   * @readonly\n   */\n  get modified () {\n    return this.checksum !== this.benchmark\n  }\n\n  /**\n   * @cfgproperty {String/Number/Date} [id=null]\n   * The unique ID of the model object. If #idAttribute is defined,\n   * this will get/set the #idAttribute value.\n   */\n  get id () {\n    return this.oid\n  }\n\n  set id (value) {\n    this.oid = value\n  }\n\n  /**\n   * @property checksum\n   * The unique checksum of the record (i.e. a record fingerprint).\n   * This will change as the data changes.\n   */\n  get checksum () {\n    return NGN.DATA.util.checksum(JSON.stringify(this.data))\n  }\n\n  /**\n   * @property {Object} dataMap\n   * The current data map.\n   * @private\n   */\n  get dataMap () {\n    return this._dataMap\n  }\n\n  set dataMap (value) {\n    this._dataMap = value\n    this._reverseDataMap = null\n  }\n\n  /**\n   * @property {NGN.DATA.Store} store\n   * If a store is associated with the model, this will\n   * provide a reference to it. If there is no store, this\n   * will return `null`.\n   */\n  get datastore () {\n    return this._store\n  }\n\n  /**\n   * @property {boolean} valid\n   * Indicates the record is valid.\n   */\n  get valid () {\n    this.validate()\n    return this.invalidDataAttributes.length === 0\n  }\n\n  /**\n   * @property datafields\n   * Provides an array of data fields associated with the model.\n   * @returns {String[]}\n   */\n  get datafields () {\n    return Object.keys(this.fields)\n  }\n\n  /**\n   * @property reslationships\n   * Provides an array of join fields associated with the model.\n   * @returns {String[]}\n   */\n  get relationships () {\n    return Object.keys(this.joins)\n  }\n\n  /**\n   * @property virtualdatafields\n   * Provides an array of virtual data fields associated with the model.\n   * @returns {String[]}\n   */\n  get virtualdatafields () {\n    return Object.keys(this.virtuals)\n  }\n\n  /**\n   * @property {object} reverseMap\n   * Reverses the data map. For example, if the original #dataMap\n   * looks like:\n   *\n   * ```js\n   * {\n   *    firstname: 'gn',\n   *    lastname: 'sn\n   * }\n   * ```\n   *\n   * The reverse map will look like:\n   *\n   * ```js\n   * {\n   *    gn: 'firstname',\n   *    sn: 'lastname\n   * }\n   * ```\n   */\n  get reverseMap () {\n    if (this.dataMap !== null) {\n      if (this._reverseDataMap !== null) {\n        return this._reverseDataMap\n      }\n      let rmap = {}\n      const me = this\n      Object.keys(this._dataMap).forEach(function (attr) {\n        rmap[me._dataMap[attr]] = attr\n      })\n      this._reverseDataMap = rmap\n      return rmap\n    }\n    return null\n  }\n\n  /**\n    * @property data\n    * Creates a JSON representation of the data entity. This is\n    * a record that can be persisted to a database or other data store.\n    * @readonly.\n    */\n  get data () {\n    let d = this.serialize()\n    if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n      d[this.idAttribute] = this[this.idAttribute]\n    }\n    if (this.dataMap) {\n      const me = this\n      // Loop through the map keys\n      Object.keys(this.dataMap).forEach(function (key) {\n        // If the node contains key, make the mapping\n        if (d.hasOwnProperty(key)) {\n          if (d[key] instanceof NGN.DATA.Model) {\n            d[me.dataMap[key]] = d[key].data\n          } else {\n            d[me.dataMap[key]] = d[key]\n          }\n          delete d[key]\n        }\n      })\n    }\n    return d\n  }\n\n  /**\n   * @property history\n   * The history of the entity (i.e. changelog).The history\n   * is shown from most recent to oldest change. Keep in mind that\n   * some actions, such as adding new custom fields on the fly, may\n   * be triggered before other updates.\n   * @returns {array}\n   */\n  get history () {\n    return this.changelog.reverse()\n  }\n\n  /**\n   * @method expire\n   * Forcibly expire the model/record.\n   * @param {Date|Number} [duration]\n   * Optionally provide a new expiration time. This is an alternative\n   * way of setting #expires. If no value is specified, the record\n   * will immediately be marked as `expired`.\n   */\n  expire (duration) {\n    if (duration) {\n      this.expires = duration\n      return\n    }\n\n    if (this.ignoreTTL) {\n      return\n    }\n\n    // Force expiration.\n    if (!this.expired) {\n      this.expiration = new Date()\n    }\n\n    clearTimeout(this.expirationTimeout)\n\n    this.emit('expired', this)\n  }\n\n  /**\n   * @method disableExpiration\n   * Do not expire this model/record.\n   */\n  disableExpiration () {\n    this.expires = -1\n  }\n\n  /**\n    * @method addValidator\n    * Add or update a validation rule for a specific model property.\n    * @param {String} field\n    * The data field to test.\n    * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n    * The validation used to test the property value. This should return\n    * `true` when the data is valid and `false` when it is not.\n    *\n    * * When this is a _function_, the value is passed to it as an argument.\n    * * When this is a _String_, the value is compared for an exact match (case sensitive)\n    * * When this is a _Number_, the value is compared for equality.\n    * * When this is a _Date_, the value is compared for exact equality.\n    * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n    * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n    * * When this is _an array of dates_, the value is compared to each date for equality.\n    * @fires validator.add\n    */\n  addValidator (property, validator) {\n    if (!this.hasOwnProperty(property)) {\n      console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '')\n      return\n    }\n\n    switch (typeof validator) {\n      case 'function':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(validator)\n        this.emit('validator.add', property)\n        break\n      case 'object':\n        if (Array.isArray(validator)) {\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.indexOf(value) >= 0\n          })\n          this.emit('validator.add', property)\n        } else if (validator.test) { // RegExp\n          this.validators[property] = this.validators[property] || []\n          this.validators[property].push(function (value) {\n            return validator.test(value)\n          })\n          this.emit('validator.add', property)\n        } else {\n          console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n        }\n        break\n      case 'string':\n      case 'number':\n      case 'date':\n        this.validators[property] = this.validators[property] || []\n        this.validators[property].push(function (value) {\n          return value === validator\n        })\n        this.emit('validator.add', property)\n        break\n      default:\n        console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '')\n    }\n  }\n\n  /**\n    * @method removeValidator\n    * Remove a data validator from the object.\n    * @param {String} attribute\n    * The name of the attribute to remove from the validators.\n    * @fires validator.remove\n    */\n  removeValidator (attribute) {\n    if (this.validators.hasOwnProperty(attribute)) {\n      delete this.validators[attribute]\n      this.emit('validator.remove', attribute)\n    }\n  }\n\n  /**\n    * @method validate\n    * Validate one or all attributes of the data.\n    * @param {String} [attribute=null]\n    * Validate a specific attribute. By default, all attributes are tested.\n    * @private\n    * @returns {Boolean}\n    * Returns true or false based on the validity of data.\n    */\n  validate (attribute) {\n    const me = this\n\n    // Single Attribute Validation\n    if (attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        for (let i = 0; i < this.validators[attribute].length; i++) {\n          if (!me.validators[attribute][i](me[attribute])) {\n            me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute)\n            return false\n          } else {\n            me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n              return attribute !== attr\n            })\n          }\n        }\n\n        if (!this.validateDataType(attribute)) {\n          this.invalidDataAttributes.push(attribute)\n          return false\n        }\n      }\n\n      return true\n    }\n\n    // Validate data type of each attribute\n    this.datafields.forEach(function (field) {\n      me.validate(field)\n    })\n  }\n\n  /**\n   * @method validateDataType\n   * Indicates the data types match.\n   * @param {string} fieldname\n   * Name of the field whose data should be validated.\n   * @private\n   * @return {boolean}\n   */\n  validateDataType (field) {\n    const fieldType = NGN.typeof(this[field])\n    const expectedType = NGN.typeof(this.fields[field].type)\n\n    if (fieldType !== 'null') {\n      return fieldType === expectedType\n    }\n\n    if (this[field] === null && this.fields[field].required) {\n      if (this.autoid && field === this.idAttribute) {\n        return true\n      }\n      return false\n    }\n\n    return true\n  }\n\n  /**\n   * @method getRelationshipField\n   * Provides specific detail/configuration about a join/relationship.\n   * @param {String} fieldname\n   * The name of the field.\n   * @returns {Object}\n   */\n  getRelationshipField (fieldname) {\n    return this.joins[fieldname]\n  }\n\n  /**\n   * @method hasRelationship\n   * Indicates a data join exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasRelationship (fieldname) {\n    return this.joins.hasOwnProperty(fieldname)\n  }\n\n  /**\n     * @method getDataField\n     * Provides specific detail/configuration about a field.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Object}\n     */\n  getDataField (fieldname) {\n    return this.fields[fieldname]\n  }\n\n  /**\n   * @method hasDataField\n   * Indicates a data field exists.\n   * @param {String} fieldname\n   * The name of the data field.\n   * @returns {Boolean}\n   */\n  hasDataField (fieldname) {\n    return this.fields.hasOwnProperty(fieldname)\n  }\n\n  /**\n    * @method serialize\n    * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n    * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n    *\n    * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n    * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n    *\n    * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n    * The model itself can be returned using #getXRef.\n    * @param {Object} [obj]\n    * Defaults to this object.\n    * @protected\n    */\n  serialize (obj) {\n    let _obj = obj || this.raw\n    let rtn = {}\n\n    for (let key in _obj) {\n      _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || ''\n      if (this.fields.hasOwnProperty(key)) {\n        key = key === 'id' ? this.idAttribute : key\n        if ((_obj.hasOwnProperty(key) && (_obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)))) || (_obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0)) {\n          let dsc = Object.getOwnPropertyDescriptor(_obj, key)\n          if (!dsc.set) {\n            // Handle everything else\n            switch (typeof dsc.value) {\n              case 'function':\n                // Support date & regex proxies\n                if (dsc.value.name === 'Date') {\n                  rtn[key] = _obj[key].refs.toJSON()\n                } else if (dsc.value.name === 'RegExp') {\n                  rtn[key] = dsc.value()\n                }\n                break\n              case 'object':\n                // Support array proxies\n                if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                  _obj[key] = _obj[key].slice(0)\n                }\n\n                rtn[key] = _obj[key]\n                break\n              default:\n                rtn[key] = _obj[key]\n                break\n            }\n          }\n        }\n      }\n    }\n\n    const me = this\n    this.relationships.forEach(function (r) {\n      rtn[r] = me.rawjoins[r].data\n    })\n\n    return rtn\n  }\n\n  /**\n   * @method addField\n   * Add a data field after the initial model definition.\n   * @param {string} fieldname\n   * The name of the field.\n   * @param {object} [fieldConfiguration=null]\n   * The field configuration (see cfg#fields for syntax).\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addField (field, fieldcfg, suppressEvents) {\n    if (typeof fieldcfg === 'boolean') {\n      suppressEvents = fieldcfg\n      fieldcfg = null\n    }\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    const me = this\n    let cfg = null\n    if (field.toLowerCase() !== 'id') {\n      if (typeof field === 'object') {\n        if (!field.name) {\n          throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.')\n        }\n        cfg = field\n        field = cfg.name\n        delete cfg.name\n      }\n\n      if (me[field] !== undefined) {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '')\n        }\n        delete me[field]\n      }\n\n      // Create the data field as an object attribute & getter/setter\n      me.fields[field] = cfg || me.fields[field] || {}\n      me.fields[field].required = NGN.coalesce(me.fields[field].required, false)\n\n      if (!me.fields[field].hasOwnProperty('type')) {\n        if (me.fields[field].hasOwnProperty('default')) {\n          let type = NGN.typeof(me.fields[field].default)\n          type = type.charAt(0).toUpperCase() + type.slice(1)\n          me.fields[field].type = eval(type)\n        }\n      }\n      me.fields[field].type = NGN.coalesce(me.fields[field].type, String)\n      if (field === me.idAttribute && me.autoid === true) {\n        me.fields[field].type = String\n        me.fields[field]['default'] = NGN.DATA.util.GUID()\n      } else {\n        me.fields[field]['default'] = me.fields[field]['default'] || null\n      }\n      me.raw[field] = me.fields[field]['default']\n      me[field] = me.raw[field]\n\n      Object.defineProperty(me, field, {\n        get: function () {\n          return me.raw[field]\n        },\n        set: function (value) {\n          let old = me.raw[field]\n          me.raw[field] = value\n          let c = {\n            action: 'update',\n            field: field,\n            old: old,\n            new: me.raw[field]\n          }\n          this.changelog.push(c)\n          this.emit('field.update', c)\n          if (!me.validate(field)) {\n            me.emit('field.invalid', {\n              field: field\n            })\n          }\n        }\n      })\n\n      if (!suppressEvents) {\n        let c = {\n          action: 'create',\n          field: field\n        }\n        this.changelog.push(c)\n        this.emit('field.create', c)\n      }\n\n      // Add field validators\n      if (me.fields.hasOwnProperty(field)) {\n        if (me.fields[field].hasOwnProperty('pattern')) {\n          me.addValidator(field, me.fields[field].pattern)\n        }\n        ['min', 'max', 'enum'].forEach(function (v) {\n          if (me.fields[field].hasOwnProperty(v)) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators[v](me.fields[field][v], val)\n            })\n          }\n        })\n        if (me.fields[field].hasOwnProperty('required')) {\n          if (me.fields[field].required) {\n            me.addValidator(field, function (val) {\n              return me._nativeValidators.required(field, val)\n            })\n          }\n        }\n        if (me.fields[field].hasOwnProperty('validate')) {\n          if (typeof me.fields[field] === 'function') {\n            me.addValidator(field, function (val) {\n              return me.fields[field](val)\n            })\n          } else {\n            const source = NGN.stack.pop()\n            console.warn('Invalid custom validation function (in %c' + source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '')\n          }\n        }\n      }\n    } else if (me.id === null && me.autoid) {\n      me.id = NGN.DATA.util.GUID()\n    }\n  }\n\n  /**\n   * @method addVirtual\n   * Add a virtual field dynamically.\n   * @param {string} name\n   * The name of the attribute to add.\n   * @param {function} handler\n   * The synchronous method (or generator) that produces\n   * the desired output.\n   */\n  addVirtual (name, fn) {\n    const me = this\n    Object.defineProperty(this, name, {\n      get: function () {\n        return fn.apply(me)\n      }\n    })\n  }\n\n  /**\n   * @method addRelationshipField\n   * Join another model dynamically.\n   * @param {string} name\n   * The name of the field to add.\n   * @param {Object|NGN.DATA.Model} config\n   * The configuration or data model type. This follows the same syntax\n   * defined in the #joins attribute.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  addRelationshipField (name, cfg, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n\n    if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n      throw new Error(name + ' already exists. It cannot be added to the model again.')\n    }\n\n    if (typeof cfg === 'function' || typeof cfg === 'object' && !cfg.hasOwnProperty('type')) {\n      cfg = {\n        type: cfg\n      }\n    }\n\n    if (!cfg.type) {\n      throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.')\n    }\n\n    cfg.required = NGN.coalesce(cfg.required, true)\n    cfg.default = cfg.default || null\n\n    const me = this\n    let entityType = 'model'\n    if (cfg.type instanceof NGN.DATA.Store) {\n      entityType = 'store'\n    } else if (NGN.typeof(cfg.type) === 'array') {\n      if (cfg.type.length === 0) {\n        throw new Error(name + ' cannot be an empty store. A model must be provided.')\n      }\n      entityType = 'collection'\n    } else if (typeof cfg.type === 'object') {\n      if (cfg.type.model) {\n        entityType = 'store'\n      }\n    }\n\n    if (entityType === 'store') {\n      let storeCfg = {}\n      if (cfg.type instanceof NGN.DATA.Store) {\n        this.rawjoins[name] = cfg.type\n        storeCfg = null\n      } else if (cfg.type.model) {\n        storeCfg = cfg.type\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.')\n      }\n\n      if (storeCfg !== null) {\n        this.rawjoins[name] = new NGN.DATA.Store(storeCfg)\n      }\n      this.applyStoreMonitor(name)\n    } else if (entityType === 'collection') {\n      this.rawjoins[name] = new NGN.DATA.Store({\n        model: cfg.type[0]\n      })\n      this.applyStoreMonitor(name)\n    } else if (!cfg.type.data) {\n      this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type()  // eslint-disable-line new-cap\n      this.applyModelMonitor(name)\n    } else if (cfg.type.data) {\n      this.rawjoins[name] = cfg.type\n      this.applyStoreMonitor(name)\n    } else {\n      throw new Error('Nested store configuration is invalid or was not recognized.')\n    }\n\n    Object.defineProperty(this, name, {\n      enumerable: true,\n      get: function () {\n        return me.rawjoins[name]\n      }\n    })\n\n    if (!suppressEvents) {\n      let c = {\n        action: 'create',\n        field: name\n      }\n      this.changelog.push(c)\n      this.emit('relationship.create', c)\n    }\n  }\n\n  /**\n   * @method applyModelMonitor\n   * Applies event handlers for bubbling model events.\n   * @param {string} field\n   * The relationship field name.\n   * @private\n   */\n  applyModelMonitor (name) {\n    const model = this.rawjoins[name]\n    const me = this\n\n    model.on('field.update', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.old,\n        new: delta.new,\n        join: true\n      })\n    })\n\n    model.on('field.create', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: null,\n        new: null,\n        join: true\n      })\n    })\n\n    model.on('field.remove', function (delta) {\n      me.emit('field.update', {\n        action: 'update',\n        field: name + '.' + delta.field,\n        old: delta.value,\n        new: null,\n        join: true\n      })\n    })\n  }\n\n  /**\n   * @method applyStoreMonitor\n   * Applies event handlers for store data.\n   * @param {string} name\n   * Name of the raw join.\n   * @private\n   */\n  applyStoreMonitor (name) {\n    if (!this.rawjoins.hasOwnProperty(name)) {\n      return\n    }\n    if (this.rawjoins[name].hasOwnProperty('proxy')) {\n      const me = this\n\n      this.rawjoins[name].on('record.create', function (record) {\n        let old = me[name].data\n        old.pop()\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n        me.emit('field.update', c)\n      })\n      this.rawjoins[name].on('record.update', function (record, delta) {\n        if (!delta) {\n          return\n        }\n        let c = {\n          action: 'update',\n          field: name + '.' + delta.field,\n          join: true,\n          old: delta.old,\n          new: delta.new\n        }\n        me.emit('field.update', c)\n      })\n      this.rawjoins[name].on('record.delete', function (record) {\n        let old = me[name].data\n        old.push(record.data)\n        let c = {\n          action: 'update',\n          field: name,\n          join: true,\n          old: old,\n          new: me[name].data\n        }\n        me.emit('field.update', c)\n      })\n    }\n  }\n\n  /**\n   * @method removeField\n   * Remove a field from the data model.\n   * @param {string} name\n   * Name of the field to remove.\n   */\n  removeField (name) {\n    if (this.raw.hasOwnProperty(name)) {\n      let val = this.raw[name]\n      delete this[name]\n      delete this.fields[name] // eslint-disable-line no-undef\n      delete this.raw[name] // eslint-disable-line no-undef\n      if (this.invalidDataAttributes.indexOf(name) >= 0) {\n        this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1)\n      }\n      let c = {\n        action: 'delete',\n        field: name,\n        value: val\n      }\n      this.emit('field.remove', c)\n      this.changelog.push(c)\n    }\n  }\n\n  /**\n   * @method removeVirtual\n   * Remove a virtual field.\n   * @param {string} name\n   * Name of the field.\n   */\n  removeVirtual (name) {\n    delete this[name]\n  }\n\n  /**\n   * @method removeRelationshipField\n   * Remove an existing join dynamically.\n   * @param {string} name\n   * The name of the relationship field to remove.\n   * @param {boolean} [suppressEvents=false]\n   * Set to `true` to prevent events from firing when the field is added.\n   */\n  removeRelationshipField (name, suppressEvents) {\n    suppressEvents = suppressEvents !== undefined ? suppressEvents : false\n    if (this.joins.hasOwnProperty(name)) {\n      let val = this.rawjoins[name]\n      delete this.rawjoins[name]\n      delete this[name]\n      delete this.joins[name]\n      if (!suppressEvents) {\n        let c = {\n          action: 'delete',\n          field: name,\n          old: val,\n          join: true\n        }\n        this.changelog.push(c)\n        this.emit('relationship.remove', c)\n      }\n    }\n  }\n\n  /**\n   * @method undo\n   * A rollback function to undo changes. This operation affects\n   * the changelog. It is possible to undo an undo (i.e. redo).\n   * This works with relationship creating/removing relationship fields,\n   * but not updates to the related model. To undo changes to a relationship\n   * field, the `undo()` method _of the related model_ must be called.\n   * @param {number} [OperationCount=1]\n   * The number of operations to \"undo\". Defaults to a single operation.\n   */\n  undo (back) {\n    back = back || 1\n    let old = this.changelog.splice(this.changelog.length - back, back)\n    const me = this\n\n    old.reverse().forEach(function (change) {\n      if (!(typeof change.join === 'boolean' ? change.join : false)) {\n        switch (change.action) {\n          case 'update':\n            me[change.field] = change.old\n            break\n          case 'create':\n            me.removeField(change.field)\n            break\n          case 'delete':\n            me.addField(change.field)\n            me[change.field] = me.old\n            break\n        }\n      } else {\n        switch (change.action) {\n          case 'create':\n            me.removeRelationshipField(change.field)\n            break\n          case 'delete':\n            me.addRelationshipField(change.field)\n            me[change.field] = change.old\n            break\n        }\n      }\n    })\n  }\n\n  /**\n   * @method load\n   * Load a data record. This clears the #history. #modified\n   * will be set to `false`, as though the record has been untouched.\n   * @param {object} data\n   * The data to apply to the model.\n   */\n  load (data) {\n    data = data || {}\n\n    // Handle data maps\n    const me = this\n    if (this._dataMap !== null) {\n      Object.keys(this.reverseMap).forEach(function (key) {\n        if (data.hasOwnProperty(key)) {\n          data[me.reverseMap[key]] = data[key]\n          delete data[key]\n        }\n      })\n    }\n\n    // Loop through the keys and add data fields\n    Object.keys(data).forEach(function (key) {\n      if (me.fields.hasOwnProperty(key)) {\n        if (me.raw.hasOwnProperty(key)) {\n          me.raw[key] = data[key]\n        } else if (key === me.idAttribute) {\n          me.id = data[key]\n        }\n      } else if (me.joins.hasOwnProperty(key)) {\n        // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n        // tmp.load(data[key])\n        // me.rawjoin[key] = tmp\n        me.rawjoins[key].load(data[key])\n      } else {\n        try {\n          const source = NGN.stack.pop()\n          console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '')\n        } catch (e) {\n          console.warn('%c' + key + '%c specified as a data field but is not defined in the model.', NGN.css, '')\n        }\n      }\n    })\n\n    this.setUnmodified()\n  }\n}\n\nNGN.DATA = NGN.DATA || {}\n\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    const ModelLoader = function (data) {\n      let model = new Model(cfg)\n      if (data) {\n        model.load(data)\n      }\n      return model\n    }\n\n    return ModelLoader\n  }),\n\n  Entity: NGN.private(Model)\n})\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA\n}\n","'use strict';\n\n/**\n * @class NGN.DATA.Model\n * Represents a data model/record.\n * @extends NGN.Class\n * @fires field.update\n * Fired when a datafield value is changed.\n * @fires field.create\n * Fired when a datafield is created.\n * @fires field.remove\n * Fired when a datafield is deleted.\n * @fires field.invalid\n * Fired when an invalid value is detected in an data field.\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar Model = function (_NGN$EventEmitter) {\n  _inherits(Model, _NGN$EventEmitter);\n\n  function Model(config) {\n    _classCallCheck(this, Model);\n\n    config = config || {};\n\n    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Model).call(this));\n\n    var me = _this;\n\n    Object.defineProperties(_this, {\n      /**\n       * @cfg {String} [idAttribute='id']\n       * Setting this allows an attribute of the object to be used as the ID.\n       * For example, if an email is the ID of a user, this would be set to\n       * `email`.\n       */\n      idAttribute: NGN.privateconst(config.idAttribute || 'id'),\n\n      /**\n       * @cfg {object} fields\n       * A private object containing the data fields of the model, including\n       * validators & default values.\n       * ```js\n       * fields: {\n       *   fieldname: {\n       *     required: true,\n       *     type: String,\n       *     default: 'default field value'\n       *   },\n       *   fieldname2: null // Uses default field config (default value is null)\n       * }\n       * ```\n       */\n      /**\n       * @datafield {string} [id=null]\n       * The unique ID of the person.\n       */\n      fields: NGN.private(config.fields || {\n        id: {\n          required: true,\n          type: String,\n          'default': config.id || null\n        }\n      }),\n\n      /**\n       * @cfg {object|NGN.DATA.Model|NGN.DATA.Store} relationships\n       * An object containing fields that reference another data set. This can\n       * contain a configuration, an NGN.DATA.Model, or an NGN.DATA.Store.\n       * ```js\n       * // Metadata\n       * relationships: {\n       *   fieldname: {\n       *     required: true,\n       *     ref: MyModel\n       *   },\n       *   fieldname2: {\n       *     required: false,\n       *     ref: MyDataStore,\n       *     default: {}\n       *   }\n       * }\n       * // or\n       * relationships: {\n       *   fieldname: MyModel\n       * }\n       * ```\n       * Using the second syntax assumes the field **is required**.\n       *\n       * It is then possible to reference a join by the fieldname. For example:\n       *\n       * ```js\n       * console.log(MyModel.fieldname.data) // Displays the MyModel data.\n       * ```\n       * @type {[type]}\n       */\n      joins: NGN.private(config.relationships || {}),\n\n      /**\n       * @cfg {Object} virtuals\n       * A private object containing virtual data attributes and generated data.\n       * Virtual datafields are derived values. They are not part of the\n       * underlying data.\n       *\n       * **Example:**\n       *\n       * ```js\n       * let Model = new NGN.DATA.Model({\n       *   fields: {\n       *     dateOfBirth: null\n       *   },\n       *   virtuals: {\n       *     age: function () {\n       *       return YearsApart(new Date(), this.dateOfBirth)\n       *     }\n       *   }\n       * })\n       * ```\n       * The `age` example above compares the `dateOfBirth` field\n       * to the current date, expecting a numeric response.\n       * @private\n       */\n      virtuals: NGN.private(config.virtuals || {}),\n\n      /**\n       * @property {Object}\n       * The validation rules used to verify data integrity when persisting to a datasource.\n       * @private\n       */\n      validators: NGN.private({}),\n\n      /**\n       * @cfgproperty {boolean} [validation=true]\n       * Toggle data validation using this.\n       */\n      validation: NGN.public(NGN.coalesce(config.validation, true)),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model is new or does not exist according to the persistence store.\n       * @private\n       * @readonly\n       */\n      isNew: NGN.private(true),\n\n      /**\n       * @property {Boolean}\n       * Indicates the model has been destroyed/deleted and should no longer exist.\n       * @private\n       * @readonly\n       */\n      isDestroyed: NGN.private(false),\n\n      /**\n       * @property {String} [oid=null]\n       * The raw object ID, which is either the #id or #idAttribute depending\n       * on how the object is configured.\n       * @private\n       */\n      oid: NGN.private(config[_this.idAttribute] || null),\n\n      /**\n       * @cfg {boolean} [autoid=false]\n       * If the NGN.DATA.Model#idAttribute/id is not provided for a record,\n       * unique ID will be automatically generated for it. This means there\n       * will not be a `null` ID.\n       *\n       * An NGN.DATA.Store using a model with this set to `true` will never\n       * have a duplicate record, since the #id or #idAttribute will always\n       * be unique.\n       */\n      autoid: NGN.public(NGN.coalesce(config.autoid, false)),\n\n      benchmark: NGN.private(null),\n\n      /**\n       * @cfgproperty {Date|Number} [expires]\n       * When this is set to a date/time, the model record will be marked\n       * as expired at the specified time/date. If a number is specified\n       * (milliseconds), the record will be marked as expired after the\n       * specified time period has elapsed. When a record/model is marked as\n       * \"expired\", it triggers the `expired` event. By default, expired\n       * records/models within an NGN.DATA.Store will be removed from the store.\n       *\n       * Setting this to any value less than `0` disables expiration.\n       * @fires expired\n       * Triggered when the model/record expires.\n       */\n      expiration: NGN.private(null),\n\n      // Used to hold a setTimeout method for expiration events.\n      expirationTimeout: NGN.private(null),\n\n      // Used to prevent expiration of a record.\n      ignoreTTL: NGN.private(false),\n\n      /**\n       * @property {Number} created\n       * The date/time when the model is created. This is represented as\n       * the number of milliseconds since the epoch (Jan 1, 1970, 00:00:00 UTC).\n       * @private\n       */\n      createDate: NGN.privateconst(Date.now()),\n\n      /**\n       * @method setUnmodified\n       * This method forces the model to be viewed as unmodified, as though\n       * the record was just loaded from it's source. This method should only\n       * be used when custom loading data. The #load method automatically\n       * invokes this when record data is loaded. This also clears the history,\n       * just as if the record is brand new.\n       * @private\n       */\n      setUnmodified: NGN.privateconst(function () {\n        this.benchmark = this.checksum;\n        this.changelog = [];\n      }),\n\n      /**\n       * @cfg {Boolean} [allowInvalidSave=false]\n       * Set this to true to allow a save even though not all of the data properties\n       * pass validation tests.\n       */\n      allowInvalidSave: NGN.private(NGN.coalesce(config.allowInvalidSave, false)),\n\n      /**\n       * @cfg {Boolean} [disableDataValidation=false]\n       * Only used when #save is called. Setting this to `true` will bypass data validation.\n       */\n      disableDataValidation: NGN.private(NGN.coalesce(config.disableDataValidation, false)),\n\n      invalidDataAttributes: NGN.private([]),\n\n      initialDataAttributes: NGN.private([]),\n\n      /**\n       * @property {array} changelog\n       * An ordered array of changes made to the object data properties.\n       * This cannot be changed manually. Instead, use #history\n       * and #undo to manage this list.\n       * @private\n       */\n      changelog: NGN.private([]),\n\n      _nativeValidators: NGN.privateconst({\n        min: function min(minimum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length >= minimum;\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() >= minimum.parse();\n          }\n\n          return false;\n        },\n\n        max: function max(maximum, value) {\n          if (NGN.typeof(value) === 'array') {\n            return value.length <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'number') {\n            return value <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'string') {\n            return value.trim().length <= maximum;\n          }\n\n          if (NGN.typeof(value) === 'date') {\n            return value.parse() <= maximum.parse();\n          }\n\n          return false;\n        },\n\n        enum: function _enum(valid, value) {\n          return valid.indexOf(value) >= 0;\n        },\n\n        required: function required(field, value) {\n          return me.hasOwnProperty(field) && me[value] !== null;\n        }\n      }),\n\n      /**\n       * @cfgproperty {Object} dataMap\n       * An object mapping model attribute names to data storage field names.\n       *\n       * _Example_\n       * ```\n       * {\n       *   father: 'dad',\n       *\t email: 'eml',\n       *\t image: 'img',\n       *\t displayName: 'dn',\n       *\t firstName: 'gn',\n       *\t lastName: 'sn',\n       *\t middleName: 'mn',\n       *\t gender: 'sex',\n       *\t dob: 'bd',\n       * }\n       * ```\n       */\n      _dataMap: NGN.private(config.dataMap || null),\n      _reverseDataMap: NGN.public(null),\n\n      /**\n       * @property {object} raw\n       * The raw data.\n       * @private\n       */\n      raw: NGN.private({}),\n\n      /**\n       * @property {object} rawjoins\n       * The related data models/stores.\n       * @private\n       */\n      rawjoins: NGN.private({}),\n\n      _store: NGN.private(null)\n    });\n\n    // Make sure there aren't duplicate field names defined (includes joins)\n    var allfields = _this.datafields.concat(_this.virtualdatafields).concat(_this.relationships).filter(function (key, i, a) {\n      return a.indexOf(key) !== i;\n    });\n\n    if (allfields.length > 0) {\n      throw new Error('Duplicate field names exist: ' + allfields.join(', ') + '. Unique fieldnames are required for data fields, virtuals, and relationship fields.');\n    }\n\n    // Make sure an ID reference is available.\n    if (!_this.fields.hasOwnProperty('id')) {\n      config.fields.id = {\n        required: true,\n        type: String,\n        'default': config.id || null\n      };\n    }\n\n    // Add fields\n    Object.keys(_this.fields).forEach(function (field) {\n      if (_typeof(me.fields[field]) !== 'object' && me.fields[field] !== null) {\n        me.fields[field] = {\n          required: true,\n          type: me.fields[field],\n          default: null,\n          name: field\n        };\n      }\n      me.addField(field, true);\n    });\n\n    // Add virtuals\n    Object.keys(_this.virtuals).forEach(function (v) {\n      Object.defineProperty(me, v, NGN.get(function () {\n        return me.virtuals[v].apply(me);\n      }));\n    });\n\n    // Add relationships\n    Object.keys(_this.joins).forEach(function (field) {\n      me.addRelationshipField(field, me.joins[field], true);\n    });\n\n    var events = ['field.update', 'field.create', 'field.remove', 'field.invalid', 'validator.add', 'validator.remove', 'relationship.create', 'relationship.remove', 'expired'];\n\n    if (NGN.BUS) {\n      events.forEach(function (eventName) {\n        me.on(eventName, function () {\n          var args = NGN.slice(arguments);\n          args.push(me);\n          args.unshift(eventName);\n          NGN.BUS.emit.apply(NGN.BUS, args);\n        });\n      });\n    }\n\n    // If an expiration is defined, set it.\n    if (config.hasOwnProperty('expires')) {\n      _this.expires = config.expires;\n    }\n    return _this;\n  }\n\n  _createClass(Model, [{\n    key: 'expire',\n\n\n    /**\n     * @method expire\n     * Forcibly expire the model/record.\n     * @param {Date|Number} [duration]\n     * Optionally provide a new expiration time. This is an alternative\n     * way of setting #expires. If no value is specified, the record\n     * will immediately be marked as `expired`.\n     */\n    value: function expire(duration) {\n      if (duration) {\n        this.expires = duration;\n        return;\n      }\n\n      if (this.ignoreTTL) {\n        return;\n      }\n\n      // Force expiration.\n      if (!this.expired) {\n        this.expiration = new Date();\n      }\n\n      clearTimeout(this.expirationTimeout);\n\n      this.emit('expired', this);\n    }\n\n    /**\n     * @method disableExpiration\n     * Do not expire this model/record.\n     */\n\n  }, {\n    key: 'disableExpiration',\n    value: function disableExpiration() {\n      this.expires = -1;\n    }\n\n    /**\n      * @method addValidator\n      * Add or update a validation rule for a specific model property.\n      * @param {String} field\n      * The data field to test.\n      * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator\n      * The validation used to test the property value. This should return\n      * `true` when the data is valid and `false` when it is not.\n      *\n      * * When this is a _function_, the value is passed to it as an argument.\n      * * When this is a _String_, the value is compared for an exact match (case sensitive)\n      * * When this is a _Number_, the value is compared for equality.\n      * * When this is a _Date_, the value is compared for exact equality.\n      * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.\n      * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.\n      * * When this is _an array of dates_, the value is compared to each date for equality.\n      * @fires validator.add\n      */\n\n  }, {\n    key: 'addValidator',\n    value: function addValidator(property, validator) {\n      if (!this.hasOwnProperty(property)) {\n        console.warn('No validator could be create for %c' + property + '%c. It is not an attribute of %c' + this.type + '%c.', NGN.css, '', NGN.css, '');\n        return;\n      }\n\n      switch (typeof validator === 'undefined' ? 'undefined' : _typeof(validator)) {\n        case 'function':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(validator);\n          this.emit('validator.add', property);\n          break;\n        case 'object':\n          if (Array.isArray(validator)) {\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.indexOf(value) >= 0;\n            });\n            this.emit('validator.add', property);\n          } else if (validator.test) {\n            // RegExp\n            this.validators[property] = this.validators[property] || [];\n            this.validators[property].push(function (value) {\n              return validator.test(value);\n            });\n            this.emit('validator.add', property);\n          } else {\n            console.warn('No validator could be created for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n          }\n          break;\n        case 'string':\n        case 'number':\n        case 'date':\n          this.validators[property] = this.validators[property] || [];\n          this.validators[property].push(function (value) {\n            return value === validator;\n          });\n          this.emit('validator.add', property);\n          break;\n        default:\n          console.warn('No validator could be create for %c' + property + '%c. The validator appears to be invalid.', NGN.css, '');\n      }\n    }\n\n    /**\n      * @method removeValidator\n      * Remove a data validator from the object.\n      * @param {String} attribute\n      * The name of the attribute to remove from the validators.\n      * @fires validator.remove\n      */\n\n  }, {\n    key: 'removeValidator',\n    value: function removeValidator(attribute) {\n      if (this.validators.hasOwnProperty(attribute)) {\n        delete this.validators[attribute];\n        this.emit('validator.remove', attribute);\n      }\n    }\n\n    /**\n      * @method validate\n      * Validate one or all attributes of the data.\n      * @param {String} [attribute=null]\n      * Validate a specific attribute. By default, all attributes are tested.\n      * @private\n      * @returns {Boolean}\n      * Returns true or false based on the validity of data.\n      */\n\n  }, {\n    key: 'validate',\n    value: function validate(attribute) {\n      var me = this;\n\n      // Single Attribute Validation\n      if (attribute) {\n        if (this.validators.hasOwnProperty(attribute)) {\n          for (var i = 0; i < this.validators[attribute].length; i++) {\n            if (!me.validators[attribute][i](me[attribute])) {\n              me.invalidDataAttributes.indexOf(attribute) < 0 && me.invalidDataAttributes.push(attribute);\n              return false;\n            } else {\n              me.invalidDataAttributes = me.invalidDataAttributes.filter(function (attr) {\n                return attribute !== attr;\n              });\n            }\n          }\n\n          if (!this.validateDataType(attribute)) {\n            this.invalidDataAttributes.push(attribute);\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      // Validate data type of each attribute\n      this.datafields.forEach(function (field) {\n        me.validate(field);\n      });\n    }\n\n    /**\n     * @method validateDataType\n     * Indicates the data types match.\n     * @param {string} fieldname\n     * Name of the field whose data should be validated.\n     * @private\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'validateDataType',\n    value: function validateDataType(field) {\n      var fieldType = NGN.typeof(this[field]);\n      var expectedType = NGN.typeof(this.fields[field].type);\n\n      if (fieldType !== 'null') {\n        return fieldType === expectedType;\n      }\n\n      if (this[field] === null && this.fields[field].required) {\n        if (this.autoid && field === this.idAttribute) {\n          return true;\n        }\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * @method getRelationshipField\n     * Provides specific detail/configuration about a join/relationship.\n     * @param {String} fieldname\n     * The name of the field.\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'getRelationshipField',\n    value: function getRelationshipField(fieldname) {\n      return this.joins[fieldname];\n    }\n\n    /**\n     * @method hasRelationship\n     * Indicates a data join exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasRelationship',\n    value: function hasRelationship(fieldname) {\n      return this.joins.hasOwnProperty(fieldname);\n    }\n\n    /**\n       * @method getDataField\n       * Provides specific detail/configuration about a field.\n       * @param {String} fieldname\n       * The name of the data field.\n       * @returns {Object}\n       */\n\n  }, {\n    key: 'getDataField',\n    value: function getDataField(fieldname) {\n      return this.fields[fieldname];\n    }\n\n    /**\n     * @method hasDataField\n     * Indicates a data field exists.\n     * @param {String} fieldname\n     * The name of the data field.\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'hasDataField',\n    value: function hasDataField(fieldname) {\n      return this.fields.hasOwnProperty(fieldname);\n    }\n\n    /**\n      * @method serialize\n      * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.\n      * Specific data values can be included/excluded using #enumerableProperties & #nonEnumerableProperties.\n      *\n      * Any object property that begins with a special character will be ignored by default. Functions & Setters are always\n      * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.\n      *\n      * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.\n      * The model itself can be returned using #getXRef.\n      * @param {Object} [obj]\n      * Defaults to this object.\n      * @protected\n      */\n\n  }, {\n    key: 'serialize',\n    value: function serialize(obj) {\n      var _obj = obj || this.raw;\n      var rtn = {};\n\n      for (var key in _obj) {\n        _obj.nonEnumerableProperties = _obj.nonEnumerableProperties || '';\n        if (this.fields.hasOwnProperty(key)) {\n          key = key === 'id' ? this.idAttribute : key;\n          if (_obj.hasOwnProperty(key) && _obj.nonEnumerableProperties.indexOf(key) < 0 && /^[a-z0-9 ]$/.test(key.substr(0, 1)) || _obj[key] !== undefined && _obj.enumerableProperties.indexOf(key) >= 0) {\n            var dsc = Object.getOwnPropertyDescriptor(_obj, key);\n            if (!dsc.set) {\n              // Handle everything else\n              switch (_typeof(dsc.value)) {\n                case 'function':\n                  // Support date & regex proxies\n                  if (dsc.value.name === 'Date') {\n                    rtn[key] = _obj[key].refs.toJSON();\n                  } else if (dsc.value.name === 'RegExp') {\n                    rtn[key] = dsc.value();\n                  }\n                  break;\n                case 'object':\n                  // Support array proxies\n                  if (_obj[key] instanceof Array && !Array.isArray(_obj[key])) {\n                    _obj[key] = _obj[key].slice(0);\n                  }\n\n                  rtn[key] = _obj[key];\n                  break;\n                default:\n                  rtn[key] = _obj[key];\n                  break;\n              }\n            }\n          }\n        }\n      }\n\n      var me = this;\n      this.relationships.forEach(function (r) {\n        rtn[r] = me.rawjoins[r].data;\n      });\n\n      return rtn;\n    }\n\n    /**\n     * @method addField\n     * Add a data field after the initial model definition.\n     * @param {string} fieldname\n     * The name of the field.\n     * @param {object} [fieldConfiguration=null]\n     * The field configuration (see cfg#fields for syntax).\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addField',\n    value: function addField(field, fieldcfg, suppressEvents) {\n      if (typeof fieldcfg === 'boolean') {\n        suppressEvents = fieldcfg;\n        fieldcfg = null;\n      }\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      var me = this;\n      var cfg = null;\n      if (field.toLowerCase() !== 'id') {\n        if ((typeof field === 'undefined' ? 'undefined' : _typeof(field)) === 'object') {\n          if (!field.name) {\n            throw new Error('Cannot create data field. The supplied configuration does not contain a unique data field name.');\n          }\n          cfg = field;\n          field = cfg.name;\n          delete cfg.name;\n        }\n\n        if (me[field] !== undefined) {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + field + '%c data field defined multiple times (at %c' + source.path + '%c). Only the last defintion will be used.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + field + '%c data field defined multiple times. Only the last definition will be used.', NGN.css, '', NGN.css, '');\n          }\n          delete me[field];\n        }\n\n        // Create the data field as an object attribute & getter/setter\n        me.fields[field] = cfg || me.fields[field] || {};\n        me.fields[field].required = NGN.coalesce(me.fields[field].required, false);\n\n        if (!me.fields[field].hasOwnProperty('type')) {\n          if (me.fields[field].hasOwnProperty('default')) {\n            var type = NGN.typeof(me.fields[field].default);\n            type = type.charAt(0).toUpperCase() + type.slice(1);\n            me.fields[field].type = eval(type);\n          }\n        }\n        me.fields[field].type = NGN.coalesce(me.fields[field].type, String);\n        if (field === me.idAttribute && me.autoid === true) {\n          me.fields[field].type = String;\n          me.fields[field]['default'] = NGN.DATA.util.GUID();\n        } else {\n          me.fields[field]['default'] = me.fields[field]['default'] || null;\n        }\n        me.raw[field] = me.fields[field]['default'];\n        me[field] = me.raw[field];\n\n        Object.defineProperty(me, field, {\n          get: function get() {\n            return me.raw[field];\n          },\n          set: function set(value) {\n            var old = me.raw[field];\n            me.raw[field] = value;\n            var c = {\n              action: 'update',\n              field: field,\n              old: old,\n              new: me.raw[field]\n            };\n            this.changelog.push(c);\n            this.emit('field.update', c);\n            if (!me.validate(field)) {\n              me.emit('field.invalid', {\n                field: field\n              });\n            }\n          }\n        });\n\n        if (!suppressEvents) {\n          var c = {\n            action: 'create',\n            field: field\n          };\n          this.changelog.push(c);\n          this.emit('field.create', c);\n        }\n\n        // Add field validators\n        if (me.fields.hasOwnProperty(field)) {\n          if (me.fields[field].hasOwnProperty('pattern')) {\n            me.addValidator(field, me.fields[field].pattern);\n          }\n          ['min', 'max', 'enum'].forEach(function (v) {\n            if (me.fields[field].hasOwnProperty(v)) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators[v](me.fields[field][v], val);\n              });\n            }\n          });\n          if (me.fields[field].hasOwnProperty('required')) {\n            if (me.fields[field].required) {\n              me.addValidator(field, function (val) {\n                return me._nativeValidators.required(field, val);\n              });\n            }\n          }\n          if (me.fields[field].hasOwnProperty('validate')) {\n            if (typeof me.fields[field] === 'function') {\n              me.addValidator(field, function (val) {\n                return me.fields[field](val);\n              });\n            } else {\n              var _source = NGN.stack.pop();\n              console.warn('Invalid custom validation function (in %c' + _source.path + '%c). The value passed to the validate attribute must be a function.', NGN.css, '');\n            }\n          }\n        }\n      } else if (me.id === null && me.autoid) {\n        me.id = NGN.DATA.util.GUID();\n      }\n    }\n\n    /**\n     * @method addVirtual\n     * Add a virtual field dynamically.\n     * @param {string} name\n     * The name of the attribute to add.\n     * @param {function} handler\n     * The synchronous method (or generator) that produces\n     * the desired output.\n     */\n\n  }, {\n    key: 'addVirtual',\n    value: function addVirtual(name, fn) {\n      var me = this;\n      Object.defineProperty(this, name, {\n        get: function get() {\n          return fn.apply(me);\n        }\n      });\n    }\n\n    /**\n     * @method addRelationshipField\n     * Join another model dynamically.\n     * @param {string} name\n     * The name of the field to add.\n     * @param {Object|NGN.DATA.Model} config\n     * The configuration or data model type. This follows the same syntax\n     * defined in the #joins attribute.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'addRelationshipField',\n    value: function addRelationshipField(name, cfg, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n\n      if (this.rawjoins.hasOwnProperty(name) || this.fields.hasOwnProperty(name) || this.hasOwnProperty(name)) {\n        throw new Error(name + ' already exists. It cannot be added to the model again.');\n      }\n\n      if (typeof cfg === 'function' || (typeof cfg === 'undefined' ? 'undefined' : _typeof(cfg)) === 'object' && !cfg.hasOwnProperty('type')) {\n        cfg = {\n          type: cfg\n        };\n      }\n\n      if (!cfg.type) {\n        throw new Error('Configuration has no reference! The reference must be an NGN.DATA.Model or NGN.DATA.Store.');\n      }\n\n      cfg.required = NGN.coalesce(cfg.required, true);\n      cfg.default = cfg.default || null;\n\n      var me = this;\n      var entityType = 'model';\n      if (cfg.type instanceof NGN.DATA.Store) {\n        entityType = 'store';\n      } else if (NGN.typeof(cfg.type) === 'array') {\n        if (cfg.type.length === 0) {\n          throw new Error(name + ' cannot be an empty store. A model must be provided.');\n        }\n        entityType = 'collection';\n      } else if (_typeof(cfg.type) === 'object') {\n        if (cfg.type.model) {\n          entityType = 'store';\n        }\n      }\n\n      if (entityType === 'store') {\n        var storeCfg = {};\n        if (cfg.type instanceof NGN.DATA.Store) {\n          this.rawjoins[name] = cfg.type;\n          storeCfg = null;\n        } else if (cfg.type.model) {\n          storeCfg = cfg.type;\n        } else {\n          throw new Error('Nested store configuration is invalid or was not recognized.');\n        }\n\n        if (storeCfg !== null) {\n          this.rawjoins[name] = new NGN.DATA.Store(storeCfg);\n        }\n        this.applyStoreMonitor(name);\n      } else if (entityType === 'collection') {\n        this.rawjoins[name] = new NGN.DATA.Store({\n          model: cfg.type[0]\n        });\n        this.applyStoreMonitor(name);\n      } else if (!cfg.type.data) {\n        this.rawjoins[name] = cfg.default !== null ? new cfg.type(cfg.default) : new cfg.type(); // eslint-disable-line new-cap\n        this.applyModelMonitor(name);\n      } else if (cfg.type.data) {\n        this.rawjoins[name] = cfg.type;\n        this.applyStoreMonitor(name);\n      } else {\n        throw new Error('Nested store configuration is invalid or was not recognized.');\n      }\n\n      Object.defineProperty(this, name, {\n        enumerable: true,\n        get: function get() {\n          return me.rawjoins[name];\n        }\n      });\n\n      if (!suppressEvents) {\n        var c = {\n          action: 'create',\n          field: name\n        };\n        this.changelog.push(c);\n        this.emit('relationship.create', c);\n      }\n    }\n\n    /**\n     * @method applyModelMonitor\n     * Applies event handlers for bubbling model events.\n     * @param {string} field\n     * The relationship field name.\n     * @private\n     */\n\n  }, {\n    key: 'applyModelMonitor',\n    value: function applyModelMonitor(name) {\n      var model = this.rawjoins[name];\n      var me = this;\n\n      model.on('field.update', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.old,\n          new: delta.new,\n          join: true\n        });\n      });\n\n      model.on('field.create', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: null,\n          new: null,\n          join: true\n        });\n      });\n\n      model.on('field.remove', function (delta) {\n        me.emit('field.update', {\n          action: 'update',\n          field: name + '.' + delta.field,\n          old: delta.value,\n          new: null,\n          join: true\n        });\n      });\n    }\n\n    /**\n     * @method applyStoreMonitor\n     * Applies event handlers for store data.\n     * @param {string} name\n     * Name of the raw join.\n     * @private\n     */\n\n  }, {\n    key: 'applyStoreMonitor',\n    value: function applyStoreMonitor(name) {\n      var _this2 = this;\n\n      if (!this.rawjoins.hasOwnProperty(name)) {\n        return;\n      }\n      if (this.rawjoins[name].hasOwnProperty('proxy')) {\n        (function () {\n          var me = _this2;\n\n          _this2.rawjoins[name].on('record.create', function (record) {\n            var old = me[name].data;\n            old.pop();\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n            me.emit('field.update', c);\n          });\n          _this2.rawjoins[name].on('record.update', function (record, delta) {\n            if (!delta) {\n              return;\n            }\n            var c = {\n              action: 'update',\n              field: name + '.' + delta.field,\n              join: true,\n              old: delta.old,\n              new: delta.new\n            };\n            me.emit('field.update', c);\n          });\n          _this2.rawjoins[name].on('record.delete', function (record) {\n            var old = me[name].data;\n            old.push(record.data);\n            var c = {\n              action: 'update',\n              field: name,\n              join: true,\n              old: old,\n              new: me[name].data\n            };\n            me.emit('field.update', c);\n          });\n        })();\n      }\n    }\n\n    /**\n     * @method removeField\n     * Remove a field from the data model.\n     * @param {string} name\n     * Name of the field to remove.\n     */\n\n  }, {\n    key: 'removeField',\n    value: function removeField(name) {\n      if (this.raw.hasOwnProperty(name)) {\n        var val = this.raw[name];\n        delete this[name];\n        delete this.fields[name]; // eslint-disable-line no-undef\n        delete this.raw[name]; // eslint-disable-line no-undef\n        if (this.invalidDataAttributes.indexOf(name) >= 0) {\n          this.invalidDataAttributes.splice(this.invalidDataAttributes.indexOf(name), 1);\n        }\n        var c = {\n          action: 'delete',\n          field: name,\n          value: val\n        };\n        this.emit('field.remove', c);\n        this.changelog.push(c);\n      }\n    }\n\n    /**\n     * @method removeVirtual\n     * Remove a virtual field.\n     * @param {string} name\n     * Name of the field.\n     */\n\n  }, {\n    key: 'removeVirtual',\n    value: function removeVirtual(name) {\n      delete this[name];\n    }\n\n    /**\n     * @method removeRelationshipField\n     * Remove an existing join dynamically.\n     * @param {string} name\n     * The name of the relationship field to remove.\n     * @param {boolean} [suppressEvents=false]\n     * Set to `true` to prevent events from firing when the field is added.\n     */\n\n  }, {\n    key: 'removeRelationshipField',\n    value: function removeRelationshipField(name, suppressEvents) {\n      suppressEvents = suppressEvents !== undefined ? suppressEvents : false;\n      if (this.joins.hasOwnProperty(name)) {\n        var val = this.rawjoins[name];\n        delete this.rawjoins[name];\n        delete this[name];\n        delete this.joins[name];\n        if (!suppressEvents) {\n          var c = {\n            action: 'delete',\n            field: name,\n            old: val,\n            join: true\n          };\n          this.changelog.push(c);\n          this.emit('relationship.remove', c);\n        }\n      }\n    }\n\n    /**\n     * @method undo\n     * A rollback function to undo changes. This operation affects\n     * the changelog. It is possible to undo an undo (i.e. redo).\n     * This works with relationship creating/removing relationship fields,\n     * but not updates to the related model. To undo changes to a relationship\n     * field, the `undo()` method _of the related model_ must be called.\n     * @param {number} [OperationCount=1]\n     * The number of operations to \"undo\". Defaults to a single operation.\n     */\n\n  }, {\n    key: 'undo',\n    value: function undo(back) {\n      back = back || 1;\n      var old = this.changelog.splice(this.changelog.length - back, back);\n      var me = this;\n\n      old.reverse().forEach(function (change) {\n        if (!(typeof change.join === 'boolean' ? change.join : false)) {\n          switch (change.action) {\n            case 'update':\n              me[change.field] = change.old;\n              break;\n            case 'create':\n              me.removeField(change.field);\n              break;\n            case 'delete':\n              me.addField(change.field);\n              me[change.field] = me.old;\n              break;\n          }\n        } else {\n          switch (change.action) {\n            case 'create':\n              me.removeRelationshipField(change.field);\n              break;\n            case 'delete':\n              me.addRelationshipField(change.field);\n              me[change.field] = change.old;\n              break;\n          }\n        }\n      });\n    }\n\n    /**\n     * @method load\n     * Load a data record. This clears the #history. #modified\n     * will be set to `false`, as though the record has been untouched.\n     * @param {object} data\n     * The data to apply to the model.\n     */\n\n  }, {\n    key: 'load',\n    value: function load(data) {\n      data = data || {};\n\n      // Handle data maps\n      var me = this;\n      if (this._dataMap !== null) {\n        Object.keys(this.reverseMap).forEach(function (key) {\n          if (data.hasOwnProperty(key)) {\n            data[me.reverseMap[key]] = data[key];\n            delete data[key];\n          }\n        });\n      }\n\n      // Loop through the keys and add data fields\n      Object.keys(data).forEach(function (key) {\n        if (me.fields.hasOwnProperty(key)) {\n          if (me.raw.hasOwnProperty(key)) {\n            me.raw[key] = data[key];\n          } else if (key === me.idAttribute) {\n            me.id = data[key];\n          }\n        } else if (me.joins.hasOwnProperty(key)) {\n          // let tmp = new me.getRelated(key).type() // eslint-disable-line new-cap\n          // tmp.load(data[key])\n          // me.rawjoin[key] = tmp\n          me.rawjoins[key].load(data[key]);\n        } else {\n          try {\n            var source = NGN.stack.pop();\n            console.warn('%c' + key + '%c specified in %c' + source.path + '%c as a data field but is not defined in the model.', NGN.css, '', NGN.css, '');\n          } catch (e) {\n            console.warn('%c' + key + '%c specified as a data field but is not defined in the model.', NGN.css, '');\n          }\n        }\n      });\n\n      this.setUnmodified();\n    }\n  }, {\n    key: 'expires',\n    get: function get() {\n      return this.expiration;\n    },\n    set: function set(value) {\n      var _this3 = this;\n\n      // Validate data type\n      if (NGN.typeof(value) !== 'date' && NGN.typeof(value) !== 'number') {\n        try {\n          var source = NGN.stack.pop();\n          console.warn('Expiration could not be set at %c' + source.path + '%c (Invalid data type. Must be a Date or number).', NGN.css, '');\n        } catch (e) {\n          console.warn('Expiration could not be set (Invalid data type. Must be a Date or number).');\n        }\n\n        return;\n      }\n\n      // Clear existing expiration timer if it is already set.\n      clearTimeout(this.expirationTimeout);\n\n      // If the new value is a number, convert to a date.\n      if (NGN.typeof(value) === 'number') {\n        if (value < 0) {\n          this.ignoreTTL = true;\n          return;\n        }\n\n        var currentDate = new Date();\n\n        value = new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), currentDate.getHours(), currentDate.getMinutes(), currentDate.getSeconds(), currentDate.getMilliseconds() + value);\n      }\n\n      // If the process has reached this far, expiration\n      // actions should be enabled.\n      this.ignoreTTL = false;\n\n      // Set the new expiration time period\n      this.expiration = value;\n\n      // If the record is already expired, immediately trigger the expiration.\n      if (this.expired) {\n        this.expire();\n        return;\n      }\n\n      // If the expiration is in the future, set a timer to expire.\n      var waitPeriod = this.expiration.getTime() - Date.now();\n      this.expirationTimeout = setTimeout(function () {\n        _this3.expire();\n      }, waitPeriod);\n    }\n\n    /**\n     * @property {boolean} expired\n     * Indicates the record/model is expired.\n     */\n\n  }, {\n    key: 'expired',\n    get: function get() {\n      if (this.ignoreTTL) {\n        return false;\n      }\n\n      return Date.now() >= this.expires.getTime();\n    }\n\n    /**\n     * @property {Boolean}\n     * Indicates one or more data properties has changed.\n     * @readonly\n     */\n\n  }, {\n    key: 'modified',\n    get: function get() {\n      return this.checksum !== this.benchmark;\n    }\n\n    /**\n     * @cfgproperty {String/Number/Date} [id=null]\n     * The unique ID of the model object. If #idAttribute is defined,\n     * this will get/set the #idAttribute value.\n     */\n\n  }, {\n    key: 'id',\n    get: function get() {\n      return this.oid;\n    },\n    set: function set(value) {\n      this.oid = value;\n    }\n\n    /**\n     * @property checksum\n     * The unique checksum of the record (i.e. a record fingerprint).\n     * This will change as the data changes.\n     */\n\n  }, {\n    key: 'checksum',\n    get: function get() {\n      return NGN.DATA.util.checksum(JSON.stringify(this.data));\n    }\n\n    /**\n     * @property {Object} dataMap\n     * The current data map.\n     * @private\n     */\n\n  }, {\n    key: 'dataMap',\n    get: function get() {\n      return this._dataMap;\n    },\n    set: function set(value) {\n      this._dataMap = value;\n      this._reverseDataMap = null;\n    }\n\n    /**\n     * @property {NGN.DATA.Store} store\n     * If a store is associated with the model, this will\n     * provide a reference to it. If there is no store, this\n     * will return `null`.\n     */\n\n  }, {\n    key: 'datastore',\n    get: function get() {\n      return this._store;\n    }\n\n    /**\n     * @property {boolean} valid\n     * Indicates the record is valid.\n     */\n\n  }, {\n    key: 'valid',\n    get: function get() {\n      this.validate();\n      return this.invalidDataAttributes.length === 0;\n    }\n\n    /**\n     * @property datafields\n     * Provides an array of data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'datafields',\n    get: function get() {\n      return Object.keys(this.fields);\n    }\n\n    /**\n     * @property reslationships\n     * Provides an array of join fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'relationships',\n    get: function get() {\n      return Object.keys(this.joins);\n    }\n\n    /**\n     * @property virtualdatafields\n     * Provides an array of virtual data fields associated with the model.\n     * @returns {String[]}\n     */\n\n  }, {\n    key: 'virtualdatafields',\n    get: function get() {\n      return Object.keys(this.virtuals);\n    }\n\n    /**\n     * @property {object} reverseMap\n     * Reverses the data map. For example, if the original #dataMap\n     * looks like:\n     *\n     * ```js\n     * {\n     *    firstname: 'gn',\n     *    lastname: 'sn\n     * }\n     * ```\n     *\n     * The reverse map will look like:\n     *\n     * ```js\n     * {\n     *    gn: 'firstname',\n     *    sn: 'lastname\n     * }\n     * ```\n     */\n\n  }, {\n    key: 'reverseMap',\n    get: function get() {\n      var _this4 = this;\n\n      if (this.dataMap !== null) {\n        var _ret2 = function () {\n          if (_this4._reverseDataMap !== null) {\n            return {\n              v: _this4._reverseDataMap\n            };\n          }\n          var rmap = {};\n          var me = _this4;\n          Object.keys(_this4._dataMap).forEach(function (attr) {\n            rmap[me._dataMap[attr]] = attr;\n          });\n          _this4._reverseDataMap = rmap;\n          return {\n            v: rmap\n          };\n        }();\n\n        if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n      }\n      return null;\n    }\n\n    /**\n      * @property data\n      * Creates a JSON representation of the data entity. This is\n      * a record that can be persisted to a database or other data store.\n      * @readonly.\n      */\n\n  }, {\n    key: 'data',\n    get: function get() {\n      var _this5 = this;\n\n      var d = this.serialize();\n      if (!d.hasOwnProperty(this.idAttribute) && this.autoid) {\n        d[this.idAttribute] = this[this.idAttribute];\n      }\n      if (this.dataMap) {\n        (function () {\n          var me = _this5;\n          // Loop through the map keys\n          Object.keys(_this5.dataMap).forEach(function (key) {\n            // If the node contains key, make the mapping\n            if (d.hasOwnProperty(key)) {\n              if (d[key] instanceof NGN.DATA.Model) {\n                d[me.dataMap[key]] = d[key].data;\n              } else {\n                d[me.dataMap[key]] = d[key];\n              }\n              delete d[key];\n            }\n          });\n        })();\n      }\n      return d;\n    }\n\n    /**\n     * @property history\n     * The history of the entity (i.e. changelog).The history\n     * is shown from most recent to oldest change. Keep in mind that\n     * some actions, such as adding new custom fields on the fly, may\n     * be triggered before other updates.\n     * @returns {array}\n     */\n\n  }, {\n    key: 'history',\n    get: function get() {\n      return this.changelog.reverse();\n    }\n  }]);\n\n  return Model;\n}(NGN.EventEmitter);\n\nNGN.DATA = NGN.DATA || {};\n\n// Object.defineProperty(NGN.DATA, 'Model', NGN.public(Entity))\n\nObject.defineProperties(NGN.DATA, {\n  Model: NGN.public(function (cfg) {\n    var ModelLoader = function ModelLoader(data) {\n      var model = new Model(cfg);\n      if (data) {\n        model.load(data);\n      }\n      return model;\n    };\n\n    return ModelLoader;\n  }),\n\n  Entity: NGN.private(Model)\n});\n\nif (NGN.nodelike) {\n  module.exports = NGN.DATA;\n}"],"sourceRoot":"/source/"}