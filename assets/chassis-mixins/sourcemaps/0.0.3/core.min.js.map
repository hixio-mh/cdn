{"version":3,"sources":["core.min.js","core.js"],"names":["window","chassis","Object","defineProperties","apply","enumerable","writable","configurable","value","args","this","core","spliceArgs","arguments","mixin","shift","defineProperty","getObjectPrototype","obj","hasOwnProperty","getPrototypeOf","__proto__","prototype","deduplicate","array","filter","element","index","a","indexOf","argumentObject","baseArgs","Array","slice","call","forEach","arg","concat","push","emit","eventName","payload","event","CustomEvent","detail","e","console","log","document","createEvent","initCustomEvent","e2","initEvent","dispatchEvent","createChildDomMonitor","monitoredElement","callback","subtree","monitor","MutationObserver","mutations","m","type","observe","childList","attributes","characterData"],"mappings":";;;;AAAA,YCAAA,QAAAC,WAOAC,OAAAC,iBAAAH,OAAAC,SAkBAG,OACAC,YAAA,EACAC,UAAA,EACAC,cAAA,EACAC,MAAA,WACA,GAAAC,GAAAC,KAAAC,KAAAC,WAAAC,WACAC,EAAAL,EAAAM,OAEAL,MAAAI,GAAAL,OAWAP,OAAAc,eAAAhB,OAAAC,QAAA,QACAI,YAAA,EACAC,UAAA,EACAC,cAAA,EACAC,OAQAS,mBAAA,SAAAC,GACA,MAAAhB,QAAAiB,eAAA,kBACAjB,OAAAkB,eAAAF,GACAA,EAAAC,eAAA,aACAD,EAAAG,UACAH,EAAAC,eAAA,aACAD,EAAAI,UAGAJ,GAUAK,YAAA,SAAAC,GACA,MAAAA,GAAAC,OAAA,SAAAC,EAAAC,EAAAC,GACA,MAAAA,GAAAC,QAAAH,KAAAC,KAcAf,WAAA,SAAAkB,GACA,GAAArB,MACAsB,EAAAC,MAAAV,UAAAW,MAAAC,KAAAJ,EAUA,OARAC,GAAAI,QAAA,SAAAC,GACAA,YAAAJ,OACAvB,EAAAA,EAAA4B,OAAAD,GAEA3B,EAAA6B,KAAAF,KAIA3B,GAaA8B,KAAA,SAAAb,EAAAc,EAAAC,GACA,GAAAC,EACA,KAEAA,EADAD,EACA,GAAAE,aAAAH,GACAI,OAAAH,IAGA,GAAAE,aAAAH,GAEA,MAAAK,GAGA,GAFAC,QAAAC,IAAAF,GACAH,EAAAM,SAAAC,YAAA,SACAR,EACA,IACAC,EAAAQ,gBAAAV,GAAA,GAAA,GACAI,OAAAH,IAEA,MAAAU,GACAT,EAAAU,UAAAZ,GAAA,GAAA,GACAE,EAAAE,OAAAH,MAGAC,GAAAU,UAAAZ,GAAA,GAAA,GAIAd,EAAA2B,cAAAX,IAqBAY,sBAAA,SAAAC,EAAAC,EAAAC,GACA,GAAAC,GAAA,GAAAC,kBAAA,SAAAC,GACA,IAAA,GAAAC,KAAAD,GACA,cAAAA,EAAAC,GAAAC,MACAN,EAAAD,EAAAK,EAAAC,KAYA,OAPAH,GAAAK,QAAAR,GACAS,WAAA,EACAC,YAAA,EACAC,eAAA,EACAT,QAAA,iBAAAA,IAAAA,IAGAC","file":"core.min.js","sourcesContent":["'use strict';\n\nwindow.chassis = {};\n\n/**\n * @class chassis\n * The root library.\n * @singleton\n */\nObject.defineProperties(window.chassis, {\n  /**\n   * @method apply\n   * Apply a mixin to a DOM element/s.\n   * ```js\n   * var myInputField = document.getElementById('myinput')\n   *\n   * // Apply to a single element\n   * chassis.apply('listinput', myInputField)\n   *\n   * // Alternative syntax\n   * chassis.listinput(myInputField)\n   *\n   * // Apply to multiple elements at once:\n   * chassis.listinput('css > selector > input')\n   * chassis.listinput([HTMLInputElementA, HTMLInputElementB])\n   ```\n   */\n  apply: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: function value() {\n      var args = this.core.spliceArgs(arguments);\n      var mixin = args.shift();\n\n      this[mixin](args);\n    }\n  }\n});\n\n/**\n * @class chassis.core\n * Core functionality used throughout the library.\n * @private\n * @singleton\n */\nObject.defineProperty(window.chassis, 'core', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: {\n    /**\n     * @method getObjectPrototype\n     * A polyfill to support older browsers (IE11)\n     * @param {object|function} obj\n     * The object to return the prototype of.\n     * @private\n     */\n    getObjectPrototype: function getObjectPrototype(obj) {\n      if (Object.hasOwnProperty('getPrototypeOf')) {\n        return Object.getPrototypeOf(obj);\n      } else if (obj.hasOwnProperty('__proto__')) {\n        // eslint-disable-line no-proto\n        return obj.__proto__; // eslint-disable-line no-proto\n      } else if (obj.hasOwnProperty('prototype')) {\n        return obj.prototype;\n      }\n\n      return obj;\n    },\n\n    /**\n     * @method deduplicate\n     * Deduplicate an array.\n     * @param  {array} array\n     * The array to deduplicate\n     * @return {array}\n     */\n    deduplicate: function deduplicate(array) {\n      return array.filter(function (element, index, a) {\n        return a.indexOf(element) === index;\n      });\n    },\n\n    /**\n     * @method spliceArguments\n     * A method to convert function arguments to an array.\n     * This method also looks at each argument to determine\n     * whether it is an array or not. Any array element is\n     * automatically flattened/concatenated into the results.\n     * @param  {arguments} argumentObject\n     * The argument object(s).\n     * @return {array}\n     */\n    spliceArgs: function spliceArgs(argumentObject) {\n      var args = [];\n      var baseArgs = Array.prototype.slice.call(argumentObject);\n\n      baseArgs.forEach(function (arg) {\n        if (arg instanceof Array) {\n          args = args.concat(arg);\n        } else {\n          args.push(arg);\n        }\n      });\n\n      return args;\n    },\n\n    /**\n     * @method emit\n     * A shortcut method for emitting a CustomEvent.\n     * @param {HTMLElement} element\n     * The element from which the event is triggered.\n     * @param {string} eventName\n     * The name of the event.\n     * @param {object} [payload]\n     * An optional payload. This is applied to the event's `detail` attribute.\n     */\n    emit: function emit(element, eventName, payload) {\n      var event;\n      try {\n        if (payload) {\n          event = new CustomEvent(eventName, {\n            detail: payload\n          });\n        } else {\n          event = new CustomEvent(eventName);\n        }\n      } catch (e) {\n        console.log(e);\n        event = document.createEvent('Event');\n        if (payload) {\n          try {\n            event.initCustomEvent(eventName, true, true, {\n              detail: payload\n            });\n          } catch (e2) {\n            event.initEvent(eventName, true, true);\n            event.detail = payload;\n          }\n        } else {\n          event.initEvent(eventName, true, true);\n        }\n      }\n\n      element.dispatchEvent(event);\n    },\n\n    /**\n     * @method createChildDomMonitor\n     * Creates a MutationObserver that only listens for addition/removal of\n     * child DOM elements. This method does not account for attribute modifications\n     * to an element. The observer is triggered immediately.\n     * @param {HTMLElement} monitoredElement\n     * The element to watch.\n     * @param {function} callback\n     * The callback is fired for every childlist mutation observed. The callback\n     * receives two arguments: `element` and `mutation`. The element is a reference\n     * to the monitoredElement. The mutation is the raw mutation object provided\n     * by the observer.\n     * @param {boolean} [subtree=false]\n     * Monitor the children of the monitoredElement's children.\n     * @return {MutationObserver}\n     * The actual mutation observer is returned by this method.\n     * @private\n     */\n    createChildDomMonitor: function createChildDomMonitor(monitoredElement, callback, subtree) {\n      var monitor = new MutationObserver(function (mutations) {\n        for (var m in mutations) {\n          if (mutations[m].type === 'childList') {\n            callback(monitoredElement, mutations[m]);\n          }\n        }\n      });\n\n      monitor.observe(monitoredElement, {\n        childList: true,\n        attributes: false,\n        characterData: false,\n        subtree: typeof subtree === 'boolean' ? subtree : false\n      });\n\n      return monitor;\n    }\n  }\n});","window.chassis = {}\n\n/**\n * @class chassis\n * The root library.\n * @singleton\n */\nObject.defineProperties(window.chassis, {\n  /**\n   * @method apply\n   * Apply a mixin to a DOM element/s.\n   * ```js\n   * var myInputField = document.getElementById('myinput')\n   *\n   * // Apply to a single element\n   * chassis.apply('listinput', myInputField)\n   *\n   * // Alternative syntax\n   * chassis.listinput(myInputField)\n   *\n   * // Apply to multiple elements at once:\n   * chassis.listinput('css > selector > input')\n   * chassis.listinput([HTMLInputElementA, HTMLInputElementB])\n   ```\n   */\n  apply: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: function () {\n      var args = this.core.spliceArgs(arguments)\n      var mixin = args.shift()\n\n      this[mixin](args)\n    }\n  }\n})\n\n/**\n * @class chassis.core\n * Core functionality used throughout the library.\n * @private\n * @singleton\n */\nObject.defineProperty(window.chassis, 'core', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: {\n    /**\n     * @method getObjectPrototype\n     * A polyfill to support older browsers (IE11)\n     * @param {object|function} obj\n     * The object to return the prototype of.\n     * @private\n     */\n    getObjectPrototype: function (obj) {\n      if (Object.hasOwnProperty('getPrototypeOf')) {\n        return Object.getPrototypeOf(obj)\n      } else if (obj.hasOwnProperty('__proto__')) { // eslint-disable-line no-proto\n        return obj.__proto__ // eslint-disable-line no-proto\n      } else if (obj.hasOwnProperty('prototype')) {\n        return obj.prototype\n      }\n\n      return obj\n    },\n\n    /**\n     * @method deduplicate\n     * Deduplicate an array.\n     * @param  {array} array\n     * The array to deduplicate\n     * @return {array}\n     */\n    deduplicate: function (array) {\n      return array.filter(function (element, index, a) {\n        return a.indexOf(element) === index\n      })\n    },\n\n    /**\n     * @method spliceArguments\n     * A method to convert function arguments to an array.\n     * This method also looks at each argument to determine\n     * whether it is an array or not. Any array element is\n     * automatically flattened/concatenated into the results.\n     * @param  {arguments} argumentObject\n     * The argument object(s).\n     * @return {array}\n     */\n    spliceArgs: function (argumentObject) {\n      var args = []\n      var baseArgs = Array.prototype.slice.call(argumentObject)\n\n      baseArgs.forEach(function (arg) {\n        if (arg instanceof Array) {\n          args = args.concat(arg)\n        } else {\n          args.push(arg)\n        }\n      })\n\n      return args\n    },\n\n    /**\n     * @method emit\n     * A shortcut method for emitting a CustomEvent.\n     * @param {HTMLElement} element\n     * The element from which the event is triggered.\n     * @param {string} eventName\n     * The name of the event.\n     * @param {object} [payload]\n     * An optional payload. This is applied to the event's `detail` attribute.\n     */\n    emit: function (element, eventName, payload) {\n      var event\n      try {\n        if (payload) {\n          event = new CustomEvent(eventName, {\n            detail: payload\n          })\n        } else {\n          event = new CustomEvent(eventName)\n        }\n      } catch (e) {\n        console.log(e)\n        event = document.createEvent('Event')\n        if (payload) {\n          try {\n            event.initCustomEvent(eventName, true, true, {\n              detail: payload\n            })\n          } catch (e2) {\n            event.initEvent(eventName, true, true)\n            event.detail = payload\n          }\n        } else {\n          event.initEvent(eventName, true, true)\n        }\n      }\n\n      element.dispatchEvent(event)\n    },\n\n    /**\n     * @method createChildDomMonitor\n     * Creates a MutationObserver that only listens for addition/removal of\n     * child DOM elements. This method does not account for attribute modifications\n     * to an element. The observer is triggered immediately.\n     * @param {HTMLElement} monitoredElement\n     * The element to watch.\n     * @param {function} callback\n     * The callback is fired for every childlist mutation observed. The callback\n     * receives two arguments: `element` and `mutation`. The element is a reference\n     * to the monitoredElement. The mutation is the raw mutation object provided\n     * by the observer.\n     * @param {boolean} [subtree=false]\n     * Monitor the children of the monitoredElement's children.\n     * @return {MutationObserver}\n     * The actual mutation observer is returned by this method.\n     * @private\n     */\n    createChildDomMonitor: function (monitoredElement, callback, subtree) {\n      var monitor = new MutationObserver(function (mutations) {\n        for (var m in mutations) {\n          if (mutations[m].type === 'childList') {\n            callback(monitoredElement, mutations[m])\n          }\n        }\n      })\n\n      monitor.observe(monitoredElement, {\n        childList: true,\n        attributes: false,\n        characterData: false,\n        subtree: typeof subtree === 'boolean' ? subtree : false\n      })\n\n      return monitor\n    }\n  }\n})\n"],"sourceRoot":"/source/"}