{"version":3,"sources":["chassis.mixins.min.js","core.js","listinput.js"],"names":["window","chassis","Object","defineProperties","apply","enumerable","writable","configurable","value","args","this","core","spliceArgs","arguments","mixin","shift","defineProperty","getObjectPrototype","obj","hasOwnProperty","getPrototypeOf","__proto__","prototype","deduplicate","array","filter","element","index","a","indexOf","argumentObject","baseArgs","Array","slice","call","forEach","arg","concat","push","emit","eventName","payload","event","CustomEvent","detail","e","console","log","document","createEvent","initCustomEvent","e2","initEvent","dispatchEvent","createChildDomMonitor","monitoredElement","callback","subtree","monitor","MutationObserver","mutations","m","type","observe","childList","attributes","characterData","listinput","me","querySelectorAll","el","applyListInput","HTMLElement","warn","listData","separator","getAttribute","deduplicateInput","list","querySelector","Error","addEventListener","code","submit","data","get","filesource","inputField","browse","click","inputData","splitInput","length","append","input","replace","RegExp","split","map","toString","trim","i","created","deleted","modified","remove","clear","removed","originalData","setItem","_value","oldValue","old","new","_value2","x"],"mappings":"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","file":"chassis.mixins.min.js","sourcesContent":["'use strict';\n\nwindow.chassis = {};\n\n/**\n * @class chassis\n * The root library.\n * @singleton\n */\nObject.defineProperties(window.chassis, {\n  /**\n   * @method apply\n   * Apply a mixin to a DOM element/s.\n   * ```js\n   * var myInputField = document.getElementById('myinput')\n   *\n   * // Apply to a single element\n   * chassis.apply('listinput', myInputField)\n   *\n   * // Alternative syntax\n   * chassis.listinput(myInputField)\n   *\n   * // Apply to multiple elements at once:\n   * chassis.listinput('css > selector > input')\n   * chassis.listinput([HTMLInputElementA, HTMLInputElementB])\n   ```\n   */\n  apply: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: function value() {\n      var args = this.core.spliceArgs(arguments);\n      var mixin = args.shift();\n\n      this[mixin](args);\n    }\n  }\n});\n\n/**\n * @class chassis.core\n * Core functionality used throughout the library.\n * @private\n * @singleton\n */\nObject.defineProperty(window.chassis, 'core', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: {\n    /**\n     * @method getObjectPrototype\n     * A polyfill to support older browsers (IE11)\n     * @param {object|function} obj\n     * The object to return the prototype of.\n     * @private\n     */\n    getObjectPrototype: function getObjectPrototype(obj) {\n      if (Object.hasOwnProperty('getPrototypeOf')) {\n        return Object.getPrototypeOf(obj);\n      } else if (obj.hasOwnProperty('__proto__')) {\n        // eslint-disable-line no-proto\n        return obj.__proto__; // eslint-disable-line no-proto\n      } else if (obj.hasOwnProperty('prototype')) {\n        return obj.prototype;\n      }\n\n      return obj;\n    },\n\n    /**\n     * @method deduplicate\n     * Deduplicate an array.\n     * @param  {array} array\n     * The array to deduplicate\n     * @return {array}\n     */\n    deduplicate: function deduplicate(array) {\n      return array.filter(function (element, index, a) {\n        return a.indexOf(element) === index;\n      });\n    },\n\n    /**\n     * @method spliceArguments\n     * A method to convert function arguments to an array.\n     * This method also looks at each argument to determine\n     * whether it is an array or not. Any array element is\n     * automatically flattened/concatenated into the results.\n     * @param  {arguments} argumentObject\n     * The argument object(s).\n     * @return {array}\n     */\n    spliceArgs: function spliceArgs(argumentObject) {\n      var args = [];\n      var baseArgs = Array.prototype.slice.call(argumentObject);\n\n      baseArgs.forEach(function (arg) {\n        if (arg instanceof Array) {\n          args = args.concat(arg);\n        } else {\n          args.push(arg);\n        }\n      });\n\n      return args;\n    },\n\n    /**\n     * @method emit\n     * A shortcut method for emitting a CustomEvent.\n     * @param {HTMLElement} element\n     * The element from which the event is triggered.\n     * @param {string} eventName\n     * The name of the event.\n     * @param {object} [payload]\n     * An optional payload. This is applied to the event's `detail` attribute.\n     */\n    emit: function emit(element, eventName, payload) {\n      var event;\n      try {\n        if (payload) {\n          event = new CustomEvent(eventName, {\n            detail: payload\n          });\n        } else {\n          event = new CustomEvent(eventName);\n        }\n      } catch (e) {\n        console.log(e);\n        event = document.createEvent('Event');\n        if (payload) {\n          try {\n            event.initCustomEvent(eventName, true, true, {\n              detail: payload\n            });\n          } catch (e2) {\n            event.initEvent(eventName, true, true);\n            event.detail = payload;\n          }\n        } else {\n          event.initEvent(eventName, true, true);\n        }\n      }\n\n      element.dispatchEvent(event);\n    },\n\n    /**\n     * @method createChildDomMonitor\n     * Creates a MutationObserver that only listens for addition/removal of\n     * child DOM elements. This method does not account for attribute modifications\n     * to an element. The observer is triggered immediately.\n     * @param {HTMLElement} monitoredElement\n     * The element to watch.\n     * @param {function} callback\n     * The callback is fired for every childlist mutation observed. The callback\n     * receives two arguments: `element` and `mutation`. The element is a reference\n     * to the monitoredElement. The mutation is the raw mutation object provided\n     * by the observer.\n     * @param {boolean} [subtree=false]\n     * Monitor the children of the monitoredElement's children.\n     * @return {MutationObserver}\n     * The actual mutation observer is returned by this method.\n     * @private\n     */\n    createChildDomMonitor: function createChildDomMonitor(monitoredElement, callback, subtree) {\n      var monitor = new MutationObserver(function (mutations) {\n        for (var m in mutations) {\n          if (mutations[m].type === 'childList') {\n            callback(monitoredElement, mutations[m]);\n          }\n        }\n      });\n\n      monitor.observe(monitoredElement, {\n        childList: true,\n        attributes: false,\n        characterData: false,\n        subtree: typeof subtree === 'boolean' ? subtree : false\n      });\n\n      return monitor;\n    }\n  }\n});\n\n'use strict';\n\n/**\n * @component chassis-listinput\n * A component that maintains a small dataset of it's elements.\n * @fires append\n * A payload is sent with the data that was added to the list.\n *\n * **Example**\n *\n * ```js\n * {\n *   detail: {\n *   \t data: ['item1', 'item2']\n *   }\n * }\n * ```\n * @fires update\n * Triggered whenever the list is modified. The modifications are\n * delivered to event handlers.\n *\n * ```js\n * {\n *   detail: {\n *     created: ['item1', 'item2'], // The values added to the list.\n *     deleted: ['item1', 'item2'], // The values removed from the list.\n *     modified: [                  // The modified values.\n *     \t {old: 'item1', new: 'item1_changed', index: 0},\n *     \t {old: 'item2', new: 'item2_changed', index: 1}\n *     ]\n *   }\n * }\n * ```\n * @fires remove\n * Triggered when data is removed from the list.\n *\n * **Example Payload**\n * ```js\n * {\n *   detail: {\n *     data: ['item1', 'item2']\n *   }\n * }\n * ```\n * @fires modify\n * Triggered when a list data item is changed.\n *\n * **Example Payload**\n * ```js\n * {\n *   detail: {\n *     index: 0, // First item in the list.\n *     old: 'oldValue',\n *     new: 'newValue' // Current value.\n *   }\n * }\n * ```\n */\nObject.defineProperties(window.chassis, {\n  listinput: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: function value() {\n      var me = this;\n      chassis.core.spliceArgs(arguments).forEach(function (element) {\n        if (typeof element === 'string') {\n          document.querySelectorAll(element).forEach(function (el) {\n            me.applyListInput(el);\n          });\n        } else if (element instanceof HTMLElement) {\n          me.applyListInput(element);\n        } else {\n          console.warn('Could not apply listinput to element. Element is not a valid HTMLElement or CSS selector.');\n          console.log(element);\n        }\n      });\n    }\n  },\n\n  applyListInput: {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: function value(element) {\n      Object.defineProperties(chassis.core.getObjectPrototype(element), {\n        listData: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: []\n        },\n\n        /**\n         * @attribute {string|regexp} [separator=,]\n         * The character used to separate list items. By default, this is a comma.\n         * This can also be a regular expression.\n         */\n        separator: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: element.attributes.hasOwnProperty('separator') ? element.getAttribute('separator') : ','\n        },\n\n        /**\n         * @attribute {boolean} [deduplicate=true]\n         * Setting to `true` (default) assures the list data contains no duplicate\n         * values. Whatever value is defined for this becomes the default for\n         * #deduplicateInput.\n         * @type {Object}\n         */\n        deduplicate: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: element.attributes.hasOwnProperty('deduplicate') ? element.getAttribute('deduplicate') === 'true' : true\n        },\n\n        /**\n         * @attribute {boolean} [deduplicateInput=true]\n         * Ignore duplicate values in the input field.\n         */\n        deduplicateInput: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: element.attributes.hasOwnProperty('deduplicateInput') ? element.getAttribute('deduplicateInput') === 'true' : element.attributes.hasOwnProperty('deduplicate') ? element.getAttribute('deduplicate') === 'true' : true\n        }\n      });\n\n      if (element.attributes.hasOwnProperty('for')) {\n        var list = document.querySelector('#' + element.getAttribute('for'));\n\n        if (list === null) {\n          throw new Error('The specified DOM element, ' + element.getAttribute('for') + ', could not be found or does not exist.');\n        } else {\n          chassis.core.createChildDomMonitor(element, function (detail) {\n            chassis.core.emit(element, 'domchange', detail);\n          });\n        }\n      }\n\n      element.addEventListener('keyup', function (e) {\n        if (e.code === 'Enter') {\n          element.submit();\n        }\n      });\n\n      Object.defineProperties(chassis.core.getObjectPrototype(element), {\n        /**\n         * @property {array} data\n         * The list data.\n         * @readonly\n         */\n        data: {\n          enumerable: true,\n          get: function get() {\n            return this.listData;\n          }\n        },\n\n        // This is a placeholder. When this is converted\n        // to a web component, the filesource will be within\n        // the shadow root.\n        filesource: {\n          enumerable: true,\n          get: function get() {\n            // this.shadowRoot.lastChild\n            return element;\n          }\n        },\n\n        /**\n         * @property inputField\n         * A reference to the input field.\n         * @private\n         */\n        inputField: {\n          enumerable: true,\n          get: function get() {\n            return element;\n          }\n        },\n\n        /**\n         * @method browse\n         * Browse for files.\n         */\n        browse: {\n          value: function value() {\n            if (this.getAttribute('type') === 'file') {\n              this.filesource.click();\n            }\n          }\n        },\n\n        /**\n         * @method submit\n         * This method applies any data in the input field to the\n         * list. Depending on how the component is configured, it\n         * will deduplicate data.\n         */\n        submit: {\n          enumerable: false,\n          value: function value() {\n            var inputData = this.splitInput(this.inputField.value);\n\n            if (inputData.length === 0) {\n              this.inputField.value = '';\n              return;\n            }\n\n            if (this.deduplicate) {\n              inputData = chassis.core.deduplicate(inputData);\n            }\n\n            this.inputField.value = '';\n\n            if (inputData.length === 0) {\n              return;\n            }\n\n            this.append(inputData);\n          }\n        },\n\n        /**\n         * @method splitInput\n         * Separates the input data into an array, optionally applying\n         * deduplication filters when applicable.\n         * @param {string} input\n         * The text data to split.\n         * @private\n         */\n        splitInput: {\n          enumerable: false,\n          value: function value(input) {\n            var me = this;\n\n            input = input.replace(this.separator instanceof RegExp ? this.separator : new RegExp(this.separator + '{1,1000}', 'gi'), this.separator).split(this.separator).map(function (value) {\n              return value.toString().trim();\n            }).filter(function (value, i, a) {\n              if (me.deduplicateInput) {\n                if (a.indexOf(value) !== i) {\n                  return false;\n                }\n              }\n\n              return value.toString().length > 0;\n            });\n\n            return input;\n          }\n        },\n\n        /**\n         * @method append\n         * Append data items to the list. This method can take any number\n         * of data item arguments. It can also take a single array argument.\n         *\n         * **Example**\n         *\n         * ```js\n         * mylist.append('item1', 'item2', 'more items')\n         *\n         * // OR\n         *\n         * mylist.append(['item1', 'item2', 'more items'])\n         * ```\n         * @param {array} [items]\n         * An array of items.\n         */\n        append: {\n          enumerable: true,\n          value: function value() {\n            if (arguments.length === 0) {\n              throw new Error('addData requires at least one argument.');\n            }\n\n            var args = chassis.core.spliceArgs(arguments);\n\n            if (this.deduplicate) {\n              args = chassis.core.deduplicate(args);\n            }\n\n            this.listData = this.listData.concat(args);\n\n            if (this.deduplicate) {\n              this.listData = chassis.core.deduplicate(this.listData);\n            }\n\n            chassis.core.emit(this, 'append', { data: args });\n            chassis.core.emit(this, 'update', {\n              created: args,\n              deleted: [],\n              modified: []\n            });\n          }\n        },\n\n        /**\n         * @method remove\n         * Remove the item at a specified index or indexes. Pass `-1` or `null`\n         * to remove everything.\n         *\n         * **Example**\n         *\n         * ```js\n         * mylist.remove(null) // Removes everything (same as clear())\n         * mylist.remove(-1) // Removes everything (same as clear())\n         * mylist.remove(0) // Removes the first list item.\n         * mylist.remove(0, 3) // Remove the first and fourth list items.\n         * ```\n         * @param {number[]} index\n         */\n        remove: {\n          enumerable: true,\n          value: function value() {\n            if (arguments.length === 0) {\n              return this.clear();\n            } else if (arguments[0] === null || arguments[0] === -1) {\n              return this.clear();\n            }\n\n            var args = chassis.core.spliceArgs(arguments);\n            var removed = [];\n\n            this.listData = this.listData.filter(function (data, index) {\n              if (args.indexOf(index) < 0) {\n                return true;\n              }\n\n              removed.push(data);\n              return false;\n            });\n\n            chassis.core.emit(this, 'remove', { data: removed });\n            chassis.core.emit(this, 'update', {\n              created: [],\n              deleted: removed,\n              modified: []\n            });\n          }\n        },\n\n        /**\n         * @method clear\n         * Removes all items from the data list.\n         */\n        clear: {\n          enumerable: true,\n          value: function value() {\n            var originalData = this.listData;\n\n            this.listData = [];\n\n            chassis.core.emit(this, 'remove', { data: originalData });\n            chassis.core.emit(this, 'update', {\n              created: [],\n              deleted: originalData,\n              modified: []\n            });\n          }\n        },\n\n        /**\n         * @method setItem\n         * Modify a specific data list value at a given index.\n         * @param {number} index\n         * The index of the item within the list (0-based indexing).\n         */\n        setItem: {\n          enumerable: true,\n          value: function value(index, _value) {\n            if (index >= this.listData.length || index < 0) {\n              throw new Error('Index out of bounds. Must be between 0 and the size of the list (current max value: ' + (this.listData.length === 0 ? 0 : this.listData.length - 1) + ')');\n            }\n\n            var oldValue = this.listData[index];\n            this.listData[index] = _value;\n\n            chassis.core.emit(this, 'modified', {\n              index: index,\n              old: oldValue,\n              new: this.listData[index]\n            });\n\n            chassis.core.emit(this, 'update', {\n              created: [],\n              deleted: [],\n              modified: [{ old: oldValue, new: this.listData[index], index: index }]\n            });\n          }\n        },\n\n        /**\n         * @method indexOf\n         * Identifies the first index of a value within the list.\n         * @param {any} value\n         * The value to return from the list.\n         * @return {number}\n         * Returns the index of the value within the data set.\n         * Returns `-1` if the value is not found.\n         */\n        indexOf: {\n          enumerable: true,\n          writable: false,\n          configurable: false,\n          value: function value(_value2) {\n            var index = -1;\n            for (var x = 0; x < this.listData.length; x++) {\n              if (this.listData[x] === _value2) {\n                index = x;\n                break;\n              }\n            }\n            return index;\n          }\n        }\n      });\n    }\n  }\n});","window.chassis = {}\n\n/**\n * @class chassis\n * The root library.\n * @singleton\n */\nObject.defineProperties(window.chassis, {\n  /**\n   * @method apply\n   * Apply a mixin to a DOM element/s.\n   * ```js\n   * var myInputField = document.getElementById('myinput')\n   *\n   * // Apply to a single element\n   * chassis.apply('listinput', myInputField)\n   *\n   * // Alternative syntax\n   * chassis.listinput(myInputField)\n   *\n   * // Apply to multiple elements at once:\n   * chassis.listinput('css > selector > input')\n   * chassis.listinput([HTMLInputElementA, HTMLInputElementB])\n   ```\n   */\n  apply: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: function () {\n      var args = this.core.spliceArgs(arguments)\n      var mixin = args.shift()\n\n      this[mixin](args)\n    }\n  }\n})\n\n/**\n * @class chassis.core\n * Core functionality used throughout the library.\n * @private\n * @singleton\n */\nObject.defineProperty(window.chassis, 'core', {\n  enumerable: false,\n  writable: false,\n  configurable: false,\n  value: {\n    /**\n     * @method getObjectPrototype\n     * A polyfill to support older browsers (IE11)\n     * @param {object|function} obj\n     * The object to return the prototype of.\n     * @private\n     */\n    getObjectPrototype: function (obj) {\n      if (Object.hasOwnProperty('getPrototypeOf')) {\n        return Object.getPrototypeOf(obj)\n      } else if (obj.hasOwnProperty('__proto__')) { // eslint-disable-line no-proto\n        return obj.__proto__ // eslint-disable-line no-proto\n      } else if (obj.hasOwnProperty('prototype')) {\n        return obj.prototype\n      }\n\n      return obj\n    },\n\n    /**\n     * @method deduplicate\n     * Deduplicate an array.\n     * @param  {array} array\n     * The array to deduplicate\n     * @return {array}\n     */\n    deduplicate: function (array) {\n      return array.filter(function (element, index, a) {\n        return a.indexOf(element) === index\n      })\n    },\n\n    /**\n     * @method spliceArguments\n     * A method to convert function arguments to an array.\n     * This method also looks at each argument to determine\n     * whether it is an array or not. Any array element is\n     * automatically flattened/concatenated into the results.\n     * @param  {arguments} argumentObject\n     * The argument object(s).\n     * @return {array}\n     */\n    spliceArgs: function (argumentObject) {\n      var args = []\n      var baseArgs = Array.prototype.slice.call(argumentObject)\n\n      baseArgs.forEach(function (arg) {\n        if (arg instanceof Array) {\n          args = args.concat(arg)\n        } else {\n          args.push(arg)\n        }\n      })\n\n      return args\n    },\n\n    /**\n     * @method emit\n     * A shortcut method for emitting a CustomEvent.\n     * @param {HTMLElement} element\n     * The element from which the event is triggered.\n     * @param {string} eventName\n     * The name of the event.\n     * @param {object} [payload]\n     * An optional payload. This is applied to the event's `detail` attribute.\n     */\n    emit: function (element, eventName, payload) {\n      var event\n      try {\n        if (payload) {\n          event = new CustomEvent(eventName, {\n            detail: payload\n          })\n        } else {\n          event = new CustomEvent(eventName)\n        }\n      } catch (e) {\n        console.log(e)\n        event = document.createEvent('Event')\n        if (payload) {\n          try {\n            event.initCustomEvent(eventName, true, true, {\n              detail: payload\n            })\n          } catch (e2) {\n            event.initEvent(eventName, true, true)\n            event.detail = payload\n          }\n        } else {\n          event.initEvent(eventName, true, true)\n        }\n      }\n\n      element.dispatchEvent(event)\n    },\n\n    /**\n     * @method createChildDomMonitor\n     * Creates a MutationObserver that only listens for addition/removal of\n     * child DOM elements. This method does not account for attribute modifications\n     * to an element. The observer is triggered immediately.\n     * @param {HTMLElement} monitoredElement\n     * The element to watch.\n     * @param {function} callback\n     * The callback is fired for every childlist mutation observed. The callback\n     * receives two arguments: `element` and `mutation`. The element is a reference\n     * to the monitoredElement. The mutation is the raw mutation object provided\n     * by the observer.\n     * @param {boolean} [subtree=false]\n     * Monitor the children of the monitoredElement's children.\n     * @return {MutationObserver}\n     * The actual mutation observer is returned by this method.\n     * @private\n     */\n    createChildDomMonitor: function (monitoredElement, callback, subtree) {\n      var monitor = new MutationObserver(function (mutations) {\n        for (var m in mutations) {\n          if (mutations[m].type === 'childList') {\n            callback(monitoredElement, mutations[m])\n          }\n        }\n      })\n\n      monitor.observe(monitoredElement, {\n        childList: true,\n        attributes: false,\n        characterData: false,\n        subtree: typeof subtree === 'boolean' ? subtree : false\n      })\n\n      return monitor\n    }\n  }\n})\n","'use strict'\n\n/**\n * @component chassis-listinput\n * A component that maintains a small dataset of it's elements.\n * @fires append\n * A payload is sent with the data that was added to the list.\n *\n * **Example**\n *\n * ```js\n * {\n *   detail: {\n *   \t data: ['item1', 'item2']\n *   }\n * }\n * ```\n * @fires update\n * Triggered whenever the list is modified. The modifications are\n * delivered to event handlers.\n *\n * ```js\n * {\n *   detail: {\n *     created: ['item1', 'item2'], // The values added to the list.\n *     deleted: ['item1', 'item2'], // The values removed from the list.\n *     modified: [                  // The modified values.\n *     \t {old: 'item1', new: 'item1_changed', index: 0},\n *     \t {old: 'item2', new: 'item2_changed', index: 1}\n *     ]\n *   }\n * }\n * ```\n * @fires remove\n * Triggered when data is removed from the list.\n *\n * **Example Payload**\n * ```js\n * {\n *   detail: {\n *     data: ['item1', 'item2']\n *   }\n * }\n * ```\n * @fires modify\n * Triggered when a list data item is changed.\n *\n * **Example Payload**\n * ```js\n * {\n *   detail: {\n *     index: 0, // First item in the list.\n *     old: 'oldValue',\n *     new: 'newValue' // Current value.\n *   }\n * }\n * ```\n */\nObject.defineProperties(window.chassis, {\n  listinput: {\n    enumerable: true,\n    writable: false,\n    configurable: false,\n    value: function () {\n      var me = this\n      chassis.core.spliceArgs(arguments).forEach(function (element) {\n        if (typeof element === 'string') {\n          document.querySelectorAll(element).forEach(function (el) {\n            me.applyListInput(el)\n          })\n        } else if (element instanceof HTMLElement) {\n          me.applyListInput(element)\n        } else {\n          console.warn('Could not apply listinput to element. Element is not a valid HTMLElement or CSS selector.')\n          console.log(element)\n        }\n      })\n    }\n  },\n\n  applyListInput: {\n    enumerable: false,\n    writable: false,\n    configurable: false,\n    value: function (element) {\n      Object.defineProperties(chassis.core.getObjectPrototype(element), {\n        listData: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: []\n        },\n\n        /**\n         * @attribute {string|regexp} [separator=,]\n         * The character used to separate list items. By default, this is a comma.\n         * This can also be a regular expression.\n         */\n        separator: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: element.attributes.hasOwnProperty('separator') ? element.getAttribute('separator') : ','\n        },\n\n        /**\n         * @attribute {boolean} [deduplicate=true]\n         * Setting to `true` (default) assures the list data contains no duplicate\n         * values. Whatever value is defined for this becomes the default for\n         * #deduplicateInput.\n         * @type {Object}\n         */\n        deduplicate: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: element.attributes.hasOwnProperty('deduplicate') ? element.getAttribute('deduplicate') === 'true' : true\n        },\n\n        /**\n         * @attribute {boolean} [deduplicateInput=true]\n         * Ignore duplicate values in the input field.\n         */\n        deduplicateInput: {\n          enumerable: false,\n          writable: true,\n          configurable: false,\n          value: element.attributes.hasOwnProperty('deduplicateInput')\n            ? element.getAttribute('deduplicateInput') === 'true'\n            : (element.attributes.hasOwnProperty('deduplicate') ? element.getAttribute('deduplicate') === 'true' : true)\n        }\n      })\n\n      if (element.attributes.hasOwnProperty('for')) {\n        var list = document.querySelector('#' + element.getAttribute('for'))\n\n        if (list === null) {\n          throw new Error('The specified DOM element, ' + element.getAttribute('for') + ', could not be found or does not exist.')\n        } else {\n          chassis.core.createChildDomMonitor(element, function (detail) {\n            chassis.core.emit(element, 'domchange', detail)\n          })\n        }\n      }\n\n      element.addEventListener('keyup', function (e) {\n        if (e.code === 'Enter') {\n          element.submit()\n        }\n      })\n\n      Object.defineProperties(chassis.core.getObjectPrototype(element), {\n        /**\n         * @property {array} data\n         * The list data.\n         * @readonly\n         */\n        data: {\n          enumerable: true,\n          get: function () {\n            return this.listData\n          }\n        },\n\n        // This is a placeholder. When this is converted\n        // to a web component, the filesource will be within\n        // the shadow root.\n        filesource: {\n          enumerable: true,\n          get: function () {\n            // this.shadowRoot.lastChild\n            return element\n          }\n        },\n\n        /**\n         * @property inputField\n         * A reference to the input field.\n         * @private\n         */\n        inputField: {\n          enumerable: true,\n          get: function () {\n            return element\n          }\n        },\n\n        /**\n         * @method browse\n         * Browse for files.\n         */\n        browse: {\n          value: function () {\n            if (this.getAttribute('type') === 'file') {\n              this.filesource.click()\n            }\n          }\n        },\n\n        /**\n         * @method submit\n         * This method applies any data in the input field to the\n         * list. Depending on how the component is configured, it\n         * will deduplicate data.\n         */\n        submit: {\n          enumerable: false,\n          value: function () {\n            var inputData = this.splitInput(this.inputField.value)\n\n            if (inputData.length === 0) {\n              this.inputField.value = ''\n              return\n            }\n\n            if (this.deduplicate) {\n              inputData = chassis.core.deduplicate(inputData)\n            }\n\n            this.inputField.value = ''\n\n            if (inputData.length === 0) {\n              return\n            }\n\n            this.append(inputData)\n          }\n        },\n\n        /**\n         * @method splitInput\n         * Separates the input data into an array, optionally applying\n         * deduplication filters when applicable.\n         * @param {string} input\n         * The text data to split.\n         * @private\n         */\n        splitInput: {\n          enumerable: false,\n          value: function (input) {\n            var me = this\n\n            input = input\n              .replace(this.separator instanceof RegExp ? this.separator : new RegExp(this.separator + '{1,1000}', 'gi'), this.separator)\n              .split(this.separator)\n              .map(function (value) {\n                return value.toString().trim()\n              })\n              .filter(function (value, i, a) {\n                if (me.deduplicateInput) {\n                  if (a.indexOf(value) !== i) {\n                    return false\n                  }\n                }\n\n                return value.toString().length > 0\n              })\n\n            return input\n          }\n        },\n\n        /**\n         * @method append\n         * Append data items to the list. This method can take any number\n         * of data item arguments. It can also take a single array argument.\n         *\n         * **Example**\n         *\n         * ```js\n         * mylist.append('item1', 'item2', 'more items')\n         *\n         * // OR\n         *\n         * mylist.append(['item1', 'item2', 'more items'])\n         * ```\n         * @param {array} [items]\n         * An array of items.\n         */\n        append: {\n          enumerable: true,\n          value: function () {\n            if (arguments.length === 0) {\n              throw new Error('addData requires at least one argument.')\n            }\n\n            var args = chassis.core.spliceArgs(arguments)\n\n            if (this.deduplicate) {\n              args = chassis.core.deduplicate(args)\n            }\n\n            this.listData = this.listData.concat(args)\n\n            if (this.deduplicate) {\n              this.listData = chassis.core.deduplicate(this.listData)\n            }\n\n            chassis.core.emit(this, 'append', {data: args})\n            chassis.core.emit(this, 'update', {\n              created: args,\n              deleted: [],\n              modified: []\n            })\n          }\n        },\n\n        /**\n         * @method remove\n         * Remove the item at a specified index or indexes. Pass `-1` or `null`\n         * to remove everything.\n         *\n         * **Example**\n         *\n         * ```js\n         * mylist.remove(null) // Removes everything (same as clear())\n         * mylist.remove(-1) // Removes everything (same as clear())\n         * mylist.remove(0) // Removes the first list item.\n         * mylist.remove(0, 3) // Remove the first and fourth list items.\n         * ```\n         * @param {number[]} index\n         */\n        remove: {\n          enumerable: true,\n          value: function () {\n            if (arguments.length === 0) {\n              return this.clear()\n            } else if (arguments[0] === null || arguments[0] === -1) {\n              return this.clear()\n            }\n\n            var args = chassis.core.spliceArgs(arguments)\n            var removed = []\n\n            this.listData = this.listData.filter(function (data, index) {\n              if (args.indexOf(index) < 0) {\n                return true\n              }\n\n              removed.push(data)\n              return false\n            })\n\n            chassis.core.emit(this, 'remove', {data: removed})\n            chassis.core.emit(this, 'update', {\n              created: [],\n              deleted: removed,\n              modified: []\n            })\n          }\n        },\n\n        /**\n         * @method clear\n         * Removes all items from the data list.\n         */\n        clear: {\n          enumerable: true,\n          value: function () {\n            var originalData = this.listData\n\n            this.listData = []\n\n            chassis.core.emit(this, 'remove', {data: originalData})\n            chassis.core.emit(this, 'update', {\n              created: [],\n              deleted: originalData,\n              modified: []\n            })\n          }\n        },\n\n        /**\n         * @method setItem\n         * Modify a specific data list value at a given index.\n         * @param {number} index\n         * The index of the item within the list (0-based indexing).\n         */\n        setItem: {\n          enumerable: true,\n          value: function (index, value) {\n            if (index >= this.listData.length || index < 0) {\n              throw new Error('Index out of bounds. Must be between 0 and the size of the list (current max value: ' + (this.listData.length === 0 ? 0 : (this.listData.length - 1)) + ')')\n            }\n\n            var oldValue = this.listData[index]\n            this.listData[index] = value\n\n            chassis.core.emit(this, 'modified', {\n              index: index,\n              old: oldValue,\n              new: this.listData[index]\n            })\n\n            chassis.core.emit(this, 'update', {\n              created: [],\n              deleted: [],\n              modified: [{old: oldValue, new: this.listData[index], index: index}]\n            })\n          }\n        },\n\n        /**\n         * @method indexOf\n         * Identifies the first index of a value within the list.\n         * @param {any} value\n         * The value to return from the list.\n         * @return {number}\n         * Returns the index of the value within the data set.\n         * Returns `-1` if the value is not found.\n         */\n        indexOf: {\n          enumerable: true,\n          writable: false,\n          configurable: false,\n          value: function (value) {\n            var index = -1\n            for (var x = 0; x < this.listData.length; x++) {\n              if (this.listData[x] === value) {\n                index = x\n                break\n              }\n            }\n            return index\n          }\n        }\n      })\n    }\n  }\n})\n"],"sourceRoot":"/source/"}